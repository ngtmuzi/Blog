{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/clean-blog/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/article.styl","path":"css/article.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/variables.styl","path":"css/variables.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/mixins.styl","path":"css/mixins.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Node处理字符编码相关经验.md","hash":"667c28d24c92a3304649df806d5e13b9c93f9402","modified":1498110694774},{"_id":"source/_posts/NodeJS：Stream研究笔记.md","hash":"d4c4a97bfe6eca7f596237e047911cf13c815819","modified":1498110694956},{"_id":"themes/clean-blog/_config.yml","hash":"97944630311f9f336555bbe4c2c4501832ef6168","modified":1497408466410},{"_id":"source/_posts/Proxy对象仿Scala的通配符函数调用.md","hash":"9ed9cc0d081233a16a76befb4fa422fe4c518f50","modified":1498110694882},{"_id":"source/_posts/Proxy实现Promise同步调用逻辑.md","hash":"d69f7ca0b5e59a687ef7e980a0bb5527414af78d","modified":1498110694852},{"_id":"source/_posts/javascript模板渲染研究笔记（一）.md","hash":"94b9f8fff5f7774f1f38f901d71aa14a6e25cbaf","modified":1498110695002},{"_id":"source/_posts/javaScript的函数柯里化.md","hash":"3d0993f3d58ce581b049a74ed86b65aeb1edf1e9","modified":1498110695203},{"_id":"source/_posts/promise的日常应用.md","hash":"e10264b939f2add3f16a6eb2f93843d299e38d78","modified":1498110694927},{"_id":"source/_posts/mingw32缺少posix_memalign函数.md","hash":"4eca234ffa69a71c72e0d5615a994a0f846510e5","modified":1498110695176},{"_id":"source/_posts/一次Node代码bug的追踪过程.md","hash":"70a1a6eee6cecc00fc3b7560da68caa9742cf1ce","modified":1498110695076},{"_id":"source/_posts/博客迁移到hexo.md","hash":"0a29a98f32e5d39ab146489ddf6eb034d5d643e0","modified":1498110695111},{"_id":"source/_posts/个人博客绝赞内测中.md","hash":"7d9f6ff8914b84d436372c8d5ade421e3cffbfa8","modified":1498110695147},{"_id":"source/_posts/在前端确认框上套用Promise.md","hash":"a9167c929f9dda2328ad5364c78969d483c3eba7","modified":1491031690585},{"_id":"themes/clean-blog/README.md","hash":"4fa53a32f64f081660be607d9ed4f4efa28b3b25","modified":1485083344267},{"_id":"source/_posts/实现一个简单的promise队列.md","hash":"a495068598d407a5e9b7ed7ffe1e61309a8bf699","modified":1498104778523},{"_id":"source/_posts/异步编程，asyncawait还是promise？.md","hash":"b623a341ea33efba0ddb0c9c1d01e41d8fe09f37","modified":1498110695232},{"_id":"source/_posts/自己撸一个Promise库的过程.md","hash":"17fd42a81988f2b783dbfb210e3efe34c2516303","modified":1498110695266},{"_id":"themes/clean-blog/languages/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1485083344277},{"_id":"source/_posts/Node监视文件以实现热更新.md","hash":"2f77b3a485428eefe13e9729a4a32a5ba123e484","modified":1494928531092},{"_id":"themes/clean-blog/languages/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1485083344278},{"_id":"themes/clean-blog/languages/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1485083344275},{"_id":"themes/clean-blog/languages/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1485083344281},{"_id":"themes/clean-blog/languages/fr.yml","hash":"10e3529b8492d7a7601d5b35b44d8fc9e8ea8d1b","modified":1485083344284},{"_id":"themes/clean-blog/languages/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1485083344290},{"_id":"themes/clean-blog/languages/pt.yml","hash":"6a31d548092af8af9f25d859063b0589c23ce13a","modified":1485083344293},{"_id":"themes/clean-blog/languages/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1485083344295},{"_id":"themes/clean-blog/languages/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1485083344298},{"_id":"source/_posts/使用socket-io在页面上输出实时日志.md","hash":"c916d85051aa2d050a3cd33734e098649bc43efb","modified":1497430541504},{"_id":"themes/clean-blog/languages/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1485083344301},{"_id":"themes/clean-blog/languages/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1485083344286},{"_id":"themes/clean-blog/LICENSE","hash":"34ac5e147727699d1bbc346b014f2e0bdfbb0947","modified":1485083344262},{"_id":"themes/clean-blog/layout/page.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1485083344571},{"_id":"themes/clean-blog/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1485083344572},{"_id":"themes/clean-blog/layout/layout.ejs","hash":"acc791dc4346c135ce4cac3cdeba6f96708115e5","modified":1485083344568},{"_id":"themes/clean-blog/layout/archive.ejs","hash":"3c3eaf652efe697fe6bbbcc66c346a98f94fe363","modified":1485083344528},{"_id":"source/_posts/屏蔽参数中的敏感字段.md","hash":"3a9a21eebc2a61d7f852a4e509d0fd97fa391dad","modified":1491031352700},{"_id":"source/_posts/解决vue无法捕获input变动的问题.md","hash":"8ade01d6b0dfa1f6c100b122e191ee06b49c7166","modified":1496891267365},{"_id":"themes/clean-blog/source/favicon.ico","hash":"11c8f3376cd3d5c578f72b15265614b1c91c0921","modified":1452563365192},{"_id":"themes/clean-blog/layout/index.ejs","hash":"f05ec4cd1b8d57c234ba54b14547015a0325fcf1","modified":1485084117413},{"_id":"themes/clean-blog/layout/_partial/article-archive.ejs","hash":"75b9b24c226eda4884752a868177b590d3e8b06f","modified":1485083344361},{"_id":"themes/clean-blog/layout/_partial/article-categories.ejs","hash":"b494e4a50f63d66e545da449af18a7198a057bd6","modified":1485083344377},{"_id":"themes/clean-blog/layout/_partial/article-tags.ejs","hash":"12524df0c1ce5136a8f88cea2fe550f9e1b47b19","modified":1485083344439},{"_id":"themes/clean-blog/layout/_partial/article-full.ejs","hash":"12b8388ca3c729104225e44f247246501c925c14","modified":1485083344398},{"_id":"themes/clean-blog/layout/_partial/article-index.ejs","hash":"4545f81383a7209ae582dd090ed2067dab7ffca3","modified":1485087843650},{"_id":"themes/clean-blog/layout/_partial/after-footer.ejs","hash":"da52d35a9a996e90a608a4b0f6cbe47cf512244f","modified":1485086185166},{"_id":"themes/clean-blog/layout/_partial/gallery.ejs","hash":"15e9562d0f6146e25e22856693d1312cd3ade4af","modified":1485083344460},{"_id":"themes/clean-blog/layout/_partial/menu.ejs","hash":"3c51a2a2f950ab2ca80f10d3d3941d5d8cd08ec7","modified":1485083344516},{"_id":"themes/clean-blog/layout/_partial/footer.ejs","hash":"d0bb366dba09b96725a7bf80a4f620ab6182e480","modified":1488174241445},{"_id":"themes/clean-blog/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1485083344519},{"_id":"themes/clean-blog/source/css/article.styl","hash":"64a58eaaf711dd548016b5d67aca00b33bdccdad","modified":1485152447316},{"_id":"themes/clean-blog/source/css/style.styl","hash":"7200d572751c1f5888b3d0df25bf503a3f31ca2d","modified":1485083344607},{"_id":"themes/clean-blog/layout/_partial/head.ejs","hash":"eea3dd6f53b4419d0754e1940ffd5ba96ca00bb2","modified":1495019882920},{"_id":"themes/clean-blog/source/css/base.styl","hash":"c21cf1d759be1457d353870e5dddbbac6404376b","modified":1488174100283},{"_id":"themes/clean-blog/source/css/variables.styl","hash":"06e16f64020cbddf2c2c49ef45f940141a1b2ada","modified":1485086731195},{"_id":"themes/clean-blog/source/css/mixins.styl","hash":"f1daed6271d18f9069a4a41f43fe5588e4dd59cb","modified":1485138971818},{"_id":"themes/clean-blog/source/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1485083344615},{"_id":"themes/clean-blog/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1485083344626},{"_id":"themes/clean-blog/layout/_partial/comments.ejs","hash":"9ad110074486a9c72309ed47d1f6c34d1f84d948","modified":1491985139842},{"_id":"themes/clean-blog/layout/_partial/google-analytics.ejs","hash":"18d40f0033c9d424bfd5b7d50d86d1731426240c","modified":1485151556648},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1485083344621},{"_id":"public/rss2.xml","hash":"d79d574ed9109b332a1934ace1e94e6a441990c4","modified":1498113116594},{"_id":"public/sitemap.xml","hash":"936cffc406e2b8040a0dc5a1c0168b302f1a7de0","modified":1498113116783},{"_id":"public/解决vue无法捕获input变动的问题/index.html","hash":"f49f56e2366861c18b96c0d9f81f818a8cad2d7a","modified":1498113116827},{"_id":"public/异步编程，asyncawait还是promise？/index.html","hash":"60459b3cb80ebca64ec8afda5b2acaaee66254d0","modified":1498113116827},{"_id":"public/屏蔽参数中的敏感字段/index.html","hash":"707e501091c2de97696b43473e7a26da883631fa","modified":1498113116827},{"_id":"public/在前端确认框上套用Promise/index.html","hash":"cd65b7da09b81d00efb53265ae78611eca1cf460","modified":1498113116827},{"_id":"public/博客迁移到hexo/index.html","hash":"1558e583d2b853dc06ae8116df68cc39db58ab11","modified":1498113116827},{"_id":"public/自己撸一个Promise库的过程/index.html","hash":"33da876936ea2ff4c4e2d1a3089d62cdebb76a38","modified":1498113116827},{"_id":"public/javaScript的函数柯里化/index.html","hash":"e00c707a1de8db4693d068f5902919299a00fe6a","modified":1498113116827},{"_id":"public/promise的日常应用/index.html","hash":"a03722254b86b989f2200e79cdfadb227a72e6d6","modified":1498113116828},{"_id":"public/mingw32缺少posix_memalign函数/index.html","hash":"69a78eaf41ac7c1e52d4956e90ca0440989c11a9","modified":1498113116828},{"_id":"public/categories/神秘代码/index.html","hash":"6c937a3415b0f3ffc686bda4d4b6b5f94bcb11da","modified":1498113116828},{"_id":"public/个人博客绝赞内测中/index.html","hash":"6941a67688aaedc619566afc4fe126fba8a1a7cf","modified":1498113116828},{"_id":"public/categories/神秘代码/page/2/index.html","hash":"270bcaf168c66f97e0ee55a8a540437d0e1f5d98","modified":1498113116828},{"_id":"public/categories/亡羊补牢/index.html","hash":"425cfcf6c61b13bb62daa4002dade37dbaf2c504","modified":1498113116829},{"_id":"public/categories/班门弄斧/index.html","hash":"221180635ca5736924df6cdad74a53b8ee08933d","modified":1498113116829},{"_id":"public/categories/随笔/index.html","hash":"1ed79578d2fa3c89b9430698d458cdc64c8b5b26","modified":1498113116829},{"_id":"public/archives/index.html","hash":"c1c3507f9a1b7304c0bd2b59cad76d724fb5be51","modified":1498113116829},{"_id":"public/archives/page/2/index.html","hash":"5c1efc8d8d39136c76e5a9684d0132579ef00a2d","modified":1498113116829},{"_id":"public/archives/page/4/index.html","hash":"0285bd4c8da659691ee73caf5ba0241f593e6eb6","modified":1498113116829},{"_id":"public/archives/page/3/index.html","hash":"5d6069c80a9c2579da0337c482887f387ab1c15d","modified":1498113116829},{"_id":"public/archives/2015/index.html","hash":"938499511bc67a1820a9913384db5136f766fba5","modified":1498113116829},{"_id":"public/archives/2015/11/index.html","hash":"1a66fa0635e39a4c29ae1a336fab9691c5c58ec1","modified":1498113116829},{"_id":"public/archives/2015/12/index.html","hash":"ca80052dd1b6cbd0faa17111e5f24537c1191ec7","modified":1498113116829},{"_id":"public/archives/2016/index.html","hash":"e817b5356b60cb8c68a447891f1341cc8acad43a","modified":1498113116829},{"_id":"public/archives/2016/01/index.html","hash":"fe6cbf3357b04343d17b7e477b9b09a32a2ca559","modified":1498113116829},{"_id":"public/archives/2016/02/index.html","hash":"84bdda46c8b740651a6b509eacf005228cae0862","modified":1498113116830},{"_id":"public/archives/2016/04/index.html","hash":"a90be631d6d2bf099c74d3c1c28e2efc78cce8f4","modified":1498113116830},{"_id":"public/archives/2016/05/index.html","hash":"3019cf01114501cb3d7308214fd87cabbe2b7c3f","modified":1498113116831},{"_id":"public/archives/2016/08/index.html","hash":"03eff9891b102f1daf618654dc2b160cd4058946","modified":1498113116831},{"_id":"public/archives/2017/page/2/index.html","hash":"10167210996c8f4d2370dc179279c4ef73d0d209","modified":1498113116831},{"_id":"public/archives/2017/index.html","hash":"3ca8b8bf4b2327435c18912d12c4a5710e59c254","modified":1498113116831},{"_id":"public/archives/2017/01/index.html","hash":"8e2a49868ecf9d98d5b694bf072a0dfb8b3aa2d7","modified":1498113116831},{"_id":"public/archives/2017/02/index.html","hash":"3772f5ca04fa9d0f816490e4ca831ef0d2476a58","modified":1498113116831},{"_id":"public/archives/2017/05/index.html","hash":"371e2e1c315256ac5b9478d6f5e6a6201894b0cd","modified":1498113116831},{"_id":"public/archives/2017/04/index.html","hash":"0e1b3aea9c74f812009e80162e2538da6b9416f8","modified":1498113116831},{"_id":"public/archives/2017/06/index.html","hash":"c22c495b01ab7787ae7dac442ebea284e5081815","modified":1498113116831},{"_id":"public/index.html","hash":"b36d2b9328078e46bf580f9abe9ba9788f4184f6","modified":1498113116831},{"_id":"public/page/2/index.html","hash":"ab4a29265dcc46152f62cd1de708a33163cc9990","modified":1498113116832},{"_id":"public/page/3/index.html","hash":"a29b7c5bb68116b7cbb38c6fede7ca39093a9240","modified":1498113116832},{"_id":"public/page/4/index.html","hash":"0945f953bfd4637bd9bd90e739454ccba37970cf","modified":1498113116832},{"_id":"public/tags/nodejs/index.html","hash":"7e77a91b380c9a180de44e51f774c86c7553360c","modified":1498113116832},{"_id":"public/tags/encoding/index.html","hash":"5fad9681fb23991a0152b5c815adf6eb80a5f2c8","modified":1498113116832},{"_id":"public/tags/stream/index.html","hash":"cc9d610cac88598451dbe512e9438e56c86805eb","modified":1498113116832},{"_id":"public/tags/javascript/index.html","hash":"b7507b61be59a9dd41ce4f9f00b21df13d08bcab","modified":1498113116832},{"_id":"public/tags/javascript/page/2/index.html","hash":"7e24af4797673b672faa872450632a4ebf538d99","modified":1498113116832},{"_id":"public/tags/Proxy/index.html","hash":"a96b842b19891861a89057f6b32bd61082481295","modified":1498113116832},{"_id":"public/tags/es6/index.html","hash":"afd282a022f62f73ef454cd5ef79e64d8c079cd2","modified":1498113116832},{"_id":"public/tags/Promise/index.html","hash":"51a47650125756efc84a9a0383547fd05cc0c815","modified":1498113116832},{"_id":"public/tags/ES6/index.html","hash":"10cb0450d54a44c0872acb137720741d81723107","modified":1498113116832},{"_id":"public/tags/promise/index.html","hash":"68f6d8424bd83fb5ddf8ebf6f06536820f97f989","modified":1498113116832},{"_id":"public/tags/express/index.html","hash":"dce4e453cf932b2eb8710aaccfa7bfbc91eac304","modified":1498113116832},{"_id":"public/tags/C/index.html","hash":"4e889c76834e1b301565e56e56e2adb76ac36419","modified":1498113116833},{"_id":"public/tags/node/index.html","hash":"e48b21e3b1f0bdf1f4e32f37b73b6f1701859616","modified":1498113116833},{"_id":"public/tags/javaScript/index.html","hash":"f2349f2310221086ad4dee05107ca38376d56cf8","modified":1498113116833},{"_id":"public/tags/前端/index.html","hash":"c24ca524ffb111fc15894328ce3f5689bd150980","modified":1498113116833},{"_id":"public/tags/async/index.html","hash":"a7603eb7e007a76b13421eefc2bf1da143125041","modified":1498113116833},{"_id":"public/tags/es7/index.html","hash":"79a4affdde22ed759beed102d4a5c47a44d0601b","modified":1498113116833},{"_id":"public/tags/node-js/index.html","hash":"b724863a725d498120b19285ad1a5a025dca8ab9","modified":1498113116833},{"_id":"public/tags/socket-io/index.html","hash":"1d73f5cf15fa33f9010abcc12e7003244c3740a7","modified":1498113116833},{"_id":"public/tags/vue/index.html","hash":"854eb4ec814111aca94d0bcb534554cc8ae73ac6","modified":1498113116833},{"_id":"public/tags/jquery/index.html","hash":"158dd638549b9659e8e0b0e354c8baecbade93ea","modified":1498113116833},{"_id":"public/实现一个简单的promise队列/index.html","hash":"02106c33a4ac308634300bc376dcae4cce67c6b2","modified":1498113116833},{"_id":"public/Node监视文件以实现热更新/index.html","hash":"b6b4082cda81ed03b8b3e3d99077c0d90d415c78","modified":1498113116833},{"_id":"public/使用socket-io在页面上输出实时日志/index.html","hash":"3357c4769329f629d42d90f141ab52572c862a59","modified":1498113116833},{"_id":"public/一次Node代码bug的追踪过程/index.html","hash":"ad933660a237000d4a3d66b756541acd18884fc0","modified":1498113116833},{"_id":"public/Proxy实现Promise同步调用逻辑/index.html","hash":"4f1ee3da4c81d616d34b682392540665dbac11a8","modified":1498113116833},{"_id":"public/Node处理字符编码相关经验/index.html","hash":"eea04732919305041e3bc916ff62216c608be441","modified":1498113116833},{"_id":"public/Proxy对象仿Scala的通配符函数调用/index.html","hash":"7ded2cb43d23cfccf0e31270ad8e7bff34bc1385","modified":1498113116833},{"_id":"public/NodeJS：Stream研究笔记/index.html","hash":"e2f758c0ce13257383633211e324d0b3df19479a","modified":1498113116833},{"_id":"public/javascript模板渲染研究笔记（一）/index.html","hash":"a3536ce88424ef83acca3dd76e4b1751df406abe","modified":1498113116833},{"_id":"public/favicon.ico","hash":"11c8f3376cd3d5c578f72b15265614b1c91c0921","modified":1498113116842},{"_id":"public/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1498113116842},{"_id":"public/css/base.css","hash":"566335e15bd0b72a122a10056a172c736d6589b4","modified":1498113119372},{"_id":"public/css/article.css","hash":"b6e5dc135d7a6416b1b8e67bcc32ddf8ab4aa242","modified":1498113119372},{"_id":"public/css/style.css","hash":"f061384a3b9f6cfe927e0b042fa3ec1399c8663b","modified":1498113119372},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498113119372},{"_id":"public/css/mixins.css","hash":"b9e01ee658f10b7b381d209f384c1593237a965c","modified":1498113119373},{"_id":"public/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1498113119373},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1498113119391}],"Category":[{"name":"神秘代码","_id":"cj481v9ze0002i8u0j817tbpk"},{"name":"班门弄斧","_id":"cj481va00000ji8u046vs0p4k"},{"name":"亡羊补牢","_id":"cj481va0c0012i8u07p4or8ne"},{"name":"随笔","_id":"cj481va0k0018i8u0xlu0ujii"}],"Data":[],"Page":[],"Post":[{"title":"Node处理字符编码相关经验","desc":"在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道","date":"2016-05-25T02:10:55.618Z","author":"ngtmuzi","_content":"\n在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：\n\n\n首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用`iconv-lite`就行了\n\n\n自动判断文本编码并解码为UTF8\n---\n```javascript\nvar iconv     = require('iconv-lite');\nvar jschardet = require('jschardet');\nfunction readText(filePath) {\n  var fileData = fs.readFileSync(filePath);\n  var encoding = jschardet.detect(fileData).encoding;\n  if (!iconv.encodingExists(encoding)) encoding = 'utf8';\n  return iconv.decode(fileData, encoding);\n}\n```\n\n`jschardet`模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用`iconv-lite`转成UTF8即可\n\n\n读取GBK编码页面\n---\n```javascript\nvar request = require('request-promise');\nvar iconv   = require('iconv-lite');\nrequest('http://someurl.com', {encoding: null})\n  .then(s=>iconv.decode(s, 'gbk'))\n  .then(console.log, console.error);\n```\n\n将`encoding`指定为`null`的时候`request`模块会返回一个`buffer`，我们将其手动gbk解码即可\n\n\n处理gbk编码的urlencode\n---\n```javascript\nvar iconv   = require('iconv-lite');\nvar gbkStr = '%c4%e3%ba%c3';\niconv.decode(new Buffer(gbkStr.replace(/%/g, ''), 'hex'), 'gbk');\n```\n\n`express`在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成`buffer`之后再解码\n\n\n\n转发无法被解码的urlencode\n---\n\n假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的`%c4%e3%ba%c3`，这个时候再通过`request`去请求的时候，再次做了urlencode，会把原字符串里的百分号转成`%25`，那么目标方接到参数的时候就变成`%25c4%25e3%25ba%25c3`，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下\n```javascript\nvar qs   = require('querystring');\nvar data = {gbkStr: '%c4%e3%ba%c3'};\n\nfunction urlEncode(s) {\n  return qs.escape(s.replace(/%(\\w{2})/g, '-_-$1')).replace(/-_-(\\W{2})/g, '%$1');\n}\n\n//1、使用原生的queryString\nvar url = 'someurl' + qs.stringify(data, null, null, {encodeURIComponent: urlEncode});\n\n//2、直接用于request\nrequest('someurl', {\n  qs                : data,\n  qsStringifyOptions: {options: {encodeURIComponent: urlEncode}}\n}).then(console.log, console.error);\n```\n\n关于`querystring`更多的细节参看[官方文档](https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options)\n\n\n我们可以让`querystring`结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱","source":"_posts/Node处理字符编码相关经验.md","raw":"---\ntitle: Node处理字符编码相关经验\ndesc: 在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道  \ndate: 2016-5-25 10:10:55.618\ntags: \n- nodejs\n- encoding\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：\n\n\n首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用`iconv-lite`就行了\n\n\n自动判断文本编码并解码为UTF8\n---\n```javascript\nvar iconv     = require('iconv-lite');\nvar jschardet = require('jschardet');\nfunction readText(filePath) {\n  var fileData = fs.readFileSync(filePath);\n  var encoding = jschardet.detect(fileData).encoding;\n  if (!iconv.encodingExists(encoding)) encoding = 'utf8';\n  return iconv.decode(fileData, encoding);\n}\n```\n\n`jschardet`模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用`iconv-lite`转成UTF8即可\n\n\n读取GBK编码页面\n---\n```javascript\nvar request = require('request-promise');\nvar iconv   = require('iconv-lite');\nrequest('http://someurl.com', {encoding: null})\n  .then(s=>iconv.decode(s, 'gbk'))\n  .then(console.log, console.error);\n```\n\n将`encoding`指定为`null`的时候`request`模块会返回一个`buffer`，我们将其手动gbk解码即可\n\n\n处理gbk编码的urlencode\n---\n```javascript\nvar iconv   = require('iconv-lite');\nvar gbkStr = '%c4%e3%ba%c3';\niconv.decode(new Buffer(gbkStr.replace(/%/g, ''), 'hex'), 'gbk');\n```\n\n`express`在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成`buffer`之后再解码\n\n\n\n转发无法被解码的urlencode\n---\n\n假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的`%c4%e3%ba%c3`，这个时候再通过`request`去请求的时候，再次做了urlencode，会把原字符串里的百分号转成`%25`，那么目标方接到参数的时候就变成`%25c4%25e3%25ba%25c3`，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下\n```javascript\nvar qs   = require('querystring');\nvar data = {gbkStr: '%c4%e3%ba%c3'};\n\nfunction urlEncode(s) {\n  return qs.escape(s.replace(/%(\\w{2})/g, '-_-$1')).replace(/-_-(\\W{2})/g, '%$1');\n}\n\n//1、使用原生的queryString\nvar url = 'someurl' + qs.stringify(data, null, null, {encodeURIComponent: urlEncode});\n\n//2、直接用于request\nrequest('someurl', {\n  qs                : data,\n  qsStringifyOptions: {options: {encodeURIComponent: urlEncode}}\n}).then(console.log, console.error);\n```\n\n关于`querystring`更多的细节参看[官方文档](https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options)\n\n\n我们可以让`querystring`结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱","slug":"Node处理字符编码相关经验","published":1,"updated":"2017-06-22T05:51:34.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481v9z40000i8u0f4o4k36g","content":"<p>在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：</p>\n<p>首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用<code>iconv-lite</code>就行了</p>\n<h2 id=\"自动判断文本编码并解码为UTF8\"><a href=\"#自动判断文本编码并解码为UTF8\" class=\"headerlink\" title=\"自动判断文本编码并解码为UTF8\"></a>自动判断文本编码并解码为UTF8</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> iconv     = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> jschardet = <span class=\"built_in\">require</span>(<span class=\"string\">'jschardet'</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readText</span>(<span class=\"params\">filePath</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fileData = fs.readFileSync(filePath);</div><div class=\"line\">  <span class=\"keyword\">var</span> encoding = jschardet.detect(fileData).encoding;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!iconv.encodingExists(encoding)) encoding = <span class=\"string\">'utf8'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> iconv.decode(fileData, encoding);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>jschardet</code>模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用<code>iconv-lite</code>转成UTF8即可</p>\n<h2 id=\"读取GBK编码页面\"><a href=\"#读取GBK编码页面\" class=\"headerlink\" title=\"读取GBK编码页面\"></a>读取GBK编码页面</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\">request(<span class=\"string\">'http://someurl.com'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"literal\">null</span>&#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">s</span>=&gt;</span>iconv.decode(s, <span class=\"string\">'gbk'</span>))</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>将<code>encoding</code>指定为<code>null</code>的时候<code>request</code>模块会返回一个<code>buffer</code>，我们将其手动gbk解码即可</p>\n<h2 id=\"处理gbk编码的urlencode\"><a href=\"#处理gbk编码的urlencode\" class=\"headerlink\" title=\"处理gbk编码的urlencode\"></a>处理gbk编码的urlencode</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> gbkStr = <span class=\"string\">'%c4%e3%ba%c3'</span>;</div><div class=\"line\">iconv.decode(<span class=\"keyword\">new</span> Buffer(gbkStr.replace(<span class=\"regexp\">/%/g</span>, <span class=\"string\">''</span>), <span class=\"string\">'hex'</span>), <span class=\"string\">'gbk'</span>);</div></pre></td></tr></table></figure>\n<p><code>express</code>在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成<code>buffer</code>之后再解码</p>\n<h2 id=\"转发无法被解码的urlencode\"><a href=\"#转发无法被解码的urlencode\" class=\"headerlink\" title=\"转发无法被解码的urlencode\"></a>转发无法被解码的urlencode</h2><p>假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的<code>%c4%e3%ba%c3</code>，这个时候再通过<code>request</code>去请求的时候，再次做了urlencode，会把原字符串里的百分号转成<code>%25</code>，那么目标方接到参数的时候就变成<code>%25c4%25e3%25ba%25c3</code>，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> qs   = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">gbkStr</span>: <span class=\"string\">'%c4%e3%ba%c3'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">urlEncode</span>(<span class=\"params\">s</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> qs.escape(s.replace(<span class=\"regexp\">/%(\\w&#123;2&#125;)/g</span>, <span class=\"string\">'-_-$1'</span>)).replace(<span class=\"regexp\">/-_-(\\W&#123;2&#125;)/g</span>, <span class=\"string\">'%$1'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//1、使用原生的queryString</span></div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'someurl'</span> + qs.stringify(data, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、直接用于request</span></div><div class=\"line\">request(<span class=\"string\">'someurl'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">qs</span>                : data,</div><div class=\"line\">  <span class=\"attr\">qsStringifyOptions</span>: &#123;<span class=\"attr\">options</span>: &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;&#125;</div><div class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure></p>\n<p>关于<code>querystring</code>更多的细节参看<a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n<p>我们可以让<code>querystring</code>结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱</p>\n","excerpt":"","more":"<p>在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：</p>\n<p>首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用<code>iconv-lite</code>就行了</p>\n<h2 id=\"自动判断文本编码并解码为UTF8\"><a href=\"#自动判断文本编码并解码为UTF8\" class=\"headerlink\" title=\"自动判断文本编码并解码为UTF8\"></a>自动判断文本编码并解码为UTF8</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> iconv     = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> jschardet = <span class=\"built_in\">require</span>(<span class=\"string\">'jschardet'</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readText</span>(<span class=\"params\">filePath</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fileData = fs.readFileSync(filePath);</div><div class=\"line\">  <span class=\"keyword\">var</span> encoding = jschardet.detect(fileData).encoding;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!iconv.encodingExists(encoding)) encoding = <span class=\"string\">'utf8'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> iconv.decode(fileData, encoding);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>jschardet</code>模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用<code>iconv-lite</code>转成UTF8即可</p>\n<h2 id=\"读取GBK编码页面\"><a href=\"#读取GBK编码页面\" class=\"headerlink\" title=\"读取GBK编码页面\"></a>读取GBK编码页面</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\">request(<span class=\"string\">'http://someurl.com'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"literal\">null</span>&#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">s</span>=&gt;</span>iconv.decode(s, <span class=\"string\">'gbk'</span>))</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>将<code>encoding</code>指定为<code>null</code>的时候<code>request</code>模块会返回一个<code>buffer</code>，我们将其手动gbk解码即可</p>\n<h2 id=\"处理gbk编码的urlencode\"><a href=\"#处理gbk编码的urlencode\" class=\"headerlink\" title=\"处理gbk编码的urlencode\"></a>处理gbk编码的urlencode</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> gbkStr = <span class=\"string\">'%c4%e3%ba%c3'</span>;</div><div class=\"line\">iconv.decode(<span class=\"keyword\">new</span> Buffer(gbkStr.replace(<span class=\"regexp\">/%/g</span>, <span class=\"string\">''</span>), <span class=\"string\">'hex'</span>), <span class=\"string\">'gbk'</span>);</div></pre></td></tr></table></figure>\n<p><code>express</code>在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成<code>buffer</code>之后再解码</p>\n<h2 id=\"转发无法被解码的urlencode\"><a href=\"#转发无法被解码的urlencode\" class=\"headerlink\" title=\"转发无法被解码的urlencode\"></a>转发无法被解码的urlencode</h2><p>假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的<code>%c4%e3%ba%c3</code>，这个时候再通过<code>request</code>去请求的时候，再次做了urlencode，会把原字符串里的百分号转成<code>%25</code>，那么目标方接到参数的时候就变成<code>%25c4%25e3%25ba%25c3</code>，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> qs   = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">gbkStr</span>: <span class=\"string\">'%c4%e3%ba%c3'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">urlEncode</span>(<span class=\"params\">s</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> qs.escape(s.replace(<span class=\"regexp\">/%(\\w&#123;2&#125;)/g</span>, <span class=\"string\">'-_-$1'</span>)).replace(<span class=\"regexp\">/-_-(\\W&#123;2&#125;)/g</span>, <span class=\"string\">'%$1'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//1、使用原生的queryString</span></div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'someurl'</span> + qs.stringify(data, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、直接用于request</span></div><div class=\"line\">request(<span class=\"string\">'someurl'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">qs</span>                : data,</div><div class=\"line\">  <span class=\"attr\">qsStringifyOptions</span>: &#123;<span class=\"attr\">options</span>: &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;&#125;</div><div class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure></p>\n<p>关于<code>querystring</code>更多的细节参看<a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options\">官方文档</a></p>\n<p>我们可以让<code>querystring</code>结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱</p>\n"},{"title":"NodeJS:Stream研究笔记","desc":"相信学过nodejs的人都必然会接触到nodejs中的流（stream）","date":"2016-02-15T13:00:21.199Z","author":"ngtmuzi","_content":"\n相信学过`nodejs`的人都必然会接触到`nodejs`中的流（`stream`），不提从`fs`、`net`、`http`这些基础模块，到`express`、`request`、`mongodb`这些常用模块，处处都有流的身影。在初学时我也曾被`pipe`方法的强大特性吓到，参看`request`的文档：\n\n```javascript\nrequest('http://google.com/doodle.png').pipe(fs.createWriteStream('doodle.png'));\n\nfs.createReadStream('file.json').pipe(request.put('http://mysite.com/obj.json'));\n\nrequest.get('http://google.com/img.png').pipe(request.put('http://mysite.com/img.png'));\n```\n\n从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。\n\n\n流在`nodejs`内部提供的方法都是事件式的，需要用`on`方法将我们的回调函数挂在相应的事件上，如`close`、`end`、`data`、`drain`等，这种形式与`nodejs`异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。\n\n\n流的`pipe`方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个`pipe`就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现`pipe`也不是很复杂，主要的业务代码如下\n\n```javascript\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n};\n```\n\n就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。\n\n---\n\n以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：\n\n* `net.createServer`方法接收一个函数，用于获得`socket`套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次`data`事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……\n\n* `http`也是跟流打交道很多的模块，比如`http.request`函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过`error`事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。\n\n```javascript\nvar req = http.request('http://baidu.com', function (res) {\n  console.log(res.headers);     //调用回调的时候，已经获取到了http头\n  res.on('data', console.log);  //读http正文（表单部分存储于此）\n});\nreq.end('hello');  //只有请求流写完之后，才后真正进行http请求\n````\n* fs模块的文件流有一个很实用的特性，那就是指定读写位置，如`fs.createReadStream`函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，`express`模块中负责静态文件服务的`send`模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句\n```javascript\n// pipe\nvar stream = fs.createReadStream(path, options)\nstream.pipe(res);\n```\n* 而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是`options`中的`flags`参数，当取默认值'w'时，它每次都会重写文件，而改成'r+'，就不会将文件清空。\n\n* `mongodb`的node模块为配合`GridFS`功能，也使用了流的特性来进行文件读写，参见`GridFSBucket`类。\n\n\n在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用`on('error')`来自行捕获，之后就可以愉快地使用各种`pipe`了~","source":"_posts/NodeJS：Stream研究笔记.md","raw":"---\ntitle: NodeJS:Stream研究笔记    \ndesc: 相信学过nodejs的人都必然会接触到nodejs中的流（stream） \ndate: 2016-2-15 21:00:21.199\ntags: \n- nodejs\n- stream  \nauthor: ngtmuzi  \ncategory: 神秘代码\n---\n\n相信学过`nodejs`的人都必然会接触到`nodejs`中的流（`stream`），不提从`fs`、`net`、`http`这些基础模块，到`express`、`request`、`mongodb`这些常用模块，处处都有流的身影。在初学时我也曾被`pipe`方法的强大特性吓到，参看`request`的文档：\n\n```javascript\nrequest('http://google.com/doodle.png').pipe(fs.createWriteStream('doodle.png'));\n\nfs.createReadStream('file.json').pipe(request.put('http://mysite.com/obj.json'));\n\nrequest.get('http://google.com/img.png').pipe(request.put('http://mysite.com/img.png'));\n```\n\n从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。\n\n\n流在`nodejs`内部提供的方法都是事件式的，需要用`on`方法将我们的回调函数挂在相应的事件上，如`close`、`end`、`data`、`drain`等，这种形式与`nodejs`异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。\n\n\n流的`pipe`方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个`pipe`就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现`pipe`也不是很复杂，主要的业务代码如下\n\n```javascript\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n};\n```\n\n就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。\n\n---\n\n以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：\n\n* `net.createServer`方法接收一个函数，用于获得`socket`套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次`data`事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……\n\n* `http`也是跟流打交道很多的模块，比如`http.request`函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过`error`事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。\n\n```javascript\nvar req = http.request('http://baidu.com', function (res) {\n  console.log(res.headers);     //调用回调的时候，已经获取到了http头\n  res.on('data', console.log);  //读http正文（表单部分存储于此）\n});\nreq.end('hello');  //只有请求流写完之后，才后真正进行http请求\n````\n* fs模块的文件流有一个很实用的特性，那就是指定读写位置，如`fs.createReadStream`函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，`express`模块中负责静态文件服务的`send`模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句\n```javascript\n// pipe\nvar stream = fs.createReadStream(path, options)\nstream.pipe(res);\n```\n* 而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是`options`中的`flags`参数，当取默认值'w'时，它每次都会重写文件，而改成'r+'，就不会将文件清空。\n\n* `mongodb`的node模块为配合`GridFS`功能，也使用了流的特性来进行文件读写，参见`GridFSBucket`类。\n\n\n在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用`on('error')`来自行捕获，之后就可以愉快地使用各种`pipe`了~","slug":"NodeJS：Stream研究笔记","published":1,"updated":"2017-06-22T05:51:34.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481v9z90001i8u0qhl1z5cl","content":"<p>相信学过<code>nodejs</code>的人都必然会接触到<code>nodejs</code>中的流（<code>stream</code>），不提从<code>fs</code>、<code>net</code>、<code>http</code>这些基础模块，到<code>express</code>、<code>request</code>、<code>mongodb</code>这些常用模块，处处都有流的身影。在初学时我也曾被<code>pipe</code>方法的强大特性吓到，参看<code>request</code>的文档：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">request(<span class=\"string\">'http://google.com/doodle.png'</span>).pipe(fs.createWriteStream(<span class=\"string\">'doodle.png'</span>));</div><div class=\"line\"></div><div class=\"line\">fs.createReadStream(<span class=\"string\">'file.json'</span>).pipe(request.put(<span class=\"string\">'http://mysite.com/obj.json'</span>));</div><div class=\"line\"></div><div class=\"line\">request.get(<span class=\"string\">'http://google.com/img.png'</span>).pipe(request.put(<span class=\"string\">'http://mysite.com/img.png'</span>));</div></pre></td></tr></table></figure>\n<p>从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。</p>\n<p>流在<code>nodejs</code>内部提供的方法都是事件式的，需要用<code>on</code>方法将我们的回调函数挂在相应的事件上，如<code>close</code>、<code>end</code>、<code>data</code>、<code>drain</code>等，这种形式与<code>nodejs</code>异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。</p>\n<p>流的<code>pipe</code>方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个<code>pipe</code>就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现<code>pipe</code>也不是很复杂，主要的业务代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Stream.prototype.pipe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dest, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> source = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondata</span>(<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (dest.writable) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === dest.write(chunk) &amp;&amp; source.pause) &#123;</div><div class=\"line\">        source.pause();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  source.on(<span class=\"string\">'data'</span>, ondata);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondrain</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (source.readable &amp;&amp; source.resume) &#123;</div><div class=\"line\">      source.resume();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dest.on(<span class=\"string\">'drain'</span>, ondrain);</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。</p>\n<hr>\n<p>以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：</p>\n<ul>\n<li><p><code>net.createServer</code>方法接收一个函数，用于获得<code>socket</code>套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次<code>data</code>事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……</p>\n</li>\n<li><p><code>http</code>也是跟流打交道很多的模块，比如<code>http.request</code>函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过<code>error</code>事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> req = http.request(<span class=\"string\">'http://baidu.com'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(res.headers);     <span class=\"comment\">//调用回调的时候，已经获取到了http头</span></div><div class=\"line\">  res.on(<span class=\"string\">'data'</span>, <span class=\"built_in\">console</span>.log);  <span class=\"comment\">//读http正文（表单部分存储于此）</span></div><div class=\"line\">&#125;);</div><div class=\"line\">req.end(<span class=\"string\">'hello'</span>);  <span class=\"comment\">//只有请求流写完之后，才后真正进行http请求</span></div><div class=\"line\"><span class=\"string\">`</span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>fs模块的文件流有一个很实用的特性，那就是指定读写位置，如<code>fs.createReadStream</code>函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，<code>express</code>模块中负责静态文件服务的<code>send</code>模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// pipe</span></div><div class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(path, options)</div><div class=\"line\">stream.pipe(res);</div></pre></td></tr></table></figure>\n</li>\n<li><p>而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是<code>options</code>中的<code>flags</code>参数，当取默认值’w’时，它每次都会重写文件，而改成’r+’，就不会将文件清空。</p>\n</li>\n<li><p><code>mongodb</code>的node模块为配合<code>GridFS</code>功能，也使用了流的特性来进行文件读写，参见<code>GridFSBucket</code>类。</p>\n</li>\n</ul>\n<p>在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用<code>on(&#39;error&#39;)</code>来自行捕获，之后就可以愉快地使用各种<code>pipe</code>了~</p>\n","excerpt":"","more":"<p>相信学过<code>nodejs</code>的人都必然会接触到<code>nodejs</code>中的流（<code>stream</code>），不提从<code>fs</code>、<code>net</code>、<code>http</code>这些基础模块，到<code>express</code>、<code>request</code>、<code>mongodb</code>这些常用模块，处处都有流的身影。在初学时我也曾被<code>pipe</code>方法的强大特性吓到，参看<code>request</code>的文档：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">request(<span class=\"string\">'http://google.com/doodle.png'</span>).pipe(fs.createWriteStream(<span class=\"string\">'doodle.png'</span>));</div><div class=\"line\"></div><div class=\"line\">fs.createReadStream(<span class=\"string\">'file.json'</span>).pipe(request.put(<span class=\"string\">'http://mysite.com/obj.json'</span>));</div><div class=\"line\"></div><div class=\"line\">request.get(<span class=\"string\">'http://google.com/img.png'</span>).pipe(request.put(<span class=\"string\">'http://mysite.com/img.png'</span>));</div></pre></td></tr></table></figure>\n<p>从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。</p>\n<p>流在<code>nodejs</code>内部提供的方法都是事件式的，需要用<code>on</code>方法将我们的回调函数挂在相应的事件上，如<code>close</code>、<code>end</code>、<code>data</code>、<code>drain</code>等，这种形式与<code>nodejs</code>异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。</p>\n<p>流的<code>pipe</code>方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个<code>pipe</code>就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现<code>pipe</code>也不是很复杂，主要的业务代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Stream.prototype.pipe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dest, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> source = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondata</span>(<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (dest.writable) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === dest.write(chunk) &amp;&amp; source.pause) &#123;</div><div class=\"line\">        source.pause();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  source.on(<span class=\"string\">'data'</span>, ondata);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondrain</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (source.readable &amp;&amp; source.resume) &#123;</div><div class=\"line\">      source.resume();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dest.on(<span class=\"string\">'drain'</span>, ondrain);</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。</p>\n<hr>\n<p>以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：</p>\n<ul>\n<li><p><code>net.createServer</code>方法接收一个函数，用于获得<code>socket</code>套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次<code>data</code>事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……</p>\n</li>\n<li><p><code>http</code>也是跟流打交道很多的模块，比如<code>http.request</code>函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过<code>error</code>事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> req = http.request(<span class=\"string\">'http://baidu.com'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(res.headers);     <span class=\"comment\">//调用回调的时候，已经获取到了http头</span></div><div class=\"line\">  res.on(<span class=\"string\">'data'</span>, <span class=\"built_in\">console</span>.log);  <span class=\"comment\">//读http正文（表单部分存储于此）</span></div><div class=\"line\">&#125;);</div><div class=\"line\">req.end(<span class=\"string\">'hello'</span>);  <span class=\"comment\">//只有请求流写完之后，才后真正进行http请求</span></div><div class=\"line\"><span class=\"string\">`</span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>fs模块的文件流有一个很实用的特性，那就是指定读写位置，如<code>fs.createReadStream</code>函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，<code>express</code>模块中负责静态文件服务的<code>send</code>模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// pipe</span></div><div class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(path, options)</div><div class=\"line\">stream.pipe(res);</div></pre></td></tr></table></figure>\n</li>\n<li><p>而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是<code>options</code>中的<code>flags</code>参数，当取默认值’w’时，它每次都会重写文件，而改成’r+’，就不会将文件清空。</p>\n</li>\n<li><p><code>mongodb</code>的node模块为配合<code>GridFS</code>功能，也使用了流的特性来进行文件读写，参见<code>GridFSBucket</code>类。</p>\n</li>\n</ul>\n<p>在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用<code>on(&#39;error&#39;)</code>来自行捕获，之后就可以愉快地使用各种<code>pipe</code>了~</p>\n"},{"title":"Proxy对象仿Scala的通配符函数调用","desc":"Proxy对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本javascript无法完成的特性","date":"2016-04-23T08:47:40.471Z","author":"ngtmuzi","_content":"\n`Proxy`对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本`javascript`无法完成的特性，在不长的`scala语言`学习过程中，发现这门语言有一个很神奇的通配符`_`，在函数链式调用中，`_`就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：\n```javascript\n[1, 2, 3, 4].map(_.toString());\n```\n\n就是对每个传来的对象，调用他们自身的`toString()`方法，使用ES6中的`Proxy`对象，可以很容易地模拟该特性\n（nodejs v6.0已支持`Proxy`，代码亦可在最新版chrome中运行）\n```javascript\nvar _ = new Proxy({}, {\n  get: function (target, key) {\n    return function (obj) {\n      if (obj && obj[key] && typeof obj[key] !== 'function') return obj[key];\n      var args = arguments;\n      return function (obj) {\n        if (obj && obj[key] && typeof obj[key] === 'function')\n          return obj[key].call(obj, ...args);\n      };\n    };\n  }\n});\n```\n\n除了调用对象自带的方法外，还有取出属性的功能，运行结果如下\n\n```javascript\n[1, 32, 128, 1024].map(_.toString('2'));\n//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]\n\n[{v:123},{v:456}].map(_.v);\n//return [123, 456]\n\nPromise.resolve(new Date())\n  .then(_.getTime())\n  .then(_.toString())\n  .then(_.length)\n  .then(console.log, console.error);\n//return 13\n```\n---\n# 2016-6-8续\n\n之前研究`Proxy`的时候写出来的那个`_`实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个`_`的作用层数，不能继续往里面走，解决的方法当然是继续返回一个`Proxy`，思路如下：\n\n* `_`本身返回一个Proxy，取属性操作返回的也是一个`Proxy`，这些`Proxy`指向一个函数，并在被调用时按顺序取出第一个参数里的属性\n\n* `_`可以预接收参数，接收的参数将在`Proxy`被调用时传给取出来的函数\n\n\n难点是如何知道`Proxy`是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了`Proxy`的相关资料后，我意识到上述的两种情况，对应的`this`应该是不同的，后来又发现过长的调用链每次都要经过多个`Proxy`可能会影响效率，我又改成另外一种形式实现：`Proxy`负责收集参数和属性名，并在最终调用的时候新建一个`Function`，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 `s=>s.xx.yy.zz()` 给简化成 `_.xx.yy.zz()` 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：\n\n```javascript\n/**\n * Created by ngtmuzi on 2016/5/29.\n */\n'use strict';\nconst receiveFn = (...args) => args;\n\n/**\n * chain proxy maker\n * @params {Any} defaultValue\n * @type {Function}\n */\nconst chainProxy = module.exports = function (defaultValue) {\n  var hasDefault   = arguments.length > 0;\n\n  var handle = {\n    get: function (target, property, receiver) {\n      //set prototype to base Proxy Object _\n      if (property === 'prototype') return _;\n      if (property === 'apply') return target.apply;\n      if (property === 'call') return target.call;\n      if (property === 'bind') return target.bind;\n\n      //is number\n      if (!isNaN(+property)) return new Proxy(target.bind(null, `[${property}]`), handle);\n      //return a new Proxy, go on\n      else return new Proxy(target.bind(null, '.' + property), handle);\n    },\n\n    apply: function (target, thisArg, argumentsList) {\n      //if method calling on Proxy Object\n      if (thisArg && thisArg.prototype === _) {\n        //save arguments to chain, and go on\n        return new Proxy(target.bind(null, argumentsList), handle);\n\n      } else {  //calling on outside\n\n        //get the calling chain\n        var chains = target();\n        //pick arguments\n        var args   = [].concat(...chains.filter(Array.isArray));\n\n        //make function body\n        var argNum     = 0;\n        var expression = chains.reduce(function (a, b) {\n          if (typeof b === 'string') return a + b;\n          else if (Array.isArray(b)) return a + `(${b.map(()=> `args[${argNum++}]`)})`;\n        }, 'return _');\n\n        var fnStr = `\n        try{\n          ${expression};\n        }catch(err){\n          ${hasDefault ? 'return defaultValue;' : ''}\n          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '${expression}';\n          throw err;\n        }`;\n\n        var finalFn = new Function(['args', '_', 'defaultValue'], fnStr);\n        return finalFn(args, argumentsList[0], defaultValue);\n      }\n    }\n  };\n\n  var _ = new Proxy(receiveFn, handle);\n  return _;\n};\n```\n\n测试代码如下：\n```javascript\nvar _1 = require('../index')(undefined);\nvar _2 = require('../index')();\nvar _3 = require('../index')({foo: 'bar'});\n\nPromise.resolve({a: 12333})\n  .then(_1.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 1:'), console.error.bind(null, 'catch error1:'))\n\n  .then(()=>({a: 12333}))\n  .then(_2.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'))\n\n  .then(()=>({a: 12333}))\n  .then(_3.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'));\n```\n\n本段代码已经做为模块提交到[npm](https://www.npmjs.com/package/chainproxy)上","source":"_posts/Proxy对象仿Scala的通配符函数调用.md","raw":"---\ntitle: Proxy对象仿Scala的通配符函数调用  \ndesc: Proxy对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本javascript无法完成的特性  \ndate: 2016-4-23 16:47:40.471\ntags: \n- javascript\n- es6\n- Proxy\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n`Proxy`对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本`javascript`无法完成的特性，在不长的`scala语言`学习过程中，发现这门语言有一个很神奇的通配符`_`，在函数链式调用中，`_`就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：\n```javascript\n[1, 2, 3, 4].map(_.toString());\n```\n\n就是对每个传来的对象，调用他们自身的`toString()`方法，使用ES6中的`Proxy`对象，可以很容易地模拟该特性\n（nodejs v6.0已支持`Proxy`，代码亦可在最新版chrome中运行）\n```javascript\nvar _ = new Proxy({}, {\n  get: function (target, key) {\n    return function (obj) {\n      if (obj && obj[key] && typeof obj[key] !== 'function') return obj[key];\n      var args = arguments;\n      return function (obj) {\n        if (obj && obj[key] && typeof obj[key] === 'function')\n          return obj[key].call(obj, ...args);\n      };\n    };\n  }\n});\n```\n\n除了调用对象自带的方法外，还有取出属性的功能，运行结果如下\n\n```javascript\n[1, 32, 128, 1024].map(_.toString('2'));\n//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]\n\n[{v:123},{v:456}].map(_.v);\n//return [123, 456]\n\nPromise.resolve(new Date())\n  .then(_.getTime())\n  .then(_.toString())\n  .then(_.length)\n  .then(console.log, console.error);\n//return 13\n```\n---\n# 2016-6-8续\n\n之前研究`Proxy`的时候写出来的那个`_`实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个`_`的作用层数，不能继续往里面走，解决的方法当然是继续返回一个`Proxy`，思路如下：\n\n* `_`本身返回一个Proxy，取属性操作返回的也是一个`Proxy`，这些`Proxy`指向一个函数，并在被调用时按顺序取出第一个参数里的属性\n\n* `_`可以预接收参数，接收的参数将在`Proxy`被调用时传给取出来的函数\n\n\n难点是如何知道`Proxy`是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了`Proxy`的相关资料后，我意识到上述的两种情况，对应的`this`应该是不同的，后来又发现过长的调用链每次都要经过多个`Proxy`可能会影响效率，我又改成另外一种形式实现：`Proxy`负责收集参数和属性名，并在最终调用的时候新建一个`Function`，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 `s=>s.xx.yy.zz()` 给简化成 `_.xx.yy.zz()` 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：\n\n```javascript\n/**\n * Created by ngtmuzi on 2016/5/29.\n */\n'use strict';\nconst receiveFn = (...args) => args;\n\n/**\n * chain proxy maker\n * @params {Any} defaultValue\n * @type {Function}\n */\nconst chainProxy = module.exports = function (defaultValue) {\n  var hasDefault   = arguments.length > 0;\n\n  var handle = {\n    get: function (target, property, receiver) {\n      //set prototype to base Proxy Object _\n      if (property === 'prototype') return _;\n      if (property === 'apply') return target.apply;\n      if (property === 'call') return target.call;\n      if (property === 'bind') return target.bind;\n\n      //is number\n      if (!isNaN(+property)) return new Proxy(target.bind(null, `[${property}]`), handle);\n      //return a new Proxy, go on\n      else return new Proxy(target.bind(null, '.' + property), handle);\n    },\n\n    apply: function (target, thisArg, argumentsList) {\n      //if method calling on Proxy Object\n      if (thisArg && thisArg.prototype === _) {\n        //save arguments to chain, and go on\n        return new Proxy(target.bind(null, argumentsList), handle);\n\n      } else {  //calling on outside\n\n        //get the calling chain\n        var chains = target();\n        //pick arguments\n        var args   = [].concat(...chains.filter(Array.isArray));\n\n        //make function body\n        var argNum     = 0;\n        var expression = chains.reduce(function (a, b) {\n          if (typeof b === 'string') return a + b;\n          else if (Array.isArray(b)) return a + `(${b.map(()=> `args[${argNum++}]`)})`;\n        }, 'return _');\n\n        var fnStr = `\n        try{\n          ${expression};\n        }catch(err){\n          ${hasDefault ? 'return defaultValue;' : ''}\n          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '${expression}';\n          throw err;\n        }`;\n\n        var finalFn = new Function(['args', '_', 'defaultValue'], fnStr);\n        return finalFn(args, argumentsList[0], defaultValue);\n      }\n    }\n  };\n\n  var _ = new Proxy(receiveFn, handle);\n  return _;\n};\n```\n\n测试代码如下：\n```javascript\nvar _1 = require('../index')(undefined);\nvar _2 = require('../index')();\nvar _3 = require('../index')({foo: 'bar'});\n\nPromise.resolve({a: 12333})\n  .then(_1.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 1:'), console.error.bind(null, 'catch error1:'))\n\n  .then(()=>({a: 12333}))\n  .then(_2.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'))\n\n  .then(()=>({a: 12333}))\n  .then(_3.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'));\n```\n\n本段代码已经做为模块提交到[npm](https://www.npmjs.com/package/chainproxy)上","slug":"Proxy对象仿Scala的通配符函数调用","published":1,"updated":"2017-06-22T05:51:34.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481v9zj0004i8u0e4zxppm3","content":"<p><code>Proxy</code>对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本<code>javascript</code>无法完成的特性，在不长的<code>scala语言</code>学习过程中，发现这门语言有一个很神奇的通配符<code>_</code>，在函数链式调用中，<code>_</code>就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(_.toString());</div></pre></td></tr></table></figure></p>\n<p>就是对每个传来的对象，调用他们自身的<code>toString()</code>方法，使用ES6中的<code>Proxy</code>对象，可以很容易地模拟该特性<br>（nodejs v6.0已支持<code>Proxy</code>，代码亦可在最新版chrome中运行）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</div><div class=\"line\">  <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] !== <span class=\"string\">'function'</span>) <span class=\"keyword\">return</span> obj[key];</div><div class=\"line\">      <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'function'</span>)</div><div class=\"line\">          <span class=\"keyword\">return</span> obj[key].call(obj, ...args);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>除了调用对象自带的方法外，还有取出属性的功能，运行结果如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">32</span>, <span class=\"number\">128</span>, <span class=\"number\">1024</span>].map(_.toString(<span class=\"string\">'2'</span>));</div><div class=\"line\"><span class=\"comment\">//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]</span></div><div class=\"line\"></div><div class=\"line\">[&#123;<span class=\"attr\">v</span>:<span class=\"number\">123</span>&#125;,&#123;<span class=\"attr\">v</span>:<span class=\"number\">456</span>&#125;].map(_.v);</div><div class=\"line\"><span class=\"comment\">//return [123, 456]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</div><div class=\"line\">  .then(_.getTime())</div><div class=\"line\">  .then(_.toString())</div><div class=\"line\">  .then(_.length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div><div class=\"line\"><span class=\"comment\">//return 13</span></div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"2016-6-8续\"><a href=\"#2016-6-8续\" class=\"headerlink\" title=\"2016-6-8续\"></a>2016-6-8续</h1><p>之前研究<code>Proxy</code>的时候写出来的那个<code>_</code>实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个<code>_</code>的作用层数，不能继续往里面走，解决的方法当然是继续返回一个<code>Proxy</code>，思路如下：</p>\n<ul>\n<li><p><code>_</code>本身返回一个Proxy，取属性操作返回的也是一个<code>Proxy</code>，这些<code>Proxy</code>指向一个函数，并在被调用时按顺序取出第一个参数里的属性</p>\n</li>\n<li><p><code>_</code>可以预接收参数，接收的参数将在<code>Proxy</code>被调用时传给取出来的函数</p>\n</li>\n</ul>\n<p>难点是如何知道<code>Proxy</code>是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了<code>Proxy</code>的相关资料后，我意识到上述的两种情况，对应的<code>this</code>应该是不同的，后来又发现过长的调用链每次都要经过多个<code>Proxy</code>可能会影响效率，我又改成另外一种形式实现：<code>Proxy</code>负责收集参数和属性名，并在最终调用的时候新建一个<code>Function</code>，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 <code>s=&gt;s.xx.yy.zz()</code> 给简化成 <code>_.xx.yy.zz()</code> 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by ngtmuzi on 2016/5/29.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> receiveFn = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> args;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * chain proxy maker</div><div class=\"line\"> * @params &#123;Any&#125; defaultValue</div><div class=\"line\"> * @type &#123;Function&#125;</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">const</span> chainProxy = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">defaultValue</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> hasDefault   = <span class=\"built_in\">arguments</span>.length &gt; <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> handle = &#123;</div><div class=\"line\">    <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, property, receiver</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//set prototype to base Proxy Object _</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'prototype'</span>) <span class=\"keyword\">return</span> _;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'apply'</span>) <span class=\"keyword\">return</span> target.apply;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'call'</span>) <span class=\"keyword\">return</span> target.call;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'bind'</span>) <span class=\"keyword\">return</span> target.bind;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//is number</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">isNaN</span>(+property)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">`[<span class=\"subst\">$&#123;property&#125;</span>]`</span>), handle);</div><div class=\"line\">      <span class=\"comment\">//return a new Proxy, go on</span></div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">'.'</span> + property), handle);</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">apply</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, thisArg, argumentsList</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//if method calling on Proxy Object</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (thisArg &amp;&amp; thisArg.prototype === _) &#123;</div><div class=\"line\">        <span class=\"comment\">//save arguments to chain, and go on</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, argumentsList), handle);</div><div class=\"line\"></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//calling on outside</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//get the calling chain</span></div><div class=\"line\">        <span class=\"keyword\">var</span> chains = target();</div><div class=\"line\">        <span class=\"comment\">//pick arguments</span></div><div class=\"line\">        <span class=\"keyword\">var</span> args   = [].concat(...chains.filter(<span class=\"built_in\">Array</span>.isArray));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//make function body</span></div><div class=\"line\">        <span class=\"keyword\">var</span> argNum     = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> expression = chains.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> b === <span class=\"string\">'string'</span>) <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(b)) <span class=\"keyword\">return</span> a + <span class=\"string\">`(<span class=\"subst\">$&#123;b.map(()=&gt; <span class=\"string\">`args[<span class=\"subst\">$&#123;argNum++&#125;</span>]`</span>)&#125;</span>)`</span>;</div><div class=\"line\">        &#125;, <span class=\"string\">'return _'</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> fnStr = <span class=\"string\">`</span></div><div class=\"line\">        try&#123;</div><div class=\"line\">          <span class=\"subst\">$&#123;expression&#125;</span>;</div><div class=\"line\">        &#125;catch(err)&#123;</div><div class=\"line\">          <span class=\"subst\">$&#123;hasDefault ? <span class=\"string\">'return defaultValue;'</span> : <span class=\"string\">''</span>&#125;</span></div><div class=\"line\">          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '<span class=\"subst\">$&#123;expression&#125;</span>';</div><div class=\"line\">          throw err;</div><div class=\"line\">        &#125;`;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> finalFn = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>([<span class=\"string\">'args'</span>, <span class=\"string\">'_'</span>, <span class=\"string\">'defaultValue'</span>], fnStr);</div><div class=\"line\">        <span class=\"keyword\">return</span> finalFn(args, argumentsList[<span class=\"number\">0</span>], defaultValue);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(receiveFn, handle);</div><div class=\"line\">  <span class=\"keyword\">return</span> _;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>测试代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _1 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)(<span class=\"literal\">undefined</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _2 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)();</div><div class=\"line\"><span class=\"keyword\">var</span> _3 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)(&#123;<span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;)</div><div class=\"line\">  .then(_1.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 1:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error1:'</span>))</div><div class=\"line\"></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</div><div class=\"line\">  .then(_2.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 2:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error2:'</span>))</div><div class=\"line\"></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</div><div class=\"line\">  .then(_3.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 2:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error2:'</span>));</div></pre></td></tr></table></figure></p>\n<p>本段代码已经做为模块提交到<a href=\"https://www.npmjs.com/package/chainproxy\" target=\"_blank\" rel=\"external\">npm</a>上</p>\n","excerpt":"","more":"<p><code>Proxy</code>对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本<code>javascript</code>无法完成的特性，在不长的<code>scala语言</code>学习过程中，发现这门语言有一个很神奇的通配符<code>_</code>，在函数链式调用中，<code>_</code>就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(_.toString());</div></pre></td></tr></table></figure></p>\n<p>就是对每个传来的对象，调用他们自身的<code>toString()</code>方法，使用ES6中的<code>Proxy</code>对象，可以很容易地模拟该特性<br>（nodejs v6.0已支持<code>Proxy</code>，代码亦可在最新版chrome中运行）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</div><div class=\"line\">  <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] !== <span class=\"string\">'function'</span>) <span class=\"keyword\">return</span> obj[key];</div><div class=\"line\">      <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'function'</span>)</div><div class=\"line\">          <span class=\"keyword\">return</span> obj[key].call(obj, ...args);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>除了调用对象自带的方法外，还有取出属性的功能，运行结果如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">32</span>, <span class=\"number\">128</span>, <span class=\"number\">1024</span>].map(_.toString(<span class=\"string\">'2'</span>));</div><div class=\"line\"><span class=\"comment\">//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]</span></div><div class=\"line\"></div><div class=\"line\">[&#123;<span class=\"attr\">v</span>:<span class=\"number\">123</span>&#125;,&#123;<span class=\"attr\">v</span>:<span class=\"number\">456</span>&#125;].map(_.v);</div><div class=\"line\"><span class=\"comment\">//return [123, 456]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</div><div class=\"line\">  .then(_.getTime())</div><div class=\"line\">  .then(_.toString())</div><div class=\"line\">  .then(_.length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div><div class=\"line\"><span class=\"comment\">//return 13</span></div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"2016-6-8续\"><a href=\"#2016-6-8续\" class=\"headerlink\" title=\"2016-6-8续\"></a>2016-6-8续</h1><p>之前研究<code>Proxy</code>的时候写出来的那个<code>_</code>实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个<code>_</code>的作用层数，不能继续往里面走，解决的方法当然是继续返回一个<code>Proxy</code>，思路如下：</p>\n<ul>\n<li><p><code>_</code>本身返回一个Proxy，取属性操作返回的也是一个<code>Proxy</code>，这些<code>Proxy</code>指向一个函数，并在被调用时按顺序取出第一个参数里的属性</p>\n</li>\n<li><p><code>_</code>可以预接收参数，接收的参数将在<code>Proxy</code>被调用时传给取出来的函数</p>\n</li>\n</ul>\n<p>难点是如何知道<code>Proxy</code>是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了<code>Proxy</code>的相关资料后，我意识到上述的两种情况，对应的<code>this</code>应该是不同的，后来又发现过长的调用链每次都要经过多个<code>Proxy</code>可能会影响效率，我又改成另外一种形式实现：<code>Proxy</code>负责收集参数和属性名，并在最终调用的时候新建一个<code>Function</code>，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 <code>s=&gt;s.xx.yy.zz()</code> 给简化成 <code>_.xx.yy.zz()</code> 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Created by ngtmuzi on 2016/5/29.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> receiveFn = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> args;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * chain proxy maker</div><div class=\"line\"> * @params &#123;Any&#125; defaultValue</div><div class=\"line\"> * @type &#123;Function&#125;</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">const</span> chainProxy = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">defaultValue</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> hasDefault   = <span class=\"built_in\">arguments</span>.length &gt; <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> handle = &#123;</div><div class=\"line\">    <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, property, receiver</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//set prototype to base Proxy Object _</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'prototype'</span>) <span class=\"keyword\">return</span> _;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'apply'</span>) <span class=\"keyword\">return</span> target.apply;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'call'</span>) <span class=\"keyword\">return</span> target.call;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'bind'</span>) <span class=\"keyword\">return</span> target.bind;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//is number</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">isNaN</span>(+property)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">`[<span class=\"subst\">$&#123;property&#125;</span>]`</span>), handle);</div><div class=\"line\">      <span class=\"comment\">//return a new Proxy, go on</span></div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">'.'</span> + property), handle);</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">apply</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, thisArg, argumentsList</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//if method calling on Proxy Object</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (thisArg &amp;&amp; thisArg.prototype === _) &#123;</div><div class=\"line\">        <span class=\"comment\">//save arguments to chain, and go on</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, argumentsList), handle);</div><div class=\"line\"></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//calling on outside</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//get the calling chain</span></div><div class=\"line\">        <span class=\"keyword\">var</span> chains = target();</div><div class=\"line\">        <span class=\"comment\">//pick arguments</span></div><div class=\"line\">        <span class=\"keyword\">var</span> args   = [].concat(...chains.filter(<span class=\"built_in\">Array</span>.isArray));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//make function body</span></div><div class=\"line\">        <span class=\"keyword\">var</span> argNum     = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> expression = chains.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> b === <span class=\"string\">'string'</span>) <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(b)) <span class=\"keyword\">return</span> a + <span class=\"string\">`(<span class=\"subst\">$&#123;b.map(()=&gt; <span class=\"string\">`args[<span class=\"subst\">$&#123;argNum++&#125;</span>]`</span>)&#125;</span>)`</span>;</div><div class=\"line\">        &#125;, <span class=\"string\">'return _'</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> fnStr = <span class=\"string\">`</div><div class=\"line\">        try&#123;</div><div class=\"line\">          <span class=\"subst\">$&#123;expression&#125;</span>;</div><div class=\"line\">        &#125;catch(err)&#123;</div><div class=\"line\">          <span class=\"subst\">$&#123;hasDefault ? <span class=\"string\">'return defaultValue;'</span> : <span class=\"string\">''</span>&#125;</span></div><div class=\"line\">          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '<span class=\"subst\">$&#123;expression&#125;</span>';</div><div class=\"line\">          throw err;</div><div class=\"line\">        &#125;`</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> finalFn = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>([<span class=\"string\">'args'</span>, <span class=\"string\">'_'</span>, <span class=\"string\">'defaultValue'</span>], fnStr);</div><div class=\"line\">        <span class=\"keyword\">return</span> finalFn(args, argumentsList[<span class=\"number\">0</span>], defaultValue);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(receiveFn, handle);</div><div class=\"line\">  <span class=\"keyword\">return</span> _;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>测试代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _1 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)(<span class=\"literal\">undefined</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _2 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)();</div><div class=\"line\"><span class=\"keyword\">var</span> _3 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)(&#123;<span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;)</div><div class=\"line\">  .then(_1.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 1:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error1:'</span>))</div><div class=\"line\"></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</div><div class=\"line\">  .then(_2.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 2:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error2:'</span>))</div><div class=\"line\"></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</div><div class=\"line\">  .then(_3.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 2:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error2:'</span>));</div></pre></td></tr></table></figure></p>\n<p>本段代码已经做为模块提交到<a href=\"https://www.npmjs.com/package/chainproxy\">npm</a>上</p>\n"},{"title":"Proxy实现Promise同步调用逻辑","desc":"Proxy + Promise = 逻辑同步","date":"2016-08-08T15:30:08.830Z","author":"ngtmuzi","_content":"\n我们在很多使用Promise的时候都会有如下的用法\n```javascript\nMongoClient.connect()\n  .then(function (db) {\n    var col = db.collection('something');\n    col.find().toArray()\n      .then(console.log, console.error);\n  });\n```\n\n真正的连接对象在`connect()`之后才返回，只能在`then`回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子\n```javascript\nvar db;\nMongoClient.connect()\n  .then(function (_db) {\n    db = _db;\n  });\n//别的地方\ndb.collection('otherthing')....\n```\n\n这样的缺点是在连接未建立时访问`db`会引发异常，当然最正确的做法应该是\n```javascript\nvar db = MongoClient.connect();\n//别的地方\ndb.then(function (_db) {\n  _db.collection('otherthing')....\n});\n```\n\n可以保持对一个连接的复用，但这样还是嵌了一层回调。\n\n\n在之前用`Proxy`写了几个玩具之后，有个念头渐渐浮上心头，`Proxy`也许可以改变这个模式，我们可以用`Proxy`预先收集好调用链，然后再将其内部转为`Promise`的调用链，简单来说思路如下：\n\n1. 先将原始数据用`Promise.resolve`包裹，使其成为一个`Promise`对象，并返回该对象的代理`Proxy`\n\n2. 对该`Proxy`的`get`和`apply`操作实际上就是在后面多加一个`.then`回调，并会继续返回`Proxy`，以实现链式调用\n\n3. 当将`Proxy`作为函数运行时对参数预先做`Promise.resolve`处理，使得它可以接受`Promise`参数\n\n4. 在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能\n\n5. 最终的值从`.then中`获取，`Promise`的特性保证了最终值的可达性\n\n\n\n多说无用，以下是一些示例：\n\n```javascript\nvar request = require('request-promise');\nvar _       = require('promixy');\n\nvar parse   = _(JSON.parse);            //proxy a function\nvar docJson = request('https://nodejs.org/api/documentation.json');  //a promise \nvar obj     = parse(docJson);           //wait the promise result\n\nobj.miscs[0].textRaw.then(console.log, console.error);\n```\n\n首先代理了`JSON.parse`使其可以接受`Promise`类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过`console.log`打印出来\n\n\n当试图从`undefined`中读取属性时，会返回类似这样的错误\n```\nTypeError: can't read property 'textRaw' in {Promixy}(1 args).miscs.10, it got a undefined\n```\n\n虽然有些不直观但好歹调用链是能看出来了\n```javascript\n_(Promise.resolve(_(_(_(111))))).then(_(console.log), _(console.error));\n//111\n```\n\n即使嵌了很多层，这个`Proxy`依然是`Promise`的代理，所以最后还是可以得到正确的结果的\n\n\n而刚才的mongo连接也可以简化为\n\n```javascript\nvar db = _(MongoClient.connect());\n//别的地方\ndb.collection('something')...\n```\n\n实质上是`Proxy`在内部代替用户嵌了一层`.then`，代码上更加简单直观，且从它上面取的所有属性依然有`Proxy`包裹，所以你甚至可以实现这样变态的调用方式\n\n```javascript\ndb.collection('something').find().toArray()[0].somekey\n  .then(console.log,console.error);\n```\n\n直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法\n\n\n综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，[npm地址](https://www.npmjs.com/package/promixy)，如果你有任何建议或发现了bug，欢迎到[github](https://github.com/ngtmuzi/promixy)反馈","source":"_posts/Proxy实现Promise同步调用逻辑.md","raw":"---\ntitle: Proxy实现Promise同步调用逻辑  \ndesc: Proxy + Promise = 逻辑同步  \ndate: 2016-8-8 23:30:08.830\ntags: \n- javascript\n- Proxy\n- Promise\n- ES6\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n我们在很多使用Promise的时候都会有如下的用法\n```javascript\nMongoClient.connect()\n  .then(function (db) {\n    var col = db.collection('something');\n    col.find().toArray()\n      .then(console.log, console.error);\n  });\n```\n\n真正的连接对象在`connect()`之后才返回，只能在`then`回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子\n```javascript\nvar db;\nMongoClient.connect()\n  .then(function (_db) {\n    db = _db;\n  });\n//别的地方\ndb.collection('otherthing')....\n```\n\n这样的缺点是在连接未建立时访问`db`会引发异常，当然最正确的做法应该是\n```javascript\nvar db = MongoClient.connect();\n//别的地方\ndb.then(function (_db) {\n  _db.collection('otherthing')....\n});\n```\n\n可以保持对一个连接的复用，但这样还是嵌了一层回调。\n\n\n在之前用`Proxy`写了几个玩具之后，有个念头渐渐浮上心头，`Proxy`也许可以改变这个模式，我们可以用`Proxy`预先收集好调用链，然后再将其内部转为`Promise`的调用链，简单来说思路如下：\n\n1. 先将原始数据用`Promise.resolve`包裹，使其成为一个`Promise`对象，并返回该对象的代理`Proxy`\n\n2. 对该`Proxy`的`get`和`apply`操作实际上就是在后面多加一个`.then`回调，并会继续返回`Proxy`，以实现链式调用\n\n3. 当将`Proxy`作为函数运行时对参数预先做`Promise.resolve`处理，使得它可以接受`Promise`参数\n\n4. 在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能\n\n5. 最终的值从`.then中`获取，`Promise`的特性保证了最终值的可达性\n\n\n\n多说无用，以下是一些示例：\n\n```javascript\nvar request = require('request-promise');\nvar _       = require('promixy');\n\nvar parse   = _(JSON.parse);            //proxy a function\nvar docJson = request('https://nodejs.org/api/documentation.json');  //a promise \nvar obj     = parse(docJson);           //wait the promise result\n\nobj.miscs[0].textRaw.then(console.log, console.error);\n```\n\n首先代理了`JSON.parse`使其可以接受`Promise`类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过`console.log`打印出来\n\n\n当试图从`undefined`中读取属性时，会返回类似这样的错误\n```\nTypeError: can't read property 'textRaw' in {Promixy}(1 args).miscs.10, it got a undefined\n```\n\n虽然有些不直观但好歹调用链是能看出来了\n```javascript\n_(Promise.resolve(_(_(_(111))))).then(_(console.log), _(console.error));\n//111\n```\n\n即使嵌了很多层，这个`Proxy`依然是`Promise`的代理，所以最后还是可以得到正确的结果的\n\n\n而刚才的mongo连接也可以简化为\n\n```javascript\nvar db = _(MongoClient.connect());\n//别的地方\ndb.collection('something')...\n```\n\n实质上是`Proxy`在内部代替用户嵌了一层`.then`，代码上更加简单直观，且从它上面取的所有属性依然有`Proxy`包裹，所以你甚至可以实现这样变态的调用方式\n\n```javascript\ndb.collection('something').find().toArray()[0].somekey\n  .then(console.log,console.error);\n```\n\n直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法\n\n\n综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，[npm地址](https://www.npmjs.com/package/promixy)，如果你有任何建议或发现了bug，欢迎到[github](https://github.com/ngtmuzi/promixy)反馈","slug":"Proxy实现Promise同步调用逻辑","published":1,"updated":"2017-06-22T05:51:34.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481v9zm0005i8u0g8szsdpm","content":"<p>我们在很多使用Promise的时候都会有如下的用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">MongoClient.connect()</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">db</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> col = db.collection(<span class=\"string\">'something'</span>);</div><div class=\"line\">    col.find().toArray()</div><div class=\"line\">      .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>真正的连接对象在<code>connect()</code>之后才返回，只能在<code>then</code>回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db;</div><div class=\"line\">MongoClient.connect()</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</div><div class=\"line\">    db = _db;</div><div class=\"line\">  &#125;);</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.collection(<span class=\"string\">'otherthing'</span>)....</div></pre></td></tr></table></figure></p>\n<p>这样的缺点是在连接未建立时访问<code>db</code>会引发异常，当然最正确的做法应该是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = MongoClient.connect();</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</div><div class=\"line\">  _db.collection(<span class=\"string\">'otherthing'</span>)....</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>可以保持对一个连接的复用，但这样还是嵌了一层回调。</p>\n<p>在之前用<code>Proxy</code>写了几个玩具之后，有个念头渐渐浮上心头，<code>Proxy</code>也许可以改变这个模式，我们可以用<code>Proxy</code>预先收集好调用链，然后再将其内部转为<code>Promise</code>的调用链，简单来说思路如下：</p>\n<ol>\n<li><p>先将原始数据用<code>Promise.resolve</code>包裹，使其成为一个<code>Promise</code>对象，并返回该对象的代理<code>Proxy</code></p>\n</li>\n<li><p>对该<code>Proxy</code>的<code>get</code>和<code>apply</code>操作实际上就是在后面多加一个<code>.then</code>回调，并会继续返回<code>Proxy</code>，以实现链式调用</p>\n</li>\n<li><p>当将<code>Proxy</code>作为函数运行时对参数预先做<code>Promise.resolve</code>处理，使得它可以接受<code>Promise</code>参数</p>\n</li>\n<li><p>在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能</p>\n</li>\n<li><p>最终的值从<code>.then中</code>获取，<code>Promise</code>的特性保证了最终值的可达性</p>\n</li>\n</ol>\n<p>多说无用，以下是一些示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _       = <span class=\"built_in\">require</span>(<span class=\"string\">'promixy'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parse   = _(<span class=\"built_in\">JSON</span>.parse);            <span class=\"comment\">//proxy a function</span></div><div class=\"line\"><span class=\"keyword\">var</span> docJson = request(<span class=\"string\">'https://nodejs.org/api/documentation.json'</span>);  <span class=\"comment\">//a promise </span></div><div class=\"line\"><span class=\"keyword\">var</span> obj     = parse(docJson);           <span class=\"comment\">//wait the promise result</span></div><div class=\"line\"></div><div class=\"line\">obj.miscs[<span class=\"number\">0</span>].textRaw.then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>首先代理了<code>JSON.parse</code>使其可以接受<code>Promise</code>类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过<code>console.log</code>打印出来</p>\n<p>当试图从<code>undefined</code>中读取属性时，会返回类似这样的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TypeError: can&apos;t read property &apos;textRaw&apos; in &#123;Promixy&#125;(1 args).miscs.10, it got a undefined</div></pre></td></tr></table></figure></p>\n<p>虽然有些不直观但好歹调用链是能看出来了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_(<span class=\"built_in\">Promise</span>.resolve(_(_(_(<span class=\"number\">111</span>))))).then(_(<span class=\"built_in\">console</span>.log), _(<span class=\"built_in\">console</span>.error));</div><div class=\"line\"><span class=\"comment\">//111</span></div></pre></td></tr></table></figure></p>\n<p>即使嵌了很多层，这个<code>Proxy</code>依然是<code>Promise</code>的代理，所以最后还是可以得到正确的结果的</p>\n<p>而刚才的mongo连接也可以简化为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = _(MongoClient.connect());</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.collection(<span class=\"string\">'something'</span>)...</div></pre></td></tr></table></figure>\n<p>实质上是<code>Proxy</code>在内部代替用户嵌了一层<code>.then</code>，代码上更加简单直观，且从它上面取的所有属性依然有<code>Proxy</code>包裹，所以你甚至可以实现这样变态的调用方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.collection(<span class=\"string\">'something'</span>).find().toArray()[<span class=\"number\">0</span>].somekey</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log,<span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法</p>\n<p>综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，<a href=\"https://www.npmjs.com/package/promixy\" target=\"_blank\" rel=\"external\">npm地址</a>，如果你有任何建议或发现了bug，欢迎到<a href=\"https://github.com/ngtmuzi/promixy\" target=\"_blank\" rel=\"external\">github</a>反馈</p>\n","excerpt":"","more":"<p>我们在很多使用Promise的时候都会有如下的用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">MongoClient.connect()</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">db</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> col = db.collection(<span class=\"string\">'something'</span>);</div><div class=\"line\">    col.find().toArray()</div><div class=\"line\">      .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>真正的连接对象在<code>connect()</code>之后才返回，只能在<code>then</code>回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db;</div><div class=\"line\">MongoClient.connect()</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</div><div class=\"line\">    db = _db;</div><div class=\"line\">  &#125;);</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.collection(<span class=\"string\">'otherthing'</span>)....</div></pre></td></tr></table></figure></p>\n<p>这样的缺点是在连接未建立时访问<code>db</code>会引发异常，当然最正确的做法应该是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = MongoClient.connect();</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</div><div class=\"line\">  _db.collection(<span class=\"string\">'otherthing'</span>)....</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>可以保持对一个连接的复用，但这样还是嵌了一层回调。</p>\n<p>在之前用<code>Proxy</code>写了几个玩具之后，有个念头渐渐浮上心头，<code>Proxy</code>也许可以改变这个模式，我们可以用<code>Proxy</code>预先收集好调用链，然后再将其内部转为<code>Promise</code>的调用链，简单来说思路如下：</p>\n<ol>\n<li><p>先将原始数据用<code>Promise.resolve</code>包裹，使其成为一个<code>Promise</code>对象，并返回该对象的代理<code>Proxy</code></p>\n</li>\n<li><p>对该<code>Proxy</code>的<code>get</code>和<code>apply</code>操作实际上就是在后面多加一个<code>.then</code>回调，并会继续返回<code>Proxy</code>，以实现链式调用</p>\n</li>\n<li><p>当将<code>Proxy</code>作为函数运行时对参数预先做<code>Promise.resolve</code>处理，使得它可以接受<code>Promise</code>参数</p>\n</li>\n<li><p>在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能</p>\n</li>\n<li><p>最终的值从<code>.then中</code>获取，<code>Promise</code>的特性保证了最终值的可达性</p>\n</li>\n</ol>\n<p>多说无用，以下是一些示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _       = <span class=\"built_in\">require</span>(<span class=\"string\">'promixy'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parse   = _(<span class=\"built_in\">JSON</span>.parse);            <span class=\"comment\">//proxy a function</span></div><div class=\"line\"><span class=\"keyword\">var</span> docJson = request(<span class=\"string\">'https://nodejs.org/api/documentation.json'</span>);  <span class=\"comment\">//a promise </span></div><div class=\"line\"><span class=\"keyword\">var</span> obj     = parse(docJson);           <span class=\"comment\">//wait the promise result</span></div><div class=\"line\"></div><div class=\"line\">obj.miscs[<span class=\"number\">0</span>].textRaw.then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>首先代理了<code>JSON.parse</code>使其可以接受<code>Promise</code>类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过<code>console.log</code>打印出来</p>\n<p>当试图从<code>undefined</code>中读取属性时，会返回类似这样的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TypeError: can&apos;t read property &apos;textRaw&apos; in &#123;Promixy&#125;(1 args).miscs.10, it got a undefined</div></pre></td></tr></table></figure></p>\n<p>虽然有些不直观但好歹调用链是能看出来了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_(<span class=\"built_in\">Promise</span>.resolve(_(_(_(<span class=\"number\">111</span>))))).then(_(<span class=\"built_in\">console</span>.log), _(<span class=\"built_in\">console</span>.error));</div><div class=\"line\"><span class=\"comment\">//111</span></div></pre></td></tr></table></figure></p>\n<p>即使嵌了很多层，这个<code>Proxy</code>依然是<code>Promise</code>的代理，所以最后还是可以得到正确的结果的</p>\n<p>而刚才的mongo连接也可以简化为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = _(MongoClient.connect());</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.collection(<span class=\"string\">'something'</span>)...</div></pre></td></tr></table></figure>\n<p>实质上是<code>Proxy</code>在内部代替用户嵌了一层<code>.then</code>，代码上更加简单直观，且从它上面取的所有属性依然有<code>Proxy</code>包裹，所以你甚至可以实现这样变态的调用方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.collection(<span class=\"string\">'something'</span>).find().toArray()[<span class=\"number\">0</span>].somekey</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log,<span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法</p>\n<p>综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，<a href=\"https://www.npmjs.com/package/promixy\">npm地址</a>，如果你有任何建议或发现了bug，欢迎到<a href=\"https://github.com/ngtmuzi/promixy\">github</a>反馈</p>\n"},{"title":"javascript模板渲染研究笔记（一）","subtitle":null,"desc":"下面没有了","date":"2015-12-31T01:49:32.000Z","author":"ngtmuzi","_content":"\n只是一名本分的后端`nodejs`程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（`angular`、`reactjs`、`vue`、`meteor`以及各种其他）之后，我最终还是决定使用`express`自带的`ejs`\n \n\n即使是各大主流框架，在很大程度上还是离不开`jquery`，我当然也是如此，使用`ejs`仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。\n\n\n然而`ejs`使用中也是各种不爽，在`html`中加上各种`<%%>`真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（`reactjs`的`jsx语法`在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的`jquery`，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了\n\n\n因此我开始研究在`ejs`中加入jq的功能，`cheerio`模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——\n\n\n去翻了一下`ejs`的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言\n```ejs\n<h1>{{ 1+1 }}</h1>\n```\n\n所对应的中间函数：\n```javascript\nfunction () {\n  var out = '';\n  out += '<h1>';\n  out += escape(1 + 1);\n  out += '</h1>';\n  return new String(out);\n}\n```\n\n中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。\n\n\n可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成\n\n```'\n<h1>' + escape(1 + 1) + '</h1>'\n```\n\n这种格式呢？因为需要支持各种看起来高大上的模板语法，如`if`、`each`之类的。\n\n---\n\n\n好像有点跑题，刚才的问题是，我如何将`cheerio`模块加入到`ejs`中呢？\n\n\n\n\n我们都知道，`ejs`中如果要将某些变量的值带到模板中渲染，需要在render时传递`locals`对象，在这个对象里存储所有渲染需要的变量。\n\n\n但实际上在使用模板引擎时，我们并不会使用名叫`locals`或者其他类似`data`之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）\n```javascript\nfunction(locals){\n  with(locals){\n  ......\n  }\n}\n```\n\n模板引擎将传入的`locals`对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传`locals`对象的时候丢进去：\n```javascript\nvar cheerio = require('cheerio');\nres.render('index',{ $:cheerio } );\n```\n\n\n这样子就能实现在`ejs`里实现类似这样的jq语法了\n```javascript\n<% for(var i = 0; i < 10; i++) {%>\n    <%- $('<a>').text(i.toString()).attr('href','#') %>\n<% } %>\n```","source":"_posts/javascript模板渲染研究笔记（一）.md","raw":"---\ntitle: javascript模板渲染研究笔记（一）  \nsubtitle: \ndesc: 下面没有了\ndate: 2015-12-31 9:49:32\ntags: javascript\nauthor: ngtmuzi  \ncategory: 班门弄斧  \n---\n\n只是一名本分的后端`nodejs`程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（`angular`、`reactjs`、`vue`、`meteor`以及各种其他）之后，我最终还是决定使用`express`自带的`ejs`\n \n\n即使是各大主流框架，在很大程度上还是离不开`jquery`，我当然也是如此，使用`ejs`仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。\n\n\n然而`ejs`使用中也是各种不爽，在`html`中加上各种`<%%>`真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（`reactjs`的`jsx语法`在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的`jquery`，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了\n\n\n因此我开始研究在`ejs`中加入jq的功能，`cheerio`模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——\n\n\n去翻了一下`ejs`的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言\n```ejs\n<h1>{{ 1+1 }}</h1>\n```\n\n所对应的中间函数：\n```javascript\nfunction () {\n  var out = '';\n  out += '<h1>';\n  out += escape(1 + 1);\n  out += '</h1>';\n  return new String(out);\n}\n```\n\n中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。\n\n\n可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成\n\n```'\n<h1>' + escape(1 + 1) + '</h1>'\n```\n\n这种格式呢？因为需要支持各种看起来高大上的模板语法，如`if`、`each`之类的。\n\n---\n\n\n好像有点跑题，刚才的问题是，我如何将`cheerio`模块加入到`ejs`中呢？\n\n\n\n\n我们都知道，`ejs`中如果要将某些变量的值带到模板中渲染，需要在render时传递`locals`对象，在这个对象里存储所有渲染需要的变量。\n\n\n但实际上在使用模板引擎时，我们并不会使用名叫`locals`或者其他类似`data`之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）\n```javascript\nfunction(locals){\n  with(locals){\n  ......\n  }\n}\n```\n\n模板引擎将传入的`locals`对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传`locals`对象的时候丢进去：\n```javascript\nvar cheerio = require('cheerio');\nres.render('index',{ $:cheerio } );\n```\n\n\n这样子就能实现在`ejs`里实现类似这样的jq语法了\n```javascript\n<% for(var i = 0; i < 10; i++) {%>\n    <%- $('<a>').text(i.toString()).attr('href','#') %>\n<% } %>\n```","slug":"javascript模板渲染研究笔记（一）","published":1,"updated":"2017-06-22T05:51:35.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481v9zq0006i8u0veo7c7zp","content":"<p>只是一名本分的后端<code>nodejs</code>程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（<code>angular</code>、<code>reactjs</code>、<code>vue</code>、<code>meteor</code>以及各种其他）之后，我最终还是决定使用<code>express</code>自带的<code>ejs</code></p>\n<p>即使是各大主流框架，在很大程度上还是离不开<code>jquery</code>，我当然也是如此，使用<code>ejs</code>仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。</p>\n<p>然而<code>ejs</code>使用中也是各种不爽，在<code>html</code>中加上各种<code>&lt;%%&gt;</code>真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（<code>reactjs</code>的<code>jsx语法</code>在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的<code>jquery</code>，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了</p>\n<p>因此我开始研究在<code>ejs</code>中加入jq的功能，<code>cheerio</code>模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——</p>\n<p>去翻了一下<code>ejs</code>的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&#123;&#123; 1+1 &#125;&#125;&lt;/h1&gt;</div></pre></td></tr></table></figure></p>\n<p>所对应的中间函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> out = <span class=\"string\">''</span>;</div><div class=\"line\">  out += <span class=\"string\">'&lt;h1&gt;'</span>;</div><div class=\"line\">  out += <span class=\"built_in\">escape</span>(<span class=\"number\">1</span> + <span class=\"number\">1</span>);</div><div class=\"line\">  out += <span class=\"string\">'&lt;/h1&gt;'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(out);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。</p>\n<p>可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&apos; + escape(1 + 1) + &apos;&lt;/h1&gt;&apos;</div></pre></td></tr></table></figure>\n<p>这种格式呢？因为需要支持各种看起来高大上的模板语法，如<code>if</code>、<code>each</code>之类的。</p>\n<hr>\n<p>好像有点跑题，刚才的问题是，我如何将<code>cheerio</code>模块加入到<code>ejs</code>中呢？</p>\n<p>我们都知道，<code>ejs</code>中如果要将某些变量的值带到模板中渲染，需要在render时传递<code>locals</code>对象，在这个对象里存储所有渲染需要的变量。</p>\n<p>但实际上在使用模板引擎时，我们并不会使用名叫<code>locals</code>或者其他类似<code>data</code>之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">locals</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">with</span>(locals)&#123;</div><div class=\"line\">  ......</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>模板引擎将传入的<code>locals</code>对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传<code>locals</code>对象的时候丢进去：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>);</div><div class=\"line\">res.render(<span class=\"string\">'index'</span>,&#123; <span class=\"attr\">$</span>:cheerio &#125; );</div></pre></td></tr></table></figure></p>\n<p>这样子就能实现在<code>ejs</code>里实现类似这样的jq语法了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;%&gt;</div><div class=\"line\">    &lt;%- $('&lt;a&gt;').text(i.toString()).attr('href','#') %&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>只是一名本分的后端<code>nodejs</code>程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（<code>angular</code>、<code>reactjs</code>、<code>vue</code>、<code>meteor</code>以及各种其他）之后，我最终还是决定使用<code>express</code>自带的<code>ejs</code></p>\n<p>即使是各大主流框架，在很大程度上还是离不开<code>jquery</code>，我当然也是如此，使用<code>ejs</code>仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。</p>\n<p>然而<code>ejs</code>使用中也是各种不爽，在<code>html</code>中加上各种<code>&lt;%%&gt;</code>真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（<code>reactjs</code>的<code>jsx语法</code>在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的<code>jquery</code>，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了</p>\n<p>因此我开始研究在<code>ejs</code>中加入jq的功能，<code>cheerio</code>模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——</p>\n<p>去翻了一下<code>ejs</code>的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&#123;&#123; 1+1 &#125;&#125;&lt;/h1&gt;</div></pre></td></tr></table></figure></p>\n<p>所对应的中间函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> out = <span class=\"string\">''</span>;</div><div class=\"line\">  out += <span class=\"string\">'&lt;h1&gt;'</span>;</div><div class=\"line\">  out += <span class=\"built_in\">escape</span>(<span class=\"number\">1</span> + <span class=\"number\">1</span>);</div><div class=\"line\">  out += <span class=\"string\">'&lt;/h1&gt;'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(out);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。</p>\n<p>可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&apos; + escape(1 + 1) + &apos;&lt;/h1&gt;&apos;</div></pre></td></tr></table></figure>\n<p>这种格式呢？因为需要支持各种看起来高大上的模板语法，如<code>if</code>、<code>each</code>之类的。</p>\n<hr>\n<p>好像有点跑题，刚才的问题是，我如何将<code>cheerio</code>模块加入到<code>ejs</code>中呢？</p>\n<p>我们都知道，<code>ejs</code>中如果要将某些变量的值带到模板中渲染，需要在render时传递<code>locals</code>对象，在这个对象里存储所有渲染需要的变量。</p>\n<p>但实际上在使用模板引擎时，我们并不会使用名叫<code>locals</code>或者其他类似<code>data</code>之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">locals</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">with</span>(locals)&#123;</div><div class=\"line\">  ......</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>模板引擎将传入的<code>locals</code>对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传<code>locals</code>对象的时候丢进去：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>);</div><div class=\"line\">res.render(<span class=\"string\">'index'</span>,&#123; <span class=\"attr\">$</span>:cheerio &#125; );</div></pre></td></tr></table></figure></p>\n<p>这样子就能实现在<code>ejs</code>里实现类似这样的jq语法了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;%&gt;</div><div class=\"line\">    &lt;%- $('&lt;a&gt;').text(i.toString()).attr('href','#') %&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure></p>\n"},{"title":"javaScript的函数柯里化","desc":"柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数","date":"2016-01-07T02:11:18.000Z","author":"ngtmuzi","_content":"> 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n\n\n简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：\n```javascript\nfunction curry(fn, context) {\n    function c() {\n        var args = this.concat(Array.prototype.slice.call(arguments));\n        if (args.length >= fn.length) return fn.apply(context, args);\n        return c.bind(args);\n    }\n\n    return c.bind([]);\n}\n```\n\n返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：\n\n```javascript\nvar _a = function (a, b) {\n    return a + b;\n};\nvar a = curry(_a);\n\nconsole.log(a(1, 2), a(2)(3), a()()(3)(4), a()()(4, 5))\n//运行结果： 3 5 7 9\n```","source":"_posts/javaScript的函数柯里化.md","raw":"---\ntitle: javaScript的函数柯里化  \ndesc: 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数  \ndate: 2016-1-7 10:11:18  \ntags: javascript  \nauthor: ngtmuzi  \ncategory: 班门弄斧  \n---\n> 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n\n\n简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：\n```javascript\nfunction curry(fn, context) {\n    function c() {\n        var args = this.concat(Array.prototype.slice.call(arguments));\n        if (args.length >= fn.length) return fn.apply(context, args);\n        return c.bind(args);\n    }\n\n    return c.bind([]);\n}\n```\n\n返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：\n\n```javascript\nvar _a = function (a, b) {\n    return a + b;\n};\nvar a = curry(_a);\n\nconsole.log(a(1, 2), a(2)(3), a()()(3)(4), a()()(4, 5))\n//运行结果： 3 5 7 9\n```","slug":"javaScript的函数柯里化","published":1,"updated":"2017-06-22T05:51:35.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481v9zs0009i8u0s7ahzfoh","content":"<blockquote>\n<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>\n</blockquote>\n<p>简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"keyword\">this</span>.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">        <span class=\"keyword\">if</span> (args.length &gt;= fn.length) <span class=\"keyword\">return</span> fn.apply(context, args);</div><div class=\"line\">        <span class=\"keyword\">return</span> c.bind(args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> c.bind([]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _a = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> a = curry(_a);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(a(<span class=\"number\">1</span>, <span class=\"number\">2</span>), a(<span class=\"number\">2</span>)(<span class=\"number\">3</span>), a()()(<span class=\"number\">3</span>)(<span class=\"number\">4</span>), a()()(<span class=\"number\">4</span>, <span class=\"number\">5</span>))</div><div class=\"line\"><span class=\"comment\">//运行结果： 3 5 7 9</span></div></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>\n</blockquote>\n<p>简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"keyword\">this</span>.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">        <span class=\"keyword\">if</span> (args.length &gt;= fn.length) <span class=\"keyword\">return</span> fn.apply(context, args);</div><div class=\"line\">        <span class=\"keyword\">return</span> c.bind(args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> c.bind([]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _a = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> a = curry(_a);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(a(<span class=\"number\">1</span>, <span class=\"number\">2</span>), a(<span class=\"number\">2</span>)(<span class=\"number\">3</span>), a()()(<span class=\"number\">3</span>)(<span class=\"number\">4</span>), a()()(<span class=\"number\">4</span>, <span class=\"number\">5</span>))</div><div class=\"line\"><span class=\"comment\">//运行结果： 3 5 7 9</span></div></pre></td></tr></table></figure>"},{"title":"promise的日常应用","desc":"promise在异步处理上真是比原始的回调好了太多，promise大法好~","date":"2015-12-30T12:46:04.470Z","author":"ngtmuzi","_content":"\n`promise`在异步处理上真是比原始的回调好了太多，`promise`大法好~\n\n\n下面是一些日常工作中总结的各种神秘技巧：（使用`bluebird`模块）\n\n* 一般来说都是在`request`请求或数据库操作之后开始使用`promise`，当然要直接`Promise.resolve()`也是可以的\n\n* `mongodb`模块原生返回`promise`对象，真是方便不少，不过它用的是`Q`模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换`promise`库：\n```javascript\nMongoClient.connect(mongoUrl, {promiseLibrary: Promise})\n```\n* `mysql`方面好像除了`sequelize`外没什么比较好的`promise`的模块……因为目前的工作内容都是在`mongodb`上，对这方面也没做太多了解\n\n* `redis`模块中`ioredis`据说不错，不过也没太多接触\n\n* 至于网络请求，自然是`request`的`promise`版：`request`-`promise`\n\n---\n\n\n当以上模块返回了promise对象，就可以用then一路走到黑啦\n\n\n一般来说我的express路由处理函数都会以这样结尾：\n```javascript\nfunction getArticle(req, res, next) {\n  mongo.article.find(req.query).sort({postTime:-1}).toArray()\n    .then(res.ok, next);\n}\n```\n\n`res.ok`是自己为了方便而挂上的一个函数，一般类似于  \n\n```javascript\n  res.ok  = res.json.bind(res);\n```\n\n\n`next`函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。\n\n\n后来想想，用`next`函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：\n\n```javascript\nres.ok = function (data) {\n  res.send(200,data);\n};\nres.err = _.curry(function (code, err, ext) {\n  res.status(code || 500);\n  res.json({msg: err && err.message || err, ext: ext && ext.message || ext});\n});\n```\n\n使用了`lodash`模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术\n\n```javascript\nsms.csGetStatusReportExEx()\n  .then(res.ok, res.err(502, '状态报告获取失败'));\n```\n\n真正的错误信息会被带在`ext`里字段返回，另外`res.ok`也改成调用适用性更好的`res.send`函数\n（注意这里有个坑，`res.send`一个数字的话它会以为你只返回一个http状态码，因此虽然`res.send(200,data)`这种格式已被弃用，但是在目前还是必须这么处理才行）","source":"_posts/promise的日常应用.md","raw":"---\ntitle: promise的日常应用    \ndesc: promise在异步处理上真是比原始的回调好了太多，promise大法好~  \ndate: 2015-12-30 20:46:04.470\ntags: \n- nodejs\n- javascript\n- promise\n- express  \nauthor: ngtmuzi  \ncategory: 班门弄斧  \n---\n\n`promise`在异步处理上真是比原始的回调好了太多，`promise`大法好~\n\n\n下面是一些日常工作中总结的各种神秘技巧：（使用`bluebird`模块）\n\n* 一般来说都是在`request`请求或数据库操作之后开始使用`promise`，当然要直接`Promise.resolve()`也是可以的\n\n* `mongodb`模块原生返回`promise`对象，真是方便不少，不过它用的是`Q`模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换`promise`库：\n```javascript\nMongoClient.connect(mongoUrl, {promiseLibrary: Promise})\n```\n* `mysql`方面好像除了`sequelize`外没什么比较好的`promise`的模块……因为目前的工作内容都是在`mongodb`上，对这方面也没做太多了解\n\n* `redis`模块中`ioredis`据说不错，不过也没太多接触\n\n* 至于网络请求，自然是`request`的`promise`版：`request`-`promise`\n\n---\n\n\n当以上模块返回了promise对象，就可以用then一路走到黑啦\n\n\n一般来说我的express路由处理函数都会以这样结尾：\n```javascript\nfunction getArticle(req, res, next) {\n  mongo.article.find(req.query).sort({postTime:-1}).toArray()\n    .then(res.ok, next);\n}\n```\n\n`res.ok`是自己为了方便而挂上的一个函数，一般类似于  \n\n```javascript\n  res.ok  = res.json.bind(res);\n```\n\n\n`next`函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。\n\n\n后来想想，用`next`函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：\n\n```javascript\nres.ok = function (data) {\n  res.send(200,data);\n};\nres.err = _.curry(function (code, err, ext) {\n  res.status(code || 500);\n  res.json({msg: err && err.message || err, ext: ext && ext.message || ext});\n});\n```\n\n使用了`lodash`模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术\n\n```javascript\nsms.csGetStatusReportExEx()\n  .then(res.ok, res.err(502, '状态报告获取失败'));\n```\n\n真正的错误信息会被带在`ext`里字段返回，另外`res.ok`也改成调用适用性更好的`res.send`函数\n（注意这里有个坑，`res.send`一个数字的话它会以为你只返回一个http状态码，因此虽然`res.send(200,data)`这种格式已被弃用，但是在目前还是必须这么处理才行）","slug":"promise的日常应用","published":1,"updated":"2017-06-22T05:51:34.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481v9zu000bi8u09w4pantu","content":"<p><code>promise</code>在异步处理上真是比原始的回调好了太多，<code>promise</code>大法好~</p>\n<p>下面是一些日常工作中总结的各种神秘技巧：（使用<code>bluebird</code>模块）</p>\n<ul>\n<li><p>一般来说都是在<code>request</code>请求或数据库操作之后开始使用<code>promise</code>，当然要直接<code>Promise.resolve()</code>也是可以的</p>\n</li>\n<li><p><code>mongodb</code>模块原生返回<code>promise</code>对象，真是方便不少，不过它用的是<code>Q</code>模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换<code>promise</code>库：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MongoClient.connect(mongoUrl, &#123;<span class=\"attr\">promiseLibrary</span>: <span class=\"built_in\">Promise</span>&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>mysql</code>方面好像除了<code>sequelize</code>外没什么比较好的<code>promise</code>的模块……因为目前的工作内容都是在<code>mongodb</code>上，对这方面也没做太多了解</p>\n</li>\n<li><p><code>redis</code>模块中<code>ioredis</code>据说不错，不过也没太多接触</p>\n</li>\n<li><p>至于网络请求，自然是<code>request</code>的<code>promise</code>版：<code>request</code>-<code>promise</code></p>\n</li>\n</ul>\n<hr>\n<p>当以上模块返回了promise对象，就可以用then一路走到黑啦</p>\n<p>一般来说我的express路由处理函数都会以这样结尾：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArticle</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  mongo.article.find(req.query).sort(&#123;<span class=\"attr\">postTime</span>:<span class=\"number\">-1</span>&#125;).toArray()</div><div class=\"line\">    .then(res.ok, next);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>res.ok</code>是自己为了方便而挂上的一个函数，一般类似于  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.ok  = res.json.bind(res);</div></pre></td></tr></table></figure>\n<p><code>next</code>函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。</p>\n<p>后来想想，用<code>next</code>函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.ok = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  res.send(<span class=\"number\">200</span>,data);</div><div class=\"line\">&#125;;</div><div class=\"line\">res.err = _.curry(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, err, ext</span>) </span>&#123;</div><div class=\"line\">  res.status(code || <span class=\"number\">500</span>);</div><div class=\"line\">  res.json(&#123;<span class=\"attr\">msg</span>: err &amp;&amp; err.message || err, <span class=\"attr\">ext</span>: ext &amp;&amp; ext.message || ext&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>使用了<code>lodash</code>模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sms.csGetStatusReportExEx()</div><div class=\"line\">  .then(res.ok, res.err(<span class=\"number\">502</span>, <span class=\"string\">'状态报告获取失败'</span>));</div></pre></td></tr></table></figure>\n<p>真正的错误信息会被带在<code>ext</code>里字段返回，另外<code>res.ok</code>也改成调用适用性更好的<code>res.send</code>函数<br>（注意这里有个坑，<code>res.send</code>一个数字的话它会以为你只返回一个http状态码，因此虽然<code>res.send(200,data)</code>这种格式已被弃用，但是在目前还是必须这么处理才行）</p>\n","excerpt":"","more":"<p><code>promise</code>在异步处理上真是比原始的回调好了太多，<code>promise</code>大法好~</p>\n<p>下面是一些日常工作中总结的各种神秘技巧：（使用<code>bluebird</code>模块）</p>\n<ul>\n<li><p>一般来说都是在<code>request</code>请求或数据库操作之后开始使用<code>promise</code>，当然要直接<code>Promise.resolve()</code>也是可以的</p>\n</li>\n<li><p><code>mongodb</code>模块原生返回<code>promise</code>对象，真是方便不少，不过它用的是<code>Q</code>模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换<code>promise</code>库：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MongoClient.connect(mongoUrl, &#123;<span class=\"attr\">promiseLibrary</span>: <span class=\"built_in\">Promise</span>&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>mysql</code>方面好像除了<code>sequelize</code>外没什么比较好的<code>promise</code>的模块……因为目前的工作内容都是在<code>mongodb</code>上，对这方面也没做太多了解</p>\n</li>\n<li><p><code>redis</code>模块中<code>ioredis</code>据说不错，不过也没太多接触</p>\n</li>\n<li><p>至于网络请求，自然是<code>request</code>的<code>promise</code>版：<code>request</code>-<code>promise</code></p>\n</li>\n</ul>\n<hr>\n<p>当以上模块返回了promise对象，就可以用then一路走到黑啦</p>\n<p>一般来说我的express路由处理函数都会以这样结尾：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArticle</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  mongo.article.find(req.query).sort(&#123;<span class=\"attr\">postTime</span>:<span class=\"number\">-1</span>&#125;).toArray()</div><div class=\"line\">    .then(res.ok, next);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>res.ok</code>是自己为了方便而挂上的一个函数，一般类似于  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.ok  = res.json.bind(res);</div></pre></td></tr></table></figure>\n<p><code>next</code>函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。</p>\n<p>后来想想，用<code>next</code>函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.ok = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  res.send(<span class=\"number\">200</span>,data);</div><div class=\"line\">&#125;;</div><div class=\"line\">res.err = _.curry(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, err, ext</span>) </span>&#123;</div><div class=\"line\">  res.status(code || <span class=\"number\">500</span>);</div><div class=\"line\">  res.json(&#123;<span class=\"attr\">msg</span>: err &amp;&amp; err.message || err, <span class=\"attr\">ext</span>: ext &amp;&amp; ext.message || ext&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>使用了<code>lodash</code>模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sms.csGetStatusReportExEx()</div><div class=\"line\">  .then(res.ok, res.err(<span class=\"number\">502</span>, <span class=\"string\">'状态报告获取失败'</span>));</div></pre></td></tr></table></figure>\n<p>真正的错误信息会被带在<code>ext</code>里字段返回，另外<code>res.ok</code>也改成调用适用性更好的<code>res.send</code>函数<br>（注意这里有个坑，<code>res.send</code>一个数字的话它会以为你只返回一个http状态码，因此虽然<code>res.send(200,data)</code>这种格式已被弃用，但是在目前还是必须这么处理才行）</p>\n"},{"title":"mingw32缺少posix_memalign函数","desc":"瞎玩","date":"2015-11-30T02:40:47.000Z","author":"ngtmuzi","_content":"\n想在`windows`上研究`word2vec`，于是查了一下如何`make`之类的东西，装好`mingw32`之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数`_aligned_malloc`，但是参数格式不一样，那还是自己动手吧：\n```c\nfunction posix_memalign( void ** memptr, size_t alignment, size_t size){\n  (* memptr) = _aligned_malloc(size, alignment);\n}\n```\n\n这样就可以编译通过了","source":"_posts/mingw32缺少posix_memalign函数.md","raw":"---\ntitle: mingw32缺少posix_memalign函数    \ndesc: 瞎玩 \ndate: 2015-11-30 10:40:47.000\ntags: C++\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n想在`windows`上研究`word2vec`，于是查了一下如何`make`之类的东西，装好`mingw32`之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数`_aligned_malloc`，但是参数格式不一样，那还是自己动手吧：\n```c\nfunction posix_memalign( void ** memptr, size_t alignment, size_t size){\n  (* memptr) = _aligned_malloc(size, alignment);\n}\n```\n\n这样就可以编译通过了","slug":"mingw32缺少posix_memalign函数","published":1,"updated":"2017-06-22T05:51:35.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481v9zw000fi8u0uqecvpda","content":"<p>想在<code>windows</code>上研究<code>word2vec</code>，于是查了一下如何<code>make</code>之类的东西，装好<code>mingw32</code>之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数<code>_aligned_malloc</code>，但是参数格式不一样，那还是自己动手吧：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">function <span class=\"title\">posix_memalign</span><span class=\"params\">( <span class=\"keyword\">void</span> ** memptr, <span class=\"keyword\">size_t</span> alignment, <span class=\"keyword\">size_t</span> size)</span></span>&#123;</div><div class=\"line\">  (* memptr) = _aligned_malloc(size, alignment);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就可以编译通过了</p>\n","excerpt":"","more":"<p>想在<code>windows</code>上研究<code>word2vec</code>，于是查了一下如何<code>make</code>之类的东西，装好<code>mingw32</code>之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数<code>_aligned_malloc</code>，但是参数格式不一样，那还是自己动手吧：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">function <span class=\"title\">posix_memalign</span><span class=\"params\">( <span class=\"keyword\">void</span> ** memptr, <span class=\"keyword\">size_t</span> alignment, <span class=\"keyword\">size_t</span> size)</span></span>&#123;</div><div class=\"line\">  (* memptr) = _aligned_malloc(size, alignment);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就可以编译通过了</p>\n"},{"title":"一次Node代码bug的追踪过程","desc":"这大概是遇见过的最难找的代码bug了","date":"2017-02-23T04:00:14.000Z","author":"ngtmuzi","_content":"## 背景  \n\n业务接入了elk日志系统，考虑到能自定义日志格式和Mapping，没有使用logstash来抓取日志，而选择用本地RabbitMQ队列+Node的Elasticsearch模块来自己写日志，写日志的具体逻辑如下  \n![日志写入流程](http://i1.piimg.com/4851/2d8505e03dc3e630.png)\n\n\n问题就出在这张图上。\n## bug描述\n\n在正式环境下这个日志写入进程会经常“挂”掉，因为有另一个进程定时检查RabbitMQ队列的消息量，所以会及时发现队列的消息堆积并发出报警，这个时候到RabbitMQ的管理界面上会看到日志进程断连了（日志队列的订阅者数量为0），RabbitMQ的日志也显示客户端心跳超时断连。正常来说连接断开会触发`amqplib`模块connection的close或者error之类的事件，而后进程会打印错误然后退出（PM2会自动重启），但从PM2上观察，日志进程却还在运行，也没有输出错误，然后在几十分钟后结束进程。\n  \n\n找不到问题就加日志检查咯，由于是实时性要求不高的日志写入进程，所以随意重启调试也没关系。我在定期写入Elastic的函数（每秒执行1次）里加了调试打印，发现神奇的一幕：每逢整10分钟或20分钟，日志打印就会停止，从raabitmq管理界面上就看到进程断开了。从这里能推出两点：\n1. 一定跟定时任务有关\n2. 定时任务不再执行，最大的可能性是有严重耗时的同步操作阻塞了javascript主线程，这个也能解释为什么没有触发断开连接的事件，实际上是触发了，但事件还在Node的事件队列里等待异步处理\n \n \n\n但之后就没头绪了，因为我的代码里根本没有每10分钟触发一次的定时任务，也没有复杂到能够卡住几十分钟的同步cpu运算，我开始怀疑是系统其他定时任务的原因影响，但并没有找到线索。\n## 进一步检查\n\n说来惭愧，以前碰到bug基本上都是靠加log来追踪调试的，基本都能解决，但碰到这个连log都不打印的情况，加log都没用了，这个时候就要搬出[Node的性能分析工具](https://nodejs.org/en/docs/guides/simple-profiling/)，先运行\n```cmd\nnode --prof index.js\n```\n\n收集性能日志，一直运行到进程卡住挂起再停止，Node会在运行文件夹生成一个“isolate-0xnnnnnnnnnnnn-v8.log”文件，然后用它来生成简化的性能报告\n```cmd\nnode --prof-process isolate-0xnnnnnnnnnnnn-v8.log > processed.txt\n```\n\n报告显示了代码中各个部分占用CPU时间的情况，检查“processed.txt”之后问题一目了然：\n```\n [JavaScript]:\n   ticks  total  nonlib   name\n  687497   75.5%   75.9%  LazyCompile: *findMiddleSnake /xxx/node_modules/.1.0.1@mdiff/lib/index.js:43:36\n  59471    6.5%    6.6%  Stub: StringCompareStub\n   3137    0.3%    0.3%  Stub: CEntryStub {1}\n   1545    0.2%    0.2%  Stub: CEntryStub\n   1080    0.1%    0.1%  Stub: LoadICStub\n```\n\n看到[`mdiff`](https://github.com/tapirdata/mdiff)这个模块还真是出乎意料，它用于流程图上“IM报警Appender”[（代码）](https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L108)的聚合日志功能，简单来说就是计算两条输出日志的相似度，比较接近的日志可以统计条数再输出，避免被同样内容的日志刷屏。\n\n\n原理比较暴力，就是计算出最大相同子串（就是LCS算法，使用`mdiff`模块提供的函数来处理），计算子串长度占原串长度的百分比（相似度）再进行聚合。那么这个计算LCS的操作会占用很长的CPU时间吗？\n  \n\n`mdiff`的文档上给出了使用算法的[论文地址](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927)，出于种种原因我们就不细究到具体算法了\\_(:3 」∠ )\\_，简单看了一下算法时间复杂度：O(ND)，在最坏条件下D=2N，也就是O(2N<sup>2</sup>)。而外层的统计聚合[（代码）](https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L208)，在最坏的情况下会调用`mdiff`的LCS算法M<sup>2</sup>（M：日志条数）次，也就是说最差的算法复杂度是O(2N<sup>2</sup>M<sup>2</sup>)，这可是十分可怕的……\n  \n\n再结合实际情况：一次批量写入最多512条日志，每秒写1次，日志进程向ElasticSearch写入日志经常会返回类似这样的错误：\n```\nversion conflict, current version [13] is different than the one provided [12]\n```\n\n而返回的错误我都会完整地打印log出来，以供IM报警（参见流程图），于是产生了大量非常非常长的错误log。这些log每隔5分钟会做一次统计聚合，于是产生了严重耗时的同步操作，导致所有异步回调都被阻塞，包括各个定时器和event订阅。\n\n## 解决方案\n1. 减少计算量  \n限制参与计算的日志长度和日志量，因为是用来聚合做IM报警的，本身就不需要完整显示出来，过长的日志可以直接截断。\n2. 减少错误出现次数  \nElastic会返回“version conflict”这个错误主要是因为存在多个进程同时写入一个文档的情况，官方也提供了[`retry_on_conflict`](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html#_parameters_2)这个参数来解决问题，在`bulk`操作中它的名字是`_retry_on_conflict`，用于指定返回错误前的重试次数，理论上来说调大它就会减少出现版本错误的概率\n\n做了上述处理之后，问题被修复\n## 总结\n1. 对不熟悉的事物保持敬畏，多翻文档多尝试\n2. 对自己的代码保持猜疑，注意考虑边界条件和兜底\n3. 善用工具能节省无谓的时间","source":"_posts/一次Node代码bug的追踪过程.md","raw":"---\ntitle: 一次Node代码bug的追踪过程\ndesc: 这大概是遇见过的最难找的代码bug了  \ndate: 2017-2-23 12:00:14  \ntags: \n- node  \nauthor: ngtmuzi  \ncategory: 亡羊补牢\n---\n## 背景  \n\n业务接入了elk日志系统，考虑到能自定义日志格式和Mapping，没有使用logstash来抓取日志，而选择用本地RabbitMQ队列+Node的Elasticsearch模块来自己写日志，写日志的具体逻辑如下  \n![日志写入流程](http://i1.piimg.com/4851/2d8505e03dc3e630.png)\n\n\n问题就出在这张图上。\n## bug描述\n\n在正式环境下这个日志写入进程会经常“挂”掉，因为有另一个进程定时检查RabbitMQ队列的消息量，所以会及时发现队列的消息堆积并发出报警，这个时候到RabbitMQ的管理界面上会看到日志进程断连了（日志队列的订阅者数量为0），RabbitMQ的日志也显示客户端心跳超时断连。正常来说连接断开会触发`amqplib`模块connection的close或者error之类的事件，而后进程会打印错误然后退出（PM2会自动重启），但从PM2上观察，日志进程却还在运行，也没有输出错误，然后在几十分钟后结束进程。\n  \n\n找不到问题就加日志检查咯，由于是实时性要求不高的日志写入进程，所以随意重启调试也没关系。我在定期写入Elastic的函数（每秒执行1次）里加了调试打印，发现神奇的一幕：每逢整10分钟或20分钟，日志打印就会停止，从raabitmq管理界面上就看到进程断开了。从这里能推出两点：\n1. 一定跟定时任务有关\n2. 定时任务不再执行，最大的可能性是有严重耗时的同步操作阻塞了javascript主线程，这个也能解释为什么没有触发断开连接的事件，实际上是触发了，但事件还在Node的事件队列里等待异步处理\n \n \n\n但之后就没头绪了，因为我的代码里根本没有每10分钟触发一次的定时任务，也没有复杂到能够卡住几十分钟的同步cpu运算，我开始怀疑是系统其他定时任务的原因影响，但并没有找到线索。\n## 进一步检查\n\n说来惭愧，以前碰到bug基本上都是靠加log来追踪调试的，基本都能解决，但碰到这个连log都不打印的情况，加log都没用了，这个时候就要搬出[Node的性能分析工具](https://nodejs.org/en/docs/guides/simple-profiling/)，先运行\n```cmd\nnode --prof index.js\n```\n\n收集性能日志，一直运行到进程卡住挂起再停止，Node会在运行文件夹生成一个“isolate-0xnnnnnnnnnnnn-v8.log”文件，然后用它来生成简化的性能报告\n```cmd\nnode --prof-process isolate-0xnnnnnnnnnnnn-v8.log > processed.txt\n```\n\n报告显示了代码中各个部分占用CPU时间的情况，检查“processed.txt”之后问题一目了然：\n```\n [JavaScript]:\n   ticks  total  nonlib   name\n  687497   75.5%   75.9%  LazyCompile: *findMiddleSnake /xxx/node_modules/.1.0.1@mdiff/lib/index.js:43:36\n  59471    6.5%    6.6%  Stub: StringCompareStub\n   3137    0.3%    0.3%  Stub: CEntryStub {1}\n   1545    0.2%    0.2%  Stub: CEntryStub\n   1080    0.1%    0.1%  Stub: LoadICStub\n```\n\n看到[`mdiff`](https://github.com/tapirdata/mdiff)这个模块还真是出乎意料，它用于流程图上“IM报警Appender”[（代码）](https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L108)的聚合日志功能，简单来说就是计算两条输出日志的相似度，比较接近的日志可以统计条数再输出，避免被同样内容的日志刷屏。\n\n\n原理比较暴力，就是计算出最大相同子串（就是LCS算法，使用`mdiff`模块提供的函数来处理），计算子串长度占原串长度的百分比（相似度）再进行聚合。那么这个计算LCS的操作会占用很长的CPU时间吗？\n  \n\n`mdiff`的文档上给出了使用算法的[论文地址](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927)，出于种种原因我们就不细究到具体算法了\\_(:3 」∠ )\\_，简单看了一下算法时间复杂度：O(ND)，在最坏条件下D=2N，也就是O(2N<sup>2</sup>)。而外层的统计聚合[（代码）](https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L208)，在最坏的情况下会调用`mdiff`的LCS算法M<sup>2</sup>（M：日志条数）次，也就是说最差的算法复杂度是O(2N<sup>2</sup>M<sup>2</sup>)，这可是十分可怕的……\n  \n\n再结合实际情况：一次批量写入最多512条日志，每秒写1次，日志进程向ElasticSearch写入日志经常会返回类似这样的错误：\n```\nversion conflict, current version [13] is different than the one provided [12]\n```\n\n而返回的错误我都会完整地打印log出来，以供IM报警（参见流程图），于是产生了大量非常非常长的错误log。这些log每隔5分钟会做一次统计聚合，于是产生了严重耗时的同步操作，导致所有异步回调都被阻塞，包括各个定时器和event订阅。\n\n## 解决方案\n1. 减少计算量  \n限制参与计算的日志长度和日志量，因为是用来聚合做IM报警的，本身就不需要完整显示出来，过长的日志可以直接截断。\n2. 减少错误出现次数  \nElastic会返回“version conflict”这个错误主要是因为存在多个进程同时写入一个文档的情况，官方也提供了[`retry_on_conflict`](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html#_parameters_2)这个参数来解决问题，在`bulk`操作中它的名字是`_retry_on_conflict`，用于指定返回错误前的重试次数，理论上来说调大它就会减少出现版本错误的概率\n\n做了上述处理之后，问题被修复\n## 总结\n1. 对不熟悉的事物保持敬畏，多翻文档多尝试\n2. 对自己的代码保持猜疑，注意考虑边界条件和兜底\n3. 善用工具能节省无谓的时间","slug":"一次Node代码bug的追踪过程","published":1,"updated":"2017-06-22T05:51:35.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481v9zz000ii8u03d39h9qd","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>业务接入了elk日志系统，考虑到能自定义日志格式和Mapping，没有使用logstash来抓取日志，而选择用本地RabbitMQ队列+Node的Elasticsearch模块来自己写日志，写日志的具体逻辑如下<br><img src=\"http://i1.piimg.com/4851/2d8505e03dc3e630.png\" alt=\"日志写入流程\"></p>\n<p>问题就出在这张图上。</p>\n<h2 id=\"bug描述\"><a href=\"#bug描述\" class=\"headerlink\" title=\"bug描述\"></a>bug描述</h2><p>在正式环境下这个日志写入进程会经常“挂”掉，因为有另一个进程定时检查RabbitMQ队列的消息量，所以会及时发现队列的消息堆积并发出报警，这个时候到RabbitMQ的管理界面上会看到日志进程断连了（日志队列的订阅者数量为0），RabbitMQ的日志也显示客户端心跳超时断连。正常来说连接断开会触发<code>amqplib</code>模块connection的close或者error之类的事件，而后进程会打印错误然后退出（PM2会自动重启），但从PM2上观察，日志进程却还在运行，也没有输出错误，然后在几十分钟后结束进程。</p>\n<p>找不到问题就加日志检查咯，由于是实时性要求不高的日志写入进程，所以随意重启调试也没关系。我在定期写入Elastic的函数（每秒执行1次）里加了调试打印，发现神奇的一幕：每逢整10分钟或20分钟，日志打印就会停止，从raabitmq管理界面上就看到进程断开了。从这里能推出两点：</p>\n<ol>\n<li>一定跟定时任务有关</li>\n<li>定时任务不再执行，最大的可能性是有严重耗时的同步操作阻塞了javascript主线程，这个也能解释为什么没有触发断开连接的事件，实际上是触发了，但事件还在Node的事件队列里等待异步处理</li>\n</ol>\n<p>但之后就没头绪了，因为我的代码里根本没有每10分钟触发一次的定时任务，也没有复杂到能够卡住几十分钟的同步cpu运算，我开始怀疑是系统其他定时任务的原因影响，但并没有找到线索。</p>\n<h2 id=\"进一步检查\"><a href=\"#进一步检查\" class=\"headerlink\" title=\"进一步检查\"></a>进一步检查</h2><p>说来惭愧，以前碰到bug基本上都是靠加log来追踪调试的，基本都能解决，但碰到这个连log都不打印的情况，加log都没用了，这个时候就要搬出<a href=\"https://nodejs.org/en/docs/guides/simple-profiling/\" target=\"_blank\" rel=\"external\">Node的性能分析工具</a>，先运行<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --prof index.js</div></pre></td></tr></table></figure></p>\n<p>收集性能日志，一直运行到进程卡住挂起再停止，Node会在运行文件夹生成一个“isolate-0xnnnnnnnnnnnn-v8.log”文件，然后用它来生成简化的性能报告<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --prof-process isolate-<span class=\"number\">0</span>xnnnnnnnnnnnn-v8.log &gt; processed.txt</div></pre></td></tr></table></figure></p>\n<p>报告显示了代码中各个部分占用CPU时间的情况，检查“processed.txt”之后问题一目了然：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[JavaScript]:</div><div class=\"line\">  ticks  total  nonlib   name</div><div class=\"line\"> 687497   75.5%   75.9%  LazyCompile: *findMiddleSnake /xxx/node_modules/.1.0.1@mdiff/lib/index.js:43:36</div><div class=\"line\"> 59471    6.5%    6.6%  Stub: StringCompareStub</div><div class=\"line\">  3137    0.3%    0.3%  Stub: CEntryStub &#123;1&#125;</div><div class=\"line\">  1545    0.2%    0.2%  Stub: CEntryStub</div><div class=\"line\">  1080    0.1%    0.1%  Stub: LoadICStub</div></pre></td></tr></table></figure></p>\n<p>看到<a href=\"https://github.com/tapirdata/mdiff\" target=\"_blank\" rel=\"external\"><code>mdiff</code></a>这个模块还真是出乎意料，它用于流程图上“IM报警Appender”<a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L108\" target=\"_blank\" rel=\"external\">（代码）</a>的聚合日志功能，简单来说就是计算两条输出日志的相似度，比较接近的日志可以统计条数再输出，避免被同样内容的日志刷屏。</p>\n<p>原理比较暴力，就是计算出最大相同子串（就是LCS算法，使用<code>mdiff</code>模块提供的函数来处理），计算子串长度占原串长度的百分比（相似度）再进行聚合。那么这个计算LCS的操作会占用很长的CPU时间吗？</p>\n<p><code>mdiff</code>的文档上给出了使用算法的<a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\" target=\"_blank\" rel=\"external\">论文地址</a>，出于种种原因我们就不细究到具体算法了_(:3 」∠ )_，简单看了一下算法时间复杂度：O(ND)，在最坏条件下D=2N，也就是O(2N<sup>2</sup>)。而外层的统计聚合<a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L208\" target=\"_blank\" rel=\"external\">（代码）</a>，在最坏的情况下会调用<code>mdiff</code>的LCS算法M<sup>2</sup>（M：日志条数）次，也就是说最差的算法复杂度是O(2N<sup>2</sup>M<sup>2</sup>)，这可是十分可怕的……</p>\n<p>再结合实际情况：一次批量写入最多512条日志，每秒写1次，日志进程向ElasticSearch写入日志经常会返回类似这样的错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">version conflict, current version [13] is different than the one provided [12]</div></pre></td></tr></table></figure></p>\n<p>而返回的错误我都会完整地打印log出来，以供IM报警（参见流程图），于是产生了大量非常非常长的错误log。这些log每隔5分钟会做一次统计聚合，于是产生了严重耗时的同步操作，导致所有异步回调都被阻塞，包括各个定时器和event订阅。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li>减少计算量<br>限制参与计算的日志长度和日志量，因为是用来聚合做IM报警的，本身就不需要完整显示出来，过长的日志可以直接截断。</li>\n<li>减少错误出现次数<br>Elastic会返回“version conflict”这个错误主要是因为存在多个进程同时写入一个文档的情况，官方也提供了<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html#_parameters_2\" target=\"_blank\" rel=\"external\"><code>retry_on_conflict</code></a>这个参数来解决问题，在<code>bulk</code>操作中它的名字是<code>_retry_on_conflict</code>，用于指定返回错误前的重试次数，理论上来说调大它就会减少出现版本错误的概率</li>\n</ol>\n<p>做了上述处理之后，问题被修复</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>对不熟悉的事物保持敬畏，多翻文档多尝试</li>\n<li>对自己的代码保持猜疑，注意考虑边界条件和兜底</li>\n<li>善用工具能节省无谓的时间</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>业务接入了elk日志系统，考虑到能自定义日志格式和Mapping，没有使用logstash来抓取日志，而选择用本地RabbitMQ队列+Node的Elasticsearch模块来自己写日志，写日志的具体逻辑如下<br><img src=\"http://i1.piimg.com/4851/2d8505e03dc3e630.png\" alt=\"日志写入流程\"></p>\n<p>问题就出在这张图上。</p>\n<h2 id=\"bug描述\"><a href=\"#bug描述\" class=\"headerlink\" title=\"bug描述\"></a>bug描述</h2><p>在正式环境下这个日志写入进程会经常“挂”掉，因为有另一个进程定时检查RabbitMQ队列的消息量，所以会及时发现队列的消息堆积并发出报警，这个时候到RabbitMQ的管理界面上会看到日志进程断连了（日志队列的订阅者数量为0），RabbitMQ的日志也显示客户端心跳超时断连。正常来说连接断开会触发<code>amqplib</code>模块connection的close或者error之类的事件，而后进程会打印错误然后退出（PM2会自动重启），但从PM2上观察，日志进程却还在运行，也没有输出错误，然后在几十分钟后结束进程。</p>\n<p>找不到问题就加日志检查咯，由于是实时性要求不高的日志写入进程，所以随意重启调试也没关系。我在定期写入Elastic的函数（每秒执行1次）里加了调试打印，发现神奇的一幕：每逢整10分钟或20分钟，日志打印就会停止，从raabitmq管理界面上就看到进程断开了。从这里能推出两点：</p>\n<ol>\n<li>一定跟定时任务有关</li>\n<li>定时任务不再执行，最大的可能性是有严重耗时的同步操作阻塞了javascript主线程，这个也能解释为什么没有触发断开连接的事件，实际上是触发了，但事件还在Node的事件队列里等待异步处理</li>\n</ol>\n<p>但之后就没头绪了，因为我的代码里根本没有每10分钟触发一次的定时任务，也没有复杂到能够卡住几十分钟的同步cpu运算，我开始怀疑是系统其他定时任务的原因影响，但并没有找到线索。</p>\n<h2 id=\"进一步检查\"><a href=\"#进一步检查\" class=\"headerlink\" title=\"进一步检查\"></a>进一步检查</h2><p>说来惭愧，以前碰到bug基本上都是靠加log来追踪调试的，基本都能解决，但碰到这个连log都不打印的情况，加log都没用了，这个时候就要搬出<a href=\"https://nodejs.org/en/docs/guides/simple-profiling/\">Node的性能分析工具</a>，先运行<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --prof index.js</div></pre></td></tr></table></figure></p>\n<p>收集性能日志，一直运行到进程卡住挂起再停止，Node会在运行文件夹生成一个“isolate-0xnnnnnnnnnnnn-v8.log”文件，然后用它来生成简化的性能报告<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --prof-process isolate-<span class=\"number\">0</span>xnnnnnnnnnnnn-v8.log &gt; processed.txt</div></pre></td></tr></table></figure></p>\n<p>报告显示了代码中各个部分占用CPU时间的情况，检查“processed.txt”之后问题一目了然：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[JavaScript]:</div><div class=\"line\">  ticks  total  nonlib   name</div><div class=\"line\"> 687497   75.5%   75.9%  LazyCompile: *findMiddleSnake /xxx/node_modules/.1.0.1@mdiff/lib/index.js:43:36</div><div class=\"line\"> 59471    6.5%    6.6%  Stub: StringCompareStub</div><div class=\"line\">  3137    0.3%    0.3%  Stub: CEntryStub &#123;1&#125;</div><div class=\"line\">  1545    0.2%    0.2%  Stub: CEntryStub</div><div class=\"line\">  1080    0.1%    0.1%  Stub: LoadICStub</div></pre></td></tr></table></figure></p>\n<p>看到<a href=\"https://github.com/tapirdata/mdiff\"><code>mdiff</code></a>这个模块还真是出乎意料，它用于流程图上“IM报警Appender”<a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L108\">（代码）</a>的聚合日志功能，简单来说就是计算两条输出日志的相似度，比较接近的日志可以统计条数再输出，避免被同样内容的日志刷屏。</p>\n<p>原理比较暴力，就是计算出最大相同子串（就是LCS算法，使用<code>mdiff</code>模块提供的函数来处理），计算子串长度占原串长度的百分比（相似度）再进行聚合。那么这个计算LCS的操作会占用很长的CPU时间吗？</p>\n<p><code>mdiff</code>的文档上给出了使用算法的<a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\">论文地址</a>，出于种种原因我们就不细究到具体算法了_(:3 」∠ )_，简单看了一下算法时间复杂度：O(ND)，在最坏条件下D=2N，也就是O(2N<sup>2</sup>)。而外层的统计聚合<a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L208\">（代码）</a>，在最坏的情况下会调用<code>mdiff</code>的LCS算法M<sup>2</sup>（M：日志条数）次，也就是说最差的算法复杂度是O(2N<sup>2</sup>M<sup>2</sup>)，这可是十分可怕的……</p>\n<p>再结合实际情况：一次批量写入最多512条日志，每秒写1次，日志进程向ElasticSearch写入日志经常会返回类似这样的错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">version conflict, current version [13] is different than the one provided [12]</div></pre></td></tr></table></figure></p>\n<p>而返回的错误我都会完整地打印log出来，以供IM报警（参见流程图），于是产生了大量非常非常长的错误log。这些log每隔5分钟会做一次统计聚合，于是产生了严重耗时的同步操作，导致所有异步回调都被阻塞，包括各个定时器和event订阅。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li>减少计算量<br>限制参与计算的日志长度和日志量，因为是用来聚合做IM报警的，本身就不需要完整显示出来，过长的日志可以直接截断。</li>\n<li>减少错误出现次数<br>Elastic会返回“version conflict”这个错误主要是因为存在多个进程同时写入一个文档的情况，官方也提供了<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html#_parameters_2\"><code>retry_on_conflict</code></a>这个参数来解决问题，在<code>bulk</code>操作中它的名字是<code>_retry_on_conflict</code>，用于指定返回错误前的重试次数，理论上来说调大它就会减少出现版本错误的概率</li>\n</ol>\n<p>做了上述处理之后，问题被修复</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>对不熟悉的事物保持敬畏，多翻文档多尝试</li>\n<li>对自己的代码保持猜疑，注意考虑边界条件和兜底</li>\n<li>善用工具能节省无谓的时间</li>\n</ol>\n"},{"title":"博客迁移到hexo","date":"2017-01-22T08:56:56.000Z","author":"ngtmuzi","_content":"\n博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~","source":"_posts/博客迁移到hexo.md","raw":"---\ntitle: 博客迁移到hexo\ndate: 2017-01-22 16:56:56\ncategory: 随笔\nauthor: ngtmuzi\n---\n\n博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~","slug":"博客迁移到hexo","published":1,"updated":"2017-06-22T05:51:35.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va02000mi8u0zzg4tb12","content":"<p>博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~</p>\n","excerpt":"","more":"<p>博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~</p>\n"},{"title":"个人博客绝赞内测中","subtitle":"来自hexo","desc":"现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧","date":"2015-11-29T10:29:53.000Z","author":"ngtmuzi","_content":"\n现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧","source":"_posts/个人博客绝赞内测中.md","raw":"---\ntitle: 个人博客绝赞内测中  \nsubtitle: 来自hexo  \ndesc: 现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧\ndate: 2015-11-29 18:29:53\ntags:  \nauthor: ngtmuzi  \ncategory: 随笔  \n---\n\n现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧","slug":"个人博客绝赞内测中","published":1,"updated":"2017-06-22T05:51:35.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va03000oi8u0escmzz07","content":"<p>现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧</p>\n","excerpt":"","more":"<p>现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧</p>\n"},{"title":"在前端确认框上套用Promise","desc":"jquery + bootstrap环境","author":"ngtmuzi","date":"2017-04-01T07:08:32.000Z","_content":"```javascript\n//jquery + bootstrap\nfunction askDlg(title, content) {\n  return new Promise(function (resolve, reject) {\n    $('#ask-title').text(title || '确认操作');\n    $('#ask-content').text(content || '确认操作吗？');\n\n    $('#ask-btn-yes').one('click', function () {\n      resolve();\n      $('#ask-dlg').modal('hide');\n    });\n\n    $('#ask-dlg').modal('show').one('hidden.bs.modal', reject);\n  });\n}\n```","source":"_posts/在前端确认框上套用Promise.md","raw":"---\ntitle: 在前端确认框上套用Promise\ndesc: jquery + bootstrap环境\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2017-04-01 15:08:32\ntags:\n- Promise\n- javaScript\n- 前端\n---\n```javascript\n//jquery + bootstrap\nfunction askDlg(title, content) {\n  return new Promise(function (resolve, reject) {\n    $('#ask-title').text(title || '确认操作');\n    $('#ask-content').text(content || '确认操作吗？');\n\n    $('#ask-btn-yes').one('click', function () {\n      resolve();\n      $('#ask-dlg').modal('hide');\n    });\n\n    $('#ask-dlg').modal('show').one('hidden.bs.modal', reject);\n  });\n}\n```","slug":"在前端确认框上套用Promise","published":1,"updated":"2017-04-01T07:28:10.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va05000si8u0afis3fyw","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//jquery + bootstrap</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">askDlg</span>(<span class=\"params\">title, content</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">    $(<span class=\"string\">'#ask-title'</span>).text(title || <span class=\"string\">'确认操作'</span>);</div><div class=\"line\">    $(<span class=\"string\">'#ask-content'</span>).text(content || <span class=\"string\">'确认操作吗？'</span>);</div><div class=\"line\"></div><div class=\"line\">    $(<span class=\"string\">'#ask-btn-yes'</span>).one(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      resolve();</div><div class=\"line\">      $(<span class=\"string\">'#ask-dlg'</span>).modal(<span class=\"string\">'hide'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    $(<span class=\"string\">'#ask-dlg'</span>).modal(<span class=\"string\">'show'</span>).one(<span class=\"string\">'hidden.bs.modal'</span>, reject);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//jquery + bootstrap</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">askDlg</span>(<span class=\"params\">title, content</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">    $(<span class=\"string\">'#ask-title'</span>).text(title || <span class=\"string\">'确认操作'</span>);</div><div class=\"line\">    $(<span class=\"string\">'#ask-content'</span>).text(content || <span class=\"string\">'确认操作吗？'</span>);</div><div class=\"line\"></div><div class=\"line\">    $(<span class=\"string\">'#ask-btn-yes'</span>).one(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      resolve();</div><div class=\"line\">      $(<span class=\"string\">'#ask-dlg'</span>).modal(<span class=\"string\">'hide'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    $(<span class=\"string\">'#ask-dlg'</span>).modal(<span class=\"string\">'show'</span>).one(<span class=\"string\">'hidden.bs.modal'</span>, reject);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"实现一个简单的Promise队列","desc":"Promise本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。","date":"2017-06-21T14:00:00.000Z","author":"ngtmuzi","_content":"\n*原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00*\n\n## 需求\n\n来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。\n\n很直观的改进方案就是用队列，系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是Promise写的，做流程控制好歹比callback简单多了\n\n## 思路\n\n* `Promise`本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。\n\n* 队列本身要有节流功能，即可以控制同一时间内在运行的`Promise`数量，参考`bluebird`的`map`函数中的concurrency(并发)字段。\n\n## 实现\n\n比较核心的代码简化起来就这一段：\n```javascript\n  function add(fn) {\n    return new Promise((resolve, reject) => {\n      this.queue.push(() =>\n        Promise.resolve()\n          .then(fn)\n          .then(resolve, reject)\n      );\n    });\n  }\n```\n\n可以看到我们是往`queue`队列里加入了一个函数，这个函数包裹了原函数`fn`，将它执行的同步或者异步的结果传给外层的`Promise`，这样对外表现就还是一个`Promise`，这个函数进入队列，等待轮到它执行的时机\n\n之后就是在内部维护一个“正在运行的任务数量”，在`fn`运行前后做加减和判断，就可以控制并行数了\n  \n完整代码：[np-queue](https://github.com/ngtmuzi/np-queue)  \n\n运行起来的感觉类似这样\n\n```javascript\nconst q = new Queue();\nconst delay = (value) =>  \n  new Promise(resolve => {\n    setTimeout(() => resolve(value), 1000);  \n  });\n\nq.add(()=>delay(1)).then(console.log);\nq.add(()=>delay(2)).then(console.log);\n\nconst delay_wrap = q.wrap(delay);\n\ndelay_wrap(3).then(console.log);\ndelay_wrap(4).then(console.log);\n```\n\n默认并发数是1，因此代码会相隔1秒依次输出`1,2,3,4`\n\n放到业务代码上，原代码是`delay().then(...)`，现在改为`q.add(delay).then(...)`，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解\n\n再配合`wrap()`方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：\n```javascript\nconst wrapFn = function () {\n  return queue.add(fn.bind(thisArg, ...arguments));\n};\n```\n原代码为`delay(a,b).then(...)`我们可以改为`delay_wrap(a,b).then(...)`，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。","source":"_posts/实现一个简单的promise队列.md","raw":"---\ntitle: 实现一个简单的Promise队列\ndesc: Promise本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。  \ndate: 2017-6-21 22:00:00.000  \ntags: \n- javascript\n- Promise\n- ES6\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n*原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00*\n\n## 需求\n\n来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。\n\n很直观的改进方案就是用队列，系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是Promise写的，做流程控制好歹比callback简单多了\n\n## 思路\n\n* `Promise`本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。\n\n* 队列本身要有节流功能，即可以控制同一时间内在运行的`Promise`数量，参考`bluebird`的`map`函数中的concurrency(并发)字段。\n\n## 实现\n\n比较核心的代码简化起来就这一段：\n```javascript\n  function add(fn) {\n    return new Promise((resolve, reject) => {\n      this.queue.push(() =>\n        Promise.resolve()\n          .then(fn)\n          .then(resolve, reject)\n      );\n    });\n  }\n```\n\n可以看到我们是往`queue`队列里加入了一个函数，这个函数包裹了原函数`fn`，将它执行的同步或者异步的结果传给外层的`Promise`，这样对外表现就还是一个`Promise`，这个函数进入队列，等待轮到它执行的时机\n\n之后就是在内部维护一个“正在运行的任务数量”，在`fn`运行前后做加减和判断，就可以控制并行数了\n  \n完整代码：[np-queue](https://github.com/ngtmuzi/np-queue)  \n\n运行起来的感觉类似这样\n\n```javascript\nconst q = new Queue();\nconst delay = (value) =>  \n  new Promise(resolve => {\n    setTimeout(() => resolve(value), 1000);  \n  });\n\nq.add(()=>delay(1)).then(console.log);\nq.add(()=>delay(2)).then(console.log);\n\nconst delay_wrap = q.wrap(delay);\n\ndelay_wrap(3).then(console.log);\ndelay_wrap(4).then(console.log);\n```\n\n默认并发数是1，因此代码会相隔1秒依次输出`1,2,3,4`\n\n放到业务代码上，原代码是`delay().then(...)`，现在改为`q.add(delay).then(...)`，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解\n\n再配合`wrap()`方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：\n```javascript\nconst wrapFn = function () {\n  return queue.add(fn.bind(thisArg, ...arguments));\n};\n```\n原代码为`delay(a,b).then(...)`我们可以改为`delay_wrap(a,b).then(...)`，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。","slug":"实现一个简单的promise队列","published":1,"updated":"2017-06-22T04:12:58.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va06000ui8u01gyozwcp","content":"<p><em>原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00</em></p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。</p>\n<p>很直观的改进方案就是用队列，系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是Promise写的，做流程控制好歹比callback简单多了</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ul>\n<li><p><code>Promise</code>本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。</p>\n</li>\n<li><p>队列本身要有节流功能，即可以控制同一时间内在运行的<code>Promise</code>数量，参考<code>bluebird</code>的<code>map</code>函数中的concurrency(并发)字段。</p>\n</li>\n</ul>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>比较核心的代码简化起来就这一段：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.queue.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span></div><div class=\"line\">      <span class=\"built_in\">Promise</span>.resolve()</div><div class=\"line\">        .then(fn)</div><div class=\"line\">        .then(resolve, reject)</div><div class=\"line\">    );</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到我们是往<code>queue</code>队列里加入了一个函数，这个函数包裹了原函数<code>fn</code>，将它执行的同步或者异步的结果传给外层的<code>Promise</code>，这样对外表现就还是一个<code>Promise</code>，这个函数进入队列，等待轮到它执行的时机</p>\n<p>之后就是在内部维护一个“正在运行的任务数量”，在<code>fn</code>运行前后做加减和判断，就可以控制并行数了</p>\n<p>完整代码：<a href=\"https://github.com/ngtmuzi/np-queue\" target=\"_blank\" rel=\"external\">np-queue</a>  </p>\n<p>运行起来的感觉类似这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> q = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span>  </div><div class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(value), <span class=\"number\">1000</span>);  </div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">q.add(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>delay(<span class=\"number\">1</span>)).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\">q.add(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>delay(<span class=\"number\">2</span>)).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> delay_wrap = q.wrap(delay);</div><div class=\"line\"></div><div class=\"line\">delay_wrap(<span class=\"number\">3</span>).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\">delay_wrap(<span class=\"number\">4</span>).then(<span class=\"built_in\">console</span>.log);</div></pre></td></tr></table></figure>\n<p>默认并发数是1，因此代码会相隔1秒依次输出<code>1,2,3,4</code></p>\n<p>放到业务代码上，原代码是<code>delay().then(...)</code>，现在改为<code>q.add(delay).then(...)</code>，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解</p>\n<p>再配合<code>wrap()</code>方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> wrapFn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> queue.add(fn.bind(thisArg, ...arguments));</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>原代码为<code>delay(a,b).then(...)</code>我们可以改为<code>delay_wrap(a,b).then(...)</code>，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。</p>\n","excerpt":"","more":"<p><em>原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00</em></p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。</p>\n<p>很直观的改进方案就是用队列，系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是Promise写的，做流程控制好歹比callback简单多了</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ul>\n<li><p><code>Promise</code>本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。</p>\n</li>\n<li><p>队列本身要有节流功能，即可以控制同一时间内在运行的<code>Promise</code>数量，参考<code>bluebird</code>的<code>map</code>函数中的concurrency(并发)字段。</p>\n</li>\n</ul>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>比较核心的代码简化起来就这一段：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.queue.push(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span></div><div class=\"line\">      <span class=\"built_in\">Promise</span>.resolve()</div><div class=\"line\">        .then(fn)</div><div class=\"line\">        .then(resolve, reject)</div><div class=\"line\">    );</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到我们是往<code>queue</code>队列里加入了一个函数，这个函数包裹了原函数<code>fn</code>，将它执行的同步或者异步的结果传给外层的<code>Promise</code>，这样对外表现就还是一个<code>Promise</code>，这个函数进入队列，等待轮到它执行的时机</p>\n<p>之后就是在内部维护一个“正在运行的任务数量”，在<code>fn</code>运行前后做加减和判断，就可以控制并行数了</p>\n<p>完整代码：<a href=\"https://github.com/ngtmuzi/np-queue\">np-queue</a>  </p>\n<p>运行起来的感觉类似这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> q = <span class=\"keyword\">new</span> Queue();</div><div class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span>  </div><div class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(value), <span class=\"number\">1000</span>);  </div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">q.add(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>delay(<span class=\"number\">1</span>)).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\">q.add(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>delay(<span class=\"number\">2</span>)).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> delay_wrap = q.wrap(delay);</div><div class=\"line\"></div><div class=\"line\">delay_wrap(<span class=\"number\">3</span>).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\">delay_wrap(<span class=\"number\">4</span>).then(<span class=\"built_in\">console</span>.log);</div></pre></td></tr></table></figure>\n<p>默认并发数是1，因此代码会相隔1秒依次输出<code>1,2,3,4</code></p>\n<p>放到业务代码上，原代码是<code>delay().then(...)</code>，现在改为<code>q.add(delay).then(...)</code>，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解</p>\n<p>再配合<code>wrap()</code>方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> wrapFn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> queue.add(fn.bind(thisArg, ...arguments));</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>原代码为<code>delay(a,b).then(...)</code>我们可以改为<code>delay_wrap(a,b).then(...)</code>，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。</p>\n"},{"title":"异步编程，async/await还是promise？","desc":"还是bluebird好用啊","date":"2017-04-19T11:00:14.000Z","author":"ngtmuzi","_content":"\nNode.js的`v7.6`版本出来之后`async/await`正式成为可用特性，其最大的亮点就是将异步的逻辑写在同步的代码里，还能捕捉到异步错误，成为了异步编程的最佳实践，但我们真的能完全抛弃掉`promise`吗？  \n\n* Node的自带模块提供的异步接口都是回调式的，想封成async函数你起码还得用类似bluebird的`Promise.promisify`来封装一遍\n* 同步的错误捕获也并不一定就最好，起码`try/catch`比起`.catch()`还是要多上几行的，想要在各层代码做捕获还要多加几层`try/catch`，看起来很乱\n* `async`定义的函数所返回的是javascript原生的`Promise`对象，也就是说第三方Promise库所提供的各种特性不能在`async`函数后直接使用了，外面还要再包一层`Promise.resolve()`才能转成当前所用的Promise对象，考虑到这点挺烦人的，有些小特性我就干脆直接往原生`Promise`的原型链上挂了\n\n\n异步编程必然要考虑超时，但使用`async`定义的函数并没有这么方便的功能，那我们就参考`bluebird`的格式加到原生`Promise`原型上好了：\n```javascript\nPromise.prototype.timeout = function (ms) {\n  return new Promise((resolve, reject) => {\n    this.then(resolve, reject);\n    setTimeout(() => reject(new Error('promise timeout')), +ms);\n  });\n};\n```\n\n也可以在`new Promise()`时直接使用第三方的Promise库，这样就相当于调过`.timeout()`的`promise`都做了一层包装了，唯一注意的一点是在这段代码之前可不要用类似`global.Promise = require('bluebird')`的语句替换掉原生`Promise`对象\n\n\n最后总结下自己对于`async/await`/`Promise`的一些抉择：\n* 业务逻辑代码可以多用`async/await`，以便在各种条件分支中同步地调用异步代码和捕捉错误\n* 注重流程的，没有太多分支的较底层代码，和已经使用`Promise`开发的旧代码，没有必要转成`async/await`，各种Promise库提供的特性更方便实现各种复杂的异步逻辑\n\n\n简言之，就是业务逻辑多用`async/await`，底层代码多用`Promise`","source":"_posts/异步编程，asyncawait还是promise？.md","raw":"---\ntitle: 异步编程，async/await还是promise？  \ndesc: 还是bluebird好用啊  \ndate: 2017-4-19 19:00:14  \ntags: \n- promise\n- async\n- es7\nauthor: ngtmuzi  \ncategory: 神秘代码\n\n---\n\nNode.js的`v7.6`版本出来之后`async/await`正式成为可用特性，其最大的亮点就是将异步的逻辑写在同步的代码里，还能捕捉到异步错误，成为了异步编程的最佳实践，但我们真的能完全抛弃掉`promise`吗？  \n\n* Node的自带模块提供的异步接口都是回调式的，想封成async函数你起码还得用类似bluebird的`Promise.promisify`来封装一遍\n* 同步的错误捕获也并不一定就最好，起码`try/catch`比起`.catch()`还是要多上几行的，想要在各层代码做捕获还要多加几层`try/catch`，看起来很乱\n* `async`定义的函数所返回的是javascript原生的`Promise`对象，也就是说第三方Promise库所提供的各种特性不能在`async`函数后直接使用了，外面还要再包一层`Promise.resolve()`才能转成当前所用的Promise对象，考虑到这点挺烦人的，有些小特性我就干脆直接往原生`Promise`的原型链上挂了\n\n\n异步编程必然要考虑超时，但使用`async`定义的函数并没有这么方便的功能，那我们就参考`bluebird`的格式加到原生`Promise`原型上好了：\n```javascript\nPromise.prototype.timeout = function (ms) {\n  return new Promise((resolve, reject) => {\n    this.then(resolve, reject);\n    setTimeout(() => reject(new Error('promise timeout')), +ms);\n  });\n};\n```\n\n也可以在`new Promise()`时直接使用第三方的Promise库，这样就相当于调过`.timeout()`的`promise`都做了一层包装了，唯一注意的一点是在这段代码之前可不要用类似`global.Promise = require('bluebird')`的语句替换掉原生`Promise`对象\n\n\n最后总结下自己对于`async/await`/`Promise`的一些抉择：\n* 业务逻辑代码可以多用`async/await`，以便在各种条件分支中同步地调用异步代码和捕捉错误\n* 注重流程的，没有太多分支的较底层代码，和已经使用`Promise`开发的旧代码，没有必要转成`async/await`，各种Promise库提供的特性更方便实现各种复杂的异步逻辑\n\n\n简言之，就是业务逻辑多用`async/await`，底层代码多用`Promise`","slug":"异步编程，asyncawait还是promise？","published":1,"updated":"2017-06-22T05:51:35.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va09000zi8u05nia5uvh","content":"<p>Node.js的<code>v7.6</code>版本出来之后<code>async/await</code>正式成为可用特性，其最大的亮点就是将异步的逻辑写在同步的代码里，还能捕捉到异步错误，成为了异步编程的最佳实践，但我们真的能完全抛弃掉<code>promise</code>吗？  </p>\n<ul>\n<li>Node的自带模块提供的异步接口都是回调式的，想封成async函数你起码还得用类似bluebird的<code>Promise.promisify</code>来封装一遍</li>\n<li>同步的错误捕获也并不一定就最好，起码<code>try/catch</code>比起<code>.catch()</code>还是要多上几行的，想要在各层代码做捕获还要多加几层<code>try/catch</code>，看起来很乱</li>\n<li><code>async</code>定义的函数所返回的是javascript原生的<code>Promise</code>对象，也就是说第三方Promise库所提供的各种特性不能在<code>async</code>函数后直接使用了，外面还要再包一层<code>Promise.resolve()</code>才能转成当前所用的Promise对象，考虑到这点挺烦人的，有些小特性我就干脆直接往原生<code>Promise</code>的原型链上挂了</li>\n</ul>\n<p>异步编程必然要考虑超时，但使用<code>async</code>定义的函数并没有这么方便的功能，那我们就参考<code>bluebird</code>的格式加到原生<code>Promise</code>原型上好了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.prototype.timeout = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ms</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.then(resolve, reject);</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'promise timeout'</span>)), +ms);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>也可以在<code>new Promise()</code>时直接使用第三方的Promise库，这样就相当于调过<code>.timeout()</code>的<code>promise</code>都做了一层包装了，唯一注意的一点是在这段代码之前可不要用类似<code>global.Promise = require(&#39;bluebird&#39;)</code>的语句替换掉原生<code>Promise</code>对象</p>\n<p>最后总结下自己对于<code>async/await</code>/<code>Promise</code>的一些抉择：</p>\n<ul>\n<li>业务逻辑代码可以多用<code>async/await</code>，以便在各种条件分支中同步地调用异步代码和捕捉错误</li>\n<li>注重流程的，没有太多分支的较底层代码，和已经使用<code>Promise</code>开发的旧代码，没有必要转成<code>async/await</code>，各种Promise库提供的特性更方便实现各种复杂的异步逻辑</li>\n</ul>\n<p>简言之，就是业务逻辑多用<code>async/await</code>，底层代码多用<code>Promise</code></p>\n","excerpt":"","more":"<p>Node.js的<code>v7.6</code>版本出来之后<code>async/await</code>正式成为可用特性，其最大的亮点就是将异步的逻辑写在同步的代码里，还能捕捉到异步错误，成为了异步编程的最佳实践，但我们真的能完全抛弃掉<code>promise</code>吗？  </p>\n<ul>\n<li>Node的自带模块提供的异步接口都是回调式的，想封成async函数你起码还得用类似bluebird的<code>Promise.promisify</code>来封装一遍</li>\n<li>同步的错误捕获也并不一定就最好，起码<code>try/catch</code>比起<code>.catch()</code>还是要多上几行的，想要在各层代码做捕获还要多加几层<code>try/catch</code>，看起来很乱</li>\n<li><code>async</code>定义的函数所返回的是javascript原生的<code>Promise</code>对象，也就是说第三方Promise库所提供的各种特性不能在<code>async</code>函数后直接使用了，外面还要再包一层<code>Promise.resolve()</code>才能转成当前所用的Promise对象，考虑到这点挺烦人的，有些小特性我就干脆直接往原生<code>Promise</code>的原型链上挂了</li>\n</ul>\n<p>异步编程必然要考虑超时，但使用<code>async</code>定义的函数并没有这么方便的功能，那我们就参考<code>bluebird</code>的格式加到原生<code>Promise</code>原型上好了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.prototype.timeout = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ms</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.then(resolve, reject);</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'promise timeout'</span>)), +ms);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>也可以在<code>new Promise()</code>时直接使用第三方的Promise库，这样就相当于调过<code>.timeout()</code>的<code>promise</code>都做了一层包装了，唯一注意的一点是在这段代码之前可不要用类似<code>global.Promise = require(&#39;bluebird&#39;)</code>的语句替换掉原生<code>Promise</code>对象</p>\n<p>最后总结下自己对于<code>async/await</code>/<code>Promise</code>的一些抉择：</p>\n<ul>\n<li>业务逻辑代码可以多用<code>async/await</code>，以便在各种条件分支中同步地调用异步代码和捕捉错误</li>\n<li>注重流程的，没有太多分支的较底层代码，和已经使用<code>Promise</code>开发的旧代码，没有必要转成<code>async/await</code>，各种Promise库提供的特性更方便实现各种复杂的异步逻辑</li>\n</ul>\n<p>简言之，就是业务逻辑多用<code>async/await</code>，底层代码多用<code>Promise</code></p>\n"},{"title":"自己撸一个Promise库的过程","desc":"因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧","date":"2017-01-19T01:54:47.349Z","author":"ngtmuzi","_content":"\n新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，`Promise`从ES6出来就用到现在，`then/catch`那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下\n\n## 参考资料：\n\n>[Promises/A+规范](https://promisesaplus.com/)  \n>[崔鹏飞的博客](http://cuipengfei.me/blog/2016/05/15/promise/)  \n>[Promise测试库](https://github.com/promises-aplus/promises-tests)\n\n\n从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。\n\n## 注意点\n\n因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：\n\n* 三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)\n* **规范2.2.4**：`onFulfilled`或`onRejected`在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使`Promise`已经`resolved`），而常用的异步执行函数就是`setTimeout`、`setImmediate`以及node特有的`process.nextTick`等函数，具体函数的不同会影响到整个`Promise`执行的效率，这里可以关注一下\n* **规范2.2.6.1**：当`Promise`进入完成状态，所有`onFulfilled`都需要按它们调用`then`的顺序来触发；这里隐含了一个点：`then`里传进去的函数是通过主动回调来触发的，也就是说`Promise`本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少\n* **规范2.3**：Promise解决程序，规范里将它表示为`[[Resolve]](promise, x)`，实际上就是写一个函数，输入一个未完成的`promise`和值`x`，通过一系列规则判断，以确定这个`promise`最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进`x.then`的函数仅能被调用一次，全程记得用`try-catch`包裹\n\n\n这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些`bluebird`的常用方法，比如`try`、`all`、`map`之类的，对理解代码逻辑很有帮助。\n\n\n附上[我的Promise库](https://github.com/ngtmuzi/np/blob/master/index.js)。另外要说一句，多尝试`new Promise()`来自己封装异步代码，我是见过不少同事只懂从`Promise.resolve()`开始的，那就弄丢了Promise最强大的部分","source":"_posts/自己撸一个Promise库的过程.md","raw":"---\ntitle: 自己撸一个Promise库的过程\ndesc: 因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧  \ndate: 2017-1-19 9:54:47.349\ntags: \n- Promise\n- ES6  \nauthor: ngtmuzi  \ncategory: 班门弄斧\n---\n\n新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，`Promise`从ES6出来就用到现在，`then/catch`那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下\n\n## 参考资料：\n\n>[Promises/A+规范](https://promisesaplus.com/)  \n>[崔鹏飞的博客](http://cuipengfei.me/blog/2016/05/15/promise/)  \n>[Promise测试库](https://github.com/promises-aplus/promises-tests)\n\n\n从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。\n\n## 注意点\n\n因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：\n\n* 三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)\n* **规范2.2.4**：`onFulfilled`或`onRejected`在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使`Promise`已经`resolved`），而常用的异步执行函数就是`setTimeout`、`setImmediate`以及node特有的`process.nextTick`等函数，具体函数的不同会影响到整个`Promise`执行的效率，这里可以关注一下\n* **规范2.2.6.1**：当`Promise`进入完成状态，所有`onFulfilled`都需要按它们调用`then`的顺序来触发；这里隐含了一个点：`then`里传进去的函数是通过主动回调来触发的，也就是说`Promise`本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少\n* **规范2.3**：Promise解决程序，规范里将它表示为`[[Resolve]](promise, x)`，实际上就是写一个函数，输入一个未完成的`promise`和值`x`，通过一系列规则判断，以确定这个`promise`最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进`x.then`的函数仅能被调用一次，全程记得用`try-catch`包裹\n\n\n这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些`bluebird`的常用方法，比如`try`、`all`、`map`之类的，对理解代码逻辑很有帮助。\n\n\n附上[我的Promise库](https://github.com/ngtmuzi/np/blob/master/index.js)。另外要说一句，多尝试`new Promise()`来自己封装异步代码，我是见过不少同事只懂从`Promise.resolve()`开始的，那就弄丢了Promise最强大的部分","slug":"自己撸一个Promise库的过程","published":1,"updated":"2017-06-22T05:51:35.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va0b0011i8u0x1scpu3q","content":"<p>新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，<code>Promise</code>从ES6出来就用到现在，<code>then/catch</code>那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><blockquote>\n<p><a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"external\">Promises/A+规范</a><br><a href=\"http://cuipengfei.me/blog/2016/05/15/promise/\" target=\"_blank\" rel=\"external\">崔鹏飞的博客</a><br><a href=\"https://github.com/promises-aplus/promises-tests\" target=\"_blank\" rel=\"external\">Promise测试库</a></p>\n</blockquote>\n<p>从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：</p>\n<ul>\n<li>三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)</li>\n<li><strong>规范2.2.4</strong>：<code>onFulfilled</code>或<code>onRejected</code>在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使<code>Promise</code>已经<code>resolved</code>），而常用的异步执行函数就是<code>setTimeout</code>、<code>setImmediate</code>以及node特有的<code>process.nextTick</code>等函数，具体函数的不同会影响到整个<code>Promise</code>执行的效率，这里可以关注一下</li>\n<li><strong>规范2.2.6.1</strong>：当<code>Promise</code>进入完成状态，所有<code>onFulfilled</code>都需要按它们调用<code>then</code>的顺序来触发；这里隐含了一个点：<code>then</code>里传进去的函数是通过主动回调来触发的，也就是说<code>Promise</code>本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少</li>\n<li><strong>规范2.3</strong>：Promise解决程序，规范里将它表示为<code>[[Resolve]](promise, x)</code>，实际上就是写一个函数，输入一个未完成的<code>promise</code>和值<code>x</code>，通过一系列规则判断，以确定这个<code>promise</code>最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进<code>x.then</code>的函数仅能被调用一次，全程记得用<code>try-catch</code>包裹</li>\n</ul>\n<p>这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些<code>bluebird</code>的常用方法，比如<code>try</code>、<code>all</code>、<code>map</code>之类的，对理解代码逻辑很有帮助。</p>\n<p>附上<a href=\"https://github.com/ngtmuzi/np/blob/master/index.js\" target=\"_blank\" rel=\"external\">我的Promise库</a>。另外要说一句，多尝试<code>new Promise()</code>来自己封装异步代码，我是见过不少同事只懂从<code>Promise.resolve()</code>开始的，那就弄丢了Promise最强大的部分</p>\n","excerpt":"","more":"<p>新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，<code>Promise</code>从ES6出来就用到现在，<code>then/catch</code>那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><blockquote>\n<p><a href=\"https://promisesaplus.com/\">Promises/A+规范</a><br><a href=\"http://cuipengfei.me/blog/2016/05/15/promise/\">崔鹏飞的博客</a><br><a href=\"https://github.com/promises-aplus/promises-tests\">Promise测试库</a></p>\n</blockquote>\n<p>从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：</p>\n<ul>\n<li>三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)</li>\n<li><strong>规范2.2.4</strong>：<code>onFulfilled</code>或<code>onRejected</code>在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使<code>Promise</code>已经<code>resolved</code>），而常用的异步执行函数就是<code>setTimeout</code>、<code>setImmediate</code>以及node特有的<code>process.nextTick</code>等函数，具体函数的不同会影响到整个<code>Promise</code>执行的效率，这里可以关注一下</li>\n<li><strong>规范2.2.6.1</strong>：当<code>Promise</code>进入完成状态，所有<code>onFulfilled</code>都需要按它们调用<code>then</code>的顺序来触发；这里隐含了一个点：<code>then</code>里传进去的函数是通过主动回调来触发的，也就是说<code>Promise</code>本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少</li>\n<li><strong>规范2.3</strong>：Promise解决程序，规范里将它表示为<code>[[Resolve]](promise, x)</code>，实际上就是写一个函数，输入一个未完成的<code>promise</code>和值<code>x</code>，通过一系列规则判断，以确定这个<code>promise</code>最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进<code>x.then</code>的函数仅能被调用一次，全程记得用<code>try-catch</code>包裹</li>\n</ul>\n<p>这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些<code>bluebird</code>的常用方法，比如<code>try</code>、<code>all</code>、<code>map</code>之类的，对理解代码逻辑很有帮助。</p>\n<p>附上<a href=\"https://github.com/ngtmuzi/np/blob/master/index.js\">我的Promise库</a>。另外要说一句，多尝试<code>new Promise()</code>来自己封装异步代码，我是见过不少同事只懂从<code>Promise.resolve()</code>开始的，那就弄丢了Promise最强大的部分</p>\n"},{"title":"Node监视文件以实现热更新","desc":"在有限范围内使用效果还是很好的","author":"ngtmuzi","date":"2017-05-16T03:47:16.000Z","_content":"\n在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的[《Node.js Web应用代码热更新的另类思路》](http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/)，写得很详细考虑得也很全，我的思路也类似这样，不过在替换旧模块上有些不同，总结出来权当抛砖引玉。\n\n为了方便说明，部分代码有省略细节，详细可以参见[完整代码](https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js)\n\n## 需求\n\n我的最开始需求倒不是要实现热更新这样听起来很炫酷的功能，只是想动态更新配置文件（JSON或JS）的内容到内存，避免每次改小小的配置都要重启进程\n\n## 基本思路\n* 监视文件/目录改动\n* 清空require.cache中的模块缓存并重新require\n* 用新模块覆盖旧模块\n\n## 监视文件/目录改动\n\n### 定位\n首先使用`path.resolve`来定位文件，其实使用`require.resolve`可以根据[node寻找模块的规则](https://nodejs.org/api/modules.html#modules_file_modules)更智能地定位到一个模块的入口文件（比如xxx/index.js）的，但更多情况下我们并不只是监视这个index.js而是想监视整个文件夹的改动（举个例子，index.js里require了同目录的xx.json并做了一系列计算最后把计算结果挂载`module.exports`上，这个时候单单监视index.js是没什么用的。）\n\n### 监视/防抖动\n原本是简单地使用`fs.watch`来监视文件，但其在linux下是无法监视到子目录/文件的改动的（参见[node文档](https://nodejs.org/api/fs.html#fs_caveats)），因此后来改用了被众多知名工具依赖的文件监视模块[chokidar](https://github.com/paulmillr/chokidar)，并且出于实际情况增加了防抖动\n```javascript\nchokidar.watch(filePath).on('all', lodash.debounce(update, 300));\n```\n\n## 清空require.cache中的模块缓存并重新require\n\n### 清空缓存\n考虑到监视的有可能是一个目录而非单个文件的情况，我们需要在清除时多考虑一下，把整个目录的引用都清除掉\n```javascript\nObject.keys(require.cache).forEach(function (cachePath) {\n  if (cachePath.startsWith(filePath)) {\n    delete require.cache[cachePath];\n  }\n});\n```\n\n### 重新require\n```javascript\nvar newModule = require(filePath);\n```\n这个时候可能会报一些找不到文件，代码语法错误之类的同步错误，这个属于预期范围内，我的处理逻辑如下：\n* 第一次require是同步的，这时的错误会同步抛出，一般来说就会结束进程，因为确实没找到文件\n* 监视事件触发并重新require时产生的错误会丢给回调函数，并且保持原模块的内容不做更改（避免意外修改文件产生语法错误导致模块失效或进程退出）\n\n## 用新模块覆盖旧模块\n如果我们在使用模块时能够遵守一个约定：**`module.exports`是Object，且其他模块永远从该模块所暴露的`module.exports`上取值**，那么我们就不需要去做反射，闭包之类的处理，只要简单地使用\n```javascript\nObject.assign(target,newMoudle)\n```\n就可以在保持该对象的引用不变的情况下增改属性，考虑到有删除属性的情况，我自己写了一段比较暴力的覆写的函数\n```javascript\nfunction override(target, source) {\n  Object.keys(target).forEach(function (key) {\n    if (!source.hasOwnProperty(key)) delete target[key];\n  });\n  Object.keys(source).forEach(function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\n```\n外部模块只要是遵守了上述约定，就可以完全透明地取得最新的属性内容，对于我主要的应用场景——动态读取配置文件来说，这个还是很容易遵守的\n\n## 使用方式\n只有一个模块引用的话，直接调用即可\n```javascript\nconst some = watchModule('./originModule');\n//从module.exports上取得的一定是最新值\nconsole.log(some.a);\n```\n当有多处需要引用时，建议使用一个代理的模块来挂载，这样在其他模块就可以直接用普通的require了（注意不要对一个模块多次调用watchModule，这样会产生重复事件）\n```javascript\n//originModule\nmodule.exports={a:1}; \n\n//代理模块\nmodule.exports = watchModule('./originModule');\n\n//其他模块\nconst some = require('proxyModule');\n\n//从module.exports上取得的一定是最新值\nconsole.log(some.a);\n```\n具体到上面文章提到的express动态挂载路由，`app.use`需要的是一个函数，因此我们无能为力——原函数已经被`app.use`挂载到中间件链上了，这种情况还是考虑使用一层闭包吧\n\n## 总结\n思路都是类似的，只是我多加了一个约定，只要遵守这个约定我们就可以写出一个比较通用的监视模块，当然这也并不是万能的，比如module.exports必须是Object（其他类型可以用Object多包裹一层），很多极限条件也没考虑到（比如Proxy、不可变Object、原型链、不可枚举的属性等），但对于普通的业务代码和配置文件来说这应该是没有什么问题了  \n\n另外提醒一点，允许动态更新代码是**非常危险**的，比如我提到的这种允许读js作为配置文件的情况，万一js里来句`process.exit`或者其他恶意代码就挂了，可以根据实际需要来考虑加上限制\n\n[完整代码](https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js)，欢迎讨论指正。\n\n## 补充：旧模块资源的释放\n阅读了上面的文章后才发现确实没考虑到这里，并且由于配置文件并不是频繁改动，在正式环境下也没出现过问题，但测试过后确实存在旧模块没有释放的情况（考虑还是不周啊），我们可以参考上面文章中fangshi给出的代码来清除引用\n```javascript\n    var module = require.cache[modulePath];\n    // remove reference in module.parent\n    if (module.parent) {\n        module.parent.children.splice(module.parent.children.indexOf(module), 1);\n    }\n```\n","source":"_posts/Node监视文件以实现热更新.md","raw":"---\ntitle: Node监视文件以实现热更新\ndesc: 在有限范围内使用效果还是很好的\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2017-05-16 11:47:16\ntags:\n- nodejs\n---\n\n在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的[《Node.js Web应用代码热更新的另类思路》](http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/)，写得很详细考虑得也很全，我的思路也类似这样，不过在替换旧模块上有些不同，总结出来权当抛砖引玉。\n\n为了方便说明，部分代码有省略细节，详细可以参见[完整代码](https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js)\n\n## 需求\n\n我的最开始需求倒不是要实现热更新这样听起来很炫酷的功能，只是想动态更新配置文件（JSON或JS）的内容到内存，避免每次改小小的配置都要重启进程\n\n## 基本思路\n* 监视文件/目录改动\n* 清空require.cache中的模块缓存并重新require\n* 用新模块覆盖旧模块\n\n## 监视文件/目录改动\n\n### 定位\n首先使用`path.resolve`来定位文件，其实使用`require.resolve`可以根据[node寻找模块的规则](https://nodejs.org/api/modules.html#modules_file_modules)更智能地定位到一个模块的入口文件（比如xxx/index.js）的，但更多情况下我们并不只是监视这个index.js而是想监视整个文件夹的改动（举个例子，index.js里require了同目录的xx.json并做了一系列计算最后把计算结果挂载`module.exports`上，这个时候单单监视index.js是没什么用的。）\n\n### 监视/防抖动\n原本是简单地使用`fs.watch`来监视文件，但其在linux下是无法监视到子目录/文件的改动的（参见[node文档](https://nodejs.org/api/fs.html#fs_caveats)），因此后来改用了被众多知名工具依赖的文件监视模块[chokidar](https://github.com/paulmillr/chokidar)，并且出于实际情况增加了防抖动\n```javascript\nchokidar.watch(filePath).on('all', lodash.debounce(update, 300));\n```\n\n## 清空require.cache中的模块缓存并重新require\n\n### 清空缓存\n考虑到监视的有可能是一个目录而非单个文件的情况，我们需要在清除时多考虑一下，把整个目录的引用都清除掉\n```javascript\nObject.keys(require.cache).forEach(function (cachePath) {\n  if (cachePath.startsWith(filePath)) {\n    delete require.cache[cachePath];\n  }\n});\n```\n\n### 重新require\n```javascript\nvar newModule = require(filePath);\n```\n这个时候可能会报一些找不到文件，代码语法错误之类的同步错误，这个属于预期范围内，我的处理逻辑如下：\n* 第一次require是同步的，这时的错误会同步抛出，一般来说就会结束进程，因为确实没找到文件\n* 监视事件触发并重新require时产生的错误会丢给回调函数，并且保持原模块的内容不做更改（避免意外修改文件产生语法错误导致模块失效或进程退出）\n\n## 用新模块覆盖旧模块\n如果我们在使用模块时能够遵守一个约定：**`module.exports`是Object，且其他模块永远从该模块所暴露的`module.exports`上取值**，那么我们就不需要去做反射，闭包之类的处理，只要简单地使用\n```javascript\nObject.assign(target,newMoudle)\n```\n就可以在保持该对象的引用不变的情况下增改属性，考虑到有删除属性的情况，我自己写了一段比较暴力的覆写的函数\n```javascript\nfunction override(target, source) {\n  Object.keys(target).forEach(function (key) {\n    if (!source.hasOwnProperty(key)) delete target[key];\n  });\n  Object.keys(source).forEach(function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\n```\n外部模块只要是遵守了上述约定，就可以完全透明地取得最新的属性内容，对于我主要的应用场景——动态读取配置文件来说，这个还是很容易遵守的\n\n## 使用方式\n只有一个模块引用的话，直接调用即可\n```javascript\nconst some = watchModule('./originModule');\n//从module.exports上取得的一定是最新值\nconsole.log(some.a);\n```\n当有多处需要引用时，建议使用一个代理的模块来挂载，这样在其他模块就可以直接用普通的require了（注意不要对一个模块多次调用watchModule，这样会产生重复事件）\n```javascript\n//originModule\nmodule.exports={a:1}; \n\n//代理模块\nmodule.exports = watchModule('./originModule');\n\n//其他模块\nconst some = require('proxyModule');\n\n//从module.exports上取得的一定是最新值\nconsole.log(some.a);\n```\n具体到上面文章提到的express动态挂载路由，`app.use`需要的是一个函数，因此我们无能为力——原函数已经被`app.use`挂载到中间件链上了，这种情况还是考虑使用一层闭包吧\n\n## 总结\n思路都是类似的，只是我多加了一个约定，只要遵守这个约定我们就可以写出一个比较通用的监视模块，当然这也并不是万能的，比如module.exports必须是Object（其他类型可以用Object多包裹一层），很多极限条件也没考虑到（比如Proxy、不可变Object、原型链、不可枚举的属性等），但对于普通的业务代码和配置文件来说这应该是没有什么问题了  \n\n另外提醒一点，允许动态更新代码是**非常危险**的，比如我提到的这种允许读js作为配置文件的情况，万一js里来句`process.exit`或者其他恶意代码就挂了，可以根据实际需要来考虑加上限制\n\n[完整代码](https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js)，欢迎讨论指正。\n\n## 补充：旧模块资源的释放\n阅读了上面的文章后才发现确实没考虑到这里，并且由于配置文件并不是频繁改动，在正式环境下也没出现过问题，但测试过后确实存在旧模块没有释放的情况（考虑还是不周啊），我们可以参考上面文章中fangshi给出的代码来清除引用\n```javascript\n    var module = require.cache[modulePath];\n    // remove reference in module.parent\n    if (module.parent) {\n        module.parent.children.splice(module.parent.children.indexOf(module), 1);\n    }\n```\n","slug":"Node监视文件以实现热更新","published":1,"updated":"2017-05-16T09:55:31.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va0d0014i8u0y1o6s2h9","content":"<p>在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的<a href=\"http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/\" target=\"_blank\" rel=\"external\">《Node.js Web应用代码热更新的另类思路》</a>，写得很详细考虑得也很全，我的思路也类似这样，不过在替换旧模块上有些不同，总结出来权当抛砖引玉。</p>\n<p>为了方便说明，部分代码有省略细节，详细可以参见<a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js\" target=\"_blank\" rel=\"external\">完整代码</a></p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>我的最开始需求倒不是要实现热更新这样听起来很炫酷的功能，只是想动态更新配置文件（JSON或JS）的内容到内存，避免每次改小小的配置都要重启进程</p>\n<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><ul>\n<li>监视文件/目录改动</li>\n<li>清空require.cache中的模块缓存并重新require</li>\n<li>用新模块覆盖旧模块</li>\n</ul>\n<h2 id=\"监视文件-目录改动\"><a href=\"#监视文件-目录改动\" class=\"headerlink\" title=\"监视文件/目录改动\"></a>监视文件/目录改动</h2><h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>首先使用<code>path.resolve</code>来定位文件，其实使用<code>require.resolve</code>可以根据<a href=\"https://nodejs.org/api/modules.html#modules_file_modules\" target=\"_blank\" rel=\"external\">node寻找模块的规则</a>更智能地定位到一个模块的入口文件（比如xxx/index.js）的，但更多情况下我们并不只是监视这个index.js而是想监视整个文件夹的改动（举个例子，index.js里require了同目录的xx.json并做了一系列计算最后把计算结果挂载<code>module.exports</code>上，这个时候单单监视index.js是没什么用的。）</p>\n<h3 id=\"监视-防抖动\"><a href=\"#监视-防抖动\" class=\"headerlink\" title=\"监视/防抖动\"></a>监视/防抖动</h3><p>原本是简单地使用<code>fs.watch</code>来监视文件，但其在linux下是无法监视到子目录/文件的改动的（参见<a href=\"https://nodejs.org/api/fs.html#fs_caveats\" target=\"_blank\" rel=\"external\">node文档</a>），因此后来改用了被众多知名工具依赖的文件监视模块<a href=\"https://github.com/paulmillr/chokidar\" target=\"_blank\" rel=\"external\">chokidar</a>，并且出于实际情况增加了防抖动<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chokidar.watch(filePath).on(<span class=\"string\">'all'</span>, lodash.debounce(update, <span class=\"number\">300</span>));</div></pre></td></tr></table></figure></p>\n<h2 id=\"清空require-cache中的模块缓存并重新require\"><a href=\"#清空require-cache中的模块缓存并重新require\" class=\"headerlink\" title=\"清空require.cache中的模块缓存并重新require\"></a>清空require.cache中的模块缓存并重新require</h2><h3 id=\"清空缓存\"><a href=\"#清空缓存\" class=\"headerlink\" title=\"清空缓存\"></a>清空缓存</h3><p>考虑到监视的有可能是一个目录而非单个文件的情况，我们需要在清除时多考虑一下，把整个目录的引用都清除掉<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">require</span>.cache).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cachePath</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (cachePath.startsWith(filePath)) &#123;</div><div class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">require</span>.cache[cachePath];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"重新require\"><a href=\"#重新require\" class=\"headerlink\" title=\"重新require\"></a>重新require</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> newModule = <span class=\"built_in\">require</span>(filePath);</div></pre></td></tr></table></figure>\n<p>这个时候可能会报一些找不到文件，代码语法错误之类的同步错误，这个属于预期范围内，我的处理逻辑如下：</p>\n<ul>\n<li>第一次require是同步的，这时的错误会同步抛出，一般来说就会结束进程，因为确实没找到文件</li>\n<li>监视事件触发并重新require时产生的错误会丢给回调函数，并且保持原模块的内容不做更改（避免意外修改文件产生语法错误导致模块失效或进程退出）</li>\n</ul>\n<h2 id=\"用新模块覆盖旧模块\"><a href=\"#用新模块覆盖旧模块\" class=\"headerlink\" title=\"用新模块覆盖旧模块\"></a>用新模块覆盖旧模块</h2><p>如果我们在使用模块时能够遵守一个约定：<strong><code>module.exports</code>是Object，且其他模块永远从该模块所暴露的<code>module.exports</code>上取值</strong>，那么我们就不需要去做反射，闭包之类的处理，只要简单地使用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.assign(target,newMoudle)</div></pre></td></tr></table></figure></p>\n<p>就可以在保持该对象的引用不变的情况下增改属性，考虑到有删除属性的情况，我自己写了一段比较暴力的覆写的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">override</span>(<span class=\"params\">target, source</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(target).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!source.hasOwnProperty(key)) <span class=\"keyword\">delete</span> target[key];</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(source).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">    target[key] = source[key];</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"keyword\">return</span> target;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>外部模块只要是遵守了上述约定，就可以完全透明地取得最新的属性内容，对于我主要的应用场景——动态读取配置文件来说，这个还是很容易遵守的</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><p>只有一个模块引用的话，直接调用即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> some = watchModule(<span class=\"string\">'./originModule'</span>);</div><div class=\"line\"><span class=\"comment\">//从module.exports上取得的一定是最新值</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(some.a);</div></pre></td></tr></table></figure></p>\n<p>当有多处需要引用时，建议使用一个代理的模块来挂载，这样在其他模块就可以直接用普通的require了（注意不要对一个模块多次调用watchModule，这样会产生重复事件）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//originModule</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//代理模块</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = watchModule(<span class=\"string\">'./originModule'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//其他模块</span></div><div class=\"line\"><span class=\"keyword\">const</span> some = <span class=\"built_in\">require</span>(<span class=\"string\">'proxyModule'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//从module.exports上取得的一定是最新值</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(some.a);</div></pre></td></tr></table></figure></p>\n<p>具体到上面文章提到的express动态挂载路由，<code>app.use</code>需要的是一个函数，因此我们无能为力——原函数已经被<code>app.use</code>挂载到中间件链上了，这种情况还是考虑使用一层闭包吧</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>思路都是类似的，只是我多加了一个约定，只要遵守这个约定我们就可以写出一个比较通用的监视模块，当然这也并不是万能的，比如module.exports必须是Object（其他类型可以用Object多包裹一层），很多极限条件也没考虑到（比如Proxy、不可变Object、原型链、不可枚举的属性等），但对于普通的业务代码和配置文件来说这应该是没有什么问题了  </p>\n<p>另外提醒一点，允许动态更新代码是<strong>非常危险</strong>的，比如我提到的这种允许读js作为配置文件的情况，万一js里来句<code>process.exit</code>或者其他恶意代码就挂了，可以根据实际需要来考虑加上限制</p>\n<p><a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js\" target=\"_blank\" rel=\"external\">完整代码</a>，欢迎讨论指正。</p>\n<h2 id=\"补充：旧模块资源的释放\"><a href=\"#补充：旧模块资源的释放\" class=\"headerlink\" title=\"补充：旧模块资源的释放\"></a>补充：旧模块资源的释放</h2><p>阅读了上面的文章后才发现确实没考虑到这里，并且由于配置文件并不是频繁改动，在正式环境下也没出现过问题，但测试过后确实存在旧模块没有释放的情况（考虑还是不周啊），我们可以参考上面文章中fangshi给出的代码来清除引用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = <span class=\"built_in\">require</span>.cache[modulePath];</div><div class=\"line\"><span class=\"comment\">// remove reference in module.parent</span></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.parent) &#123;</div><div class=\"line\">    <span class=\"built_in\">module</span>.parent.children.splice(<span class=\"built_in\">module</span>.parent.children.indexOf(<span class=\"built_in\">module</span>), <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的<a href=\"http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/\">《Node.js Web应用代码热更新的另类思路》</a>，写得很详细考虑得也很全，我的思路也类似这样，不过在替换旧模块上有些不同，总结出来权当抛砖引玉。</p>\n<p>为了方便说明，部分代码有省略细节，详细可以参见<a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js\">完整代码</a></p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>我的最开始需求倒不是要实现热更新这样听起来很炫酷的功能，只是想动态更新配置文件（JSON或JS）的内容到内存，避免每次改小小的配置都要重启进程</p>\n<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><ul>\n<li>监视文件/目录改动</li>\n<li>清空require.cache中的模块缓存并重新require</li>\n<li>用新模块覆盖旧模块</li>\n</ul>\n<h2 id=\"监视文件-目录改动\"><a href=\"#监视文件-目录改动\" class=\"headerlink\" title=\"监视文件/目录改动\"></a>监视文件/目录改动</h2><h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>首先使用<code>path.resolve</code>来定位文件，其实使用<code>require.resolve</code>可以根据<a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">node寻找模块的规则</a>更智能地定位到一个模块的入口文件（比如xxx/index.js）的，但更多情况下我们并不只是监视这个index.js而是想监视整个文件夹的改动（举个例子，index.js里require了同目录的xx.json并做了一系列计算最后把计算结果挂载<code>module.exports</code>上，这个时候单单监视index.js是没什么用的。）</p>\n<h3 id=\"监视-防抖动\"><a href=\"#监视-防抖动\" class=\"headerlink\" title=\"监视/防抖动\"></a>监视/防抖动</h3><p>原本是简单地使用<code>fs.watch</code>来监视文件，但其在linux下是无法监视到子目录/文件的改动的（参见<a href=\"https://nodejs.org/api/fs.html#fs_caveats\">node文档</a>），因此后来改用了被众多知名工具依赖的文件监视模块<a href=\"https://github.com/paulmillr/chokidar\">chokidar</a>，并且出于实际情况增加了防抖动<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chokidar.watch(filePath).on(<span class=\"string\">'all'</span>, lodash.debounce(update, <span class=\"number\">300</span>));</div></pre></td></tr></table></figure></p>\n<h2 id=\"清空require-cache中的模块缓存并重新require\"><a href=\"#清空require-cache中的模块缓存并重新require\" class=\"headerlink\" title=\"清空require.cache中的模块缓存并重新require\"></a>清空require.cache中的模块缓存并重新require</h2><h3 id=\"清空缓存\"><a href=\"#清空缓存\" class=\"headerlink\" title=\"清空缓存\"></a>清空缓存</h3><p>考虑到监视的有可能是一个目录而非单个文件的情况，我们需要在清除时多考虑一下，把整个目录的引用都清除掉<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">require</span>.cache).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cachePath</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (cachePath.startsWith(filePath)) &#123;</div><div class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">require</span>.cache[cachePath];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"重新require\"><a href=\"#重新require\" class=\"headerlink\" title=\"重新require\"></a>重新require</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> newModule = <span class=\"built_in\">require</span>(filePath);</div></pre></td></tr></table></figure>\n<p>这个时候可能会报一些找不到文件，代码语法错误之类的同步错误，这个属于预期范围内，我的处理逻辑如下：</p>\n<ul>\n<li>第一次require是同步的，这时的错误会同步抛出，一般来说就会结束进程，因为确实没找到文件</li>\n<li>监视事件触发并重新require时产生的错误会丢给回调函数，并且保持原模块的内容不做更改（避免意外修改文件产生语法错误导致模块失效或进程退出）</li>\n</ul>\n<h2 id=\"用新模块覆盖旧模块\"><a href=\"#用新模块覆盖旧模块\" class=\"headerlink\" title=\"用新模块覆盖旧模块\"></a>用新模块覆盖旧模块</h2><p>如果我们在使用模块时能够遵守一个约定：<strong><code>module.exports</code>是Object，且其他模块永远从该模块所暴露的<code>module.exports</code>上取值</strong>，那么我们就不需要去做反射，闭包之类的处理，只要简单地使用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.assign(target,newMoudle)</div></pre></td></tr></table></figure></p>\n<p>就可以在保持该对象的引用不变的情况下增改属性，考虑到有删除属性的情况，我自己写了一段比较暴力的覆写的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">override</span>(<span class=\"params\">target, source</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(target).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!source.hasOwnProperty(key)) <span class=\"keyword\">delete</span> target[key];</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(source).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">    target[key] = source[key];</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"keyword\">return</span> target;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>外部模块只要是遵守了上述约定，就可以完全透明地取得最新的属性内容，对于我主要的应用场景——动态读取配置文件来说，这个还是很容易遵守的</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><p>只有一个模块引用的话，直接调用即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> some = watchModule(<span class=\"string\">'./originModule'</span>);</div><div class=\"line\"><span class=\"comment\">//从module.exports上取得的一定是最新值</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(some.a);</div></pre></td></tr></table></figure></p>\n<p>当有多处需要引用时，建议使用一个代理的模块来挂载，这样在其他模块就可以直接用普通的require了（注意不要对一个模块多次调用watchModule，这样会产生重复事件）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//originModule</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//代理模块</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = watchModule(<span class=\"string\">'./originModule'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//其他模块</span></div><div class=\"line\"><span class=\"keyword\">const</span> some = <span class=\"built_in\">require</span>(<span class=\"string\">'proxyModule'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//从module.exports上取得的一定是最新值</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(some.a);</div></pre></td></tr></table></figure></p>\n<p>具体到上面文章提到的express动态挂载路由，<code>app.use</code>需要的是一个函数，因此我们无能为力——原函数已经被<code>app.use</code>挂载到中间件链上了，这种情况还是考虑使用一层闭包吧</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>思路都是类似的，只是我多加了一个约定，只要遵守这个约定我们就可以写出一个比较通用的监视模块，当然这也并不是万能的，比如module.exports必须是Object（其他类型可以用Object多包裹一层），很多极限条件也没考虑到（比如Proxy、不可变Object、原型链、不可枚举的属性等），但对于普通的业务代码和配置文件来说这应该是没有什么问题了  </p>\n<p>另外提醒一点，允许动态更新代码是<strong>非常危险</strong>的，比如我提到的这种允许读js作为配置文件的情况，万一js里来句<code>process.exit</code>或者其他恶意代码就挂了，可以根据实际需要来考虑加上限制</p>\n<p><a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js\">完整代码</a>，欢迎讨论指正。</p>\n<h2 id=\"补充：旧模块资源的释放\"><a href=\"#补充：旧模块资源的释放\" class=\"headerlink\" title=\"补充：旧模块资源的释放\"></a>补充：旧模块资源的释放</h2><p>阅读了上面的文章后才发现确实没考虑到这里，并且由于配置文件并不是频繁改动，在正式环境下也没出现过问题，但测试过后确实存在旧模块没有释放的情况（考虑还是不周啊），我们可以参考上面文章中fangshi给出的代码来清除引用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = <span class=\"built_in\">require</span>.cache[modulePath];</div><div class=\"line\"><span class=\"comment\">// remove reference in module.parent</span></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.parent) &#123;</div><div class=\"line\">    <span class=\"built_in\">module</span>.parent.children.splice(<span class=\"built_in\">module</span>.parent.children.indexOf(<span class=\"built_in\">module</span>), <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"使用socket.io在页面上输出实时日志","desc":"类似webshell的小玩具","author":"ngtmuzi","date":"2017-04-19T12:02:57.000Z","_content":"### 需求\n\n想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会比较有用\n\n### 思路\n\n#### 来\n\n使用`tail -f`来得到实时的文件流或者用`pm2 logs`获取pm2进程的输出流，考虑为每个流加上一个`订阅id`，这样就可以实现多端同时订阅了\n\n#### 去\n\n在web页面上说到实时，自然就想到用`websocket`啦，逻辑并不复杂，客户端传来一个`订阅id`，就把它与id对应的流的`data`事件挂钩起来，这样便能将数据传递过去\n\n### 核心代码\n\n本文主要是给出一些实践的思路，所以不会有`socket.io`工作原理的说明\n\n#### 产生流\n\n使用`child_process.exec`运行子进程，该函数所返回的`stdout`属性就是一个可读流：\n\n```javascript\nconst exec = require('child_process').exec;\n//存储所有stream的集合\nconst streams = {};\n\n/**\n * 用tail -f读文件\n * @param file\n * @return id\n */\nfunction watchFile(file) {\n  return watchProcess(`tail -f ${file}`);\n}\n\n/**\n * 自定义的命令行，比如pm2 logs 0\n * @param cmd\n * @return id\n */\nfunction watchProcess(cmd) {\n  return watchStream(exec(cmd).stdout);\n}\n\n/**\n * 对流做一些额外处理\n * @param stream\n * @return id\n */\nfunction watchStream(stream) {\n  const id     = Date.now();\n  streams[id]  = stream;\n  stream._buff = '';\n\n  //处理流的data事件，使其按行(\\n结尾)来触发自定义的line事件\n  stream.on('data', data => {\n    stream._buff += data;\n    let lines    = stream._buff.split('\\n');\n    stream._buff = lines.pop();\n    lines.forEach(line => stream.emit('line', line));\n  });\n}\n```\n\n#### 将流与socket.io订阅绑定\n```javascript\n  const io = SocketIO(httpServer);\n\n  io.on('connection', function (socket) {\n    socket.on('sub', function (id) {\n      if (!streams[id]) return socket.emit('line', `该订阅id不存在: ${id}`);\n\n      //管道函数，收到流的line事件则将控制台的ansi格式内容转成html格式然后触发客户端的line事件\n      const pipe = line => socket.emit('line', ansiHTML(line));\n\n      //订阅流的line事件\n      streams[id].on('line', pipe);\n    });\n  });\n```\n\n#### 前端订阅id\n```javascript\n  var socket = io.connect();\n  socket.on('line', function (data) {\n    app.rawLines.push(data);\n    if (app.rawLines.length > 2000) app.rawLines.splice(0, app.rawLines.length - 2000); //行数上限设为2000\n  });\n\n  socket.on('connect', function () {\n    console.log('connect succeed');\n\n    socket.emit('sub', 'time');//根据各种业务逻辑拿到一个订阅id并订阅\n  });\n```\n\n前端页面为了方便渲染非常多行的元素，使用的是vue，代码就不贴了，最终效果如下\n\n![](https://i2.muimg.com/1949/c9d8ce0256097837.jpg)\n\n### 总结\n\n这个东西功能接近于webshell了，最起码输出是可以显示了，再加个输入的接口就可以远程执行命令了，这里要提醒下允许远程执行命令是 **非常危险** 的。\n\n主要的是思路，代码本身并不难，[demo已上传github](https://github.com/ngtmuzi/webshell-demo)，由于是demo，各种错误捕获和回收处理都不完善，这个还请自己研究了~\n\n### 2017-06-14补充\n\n监听逐行输出可以直接使用Node自带的`readline`模块，示例代码已更新","source":"_posts/使用socket-io在页面上输出实时日志.md","raw":"---\ntitle: 使用socket.io在页面上输出实时日志    \ndesc: 类似webshell的小玩具  \nauthor: ngtmuzi  \ncategory: 班门弄斧  \ndate: 2017-04-19 20:02:57  \ntags: \n- node.js\n- socket.io\n\n---\n### 需求\n\n想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会比较有用\n\n### 思路\n\n#### 来\n\n使用`tail -f`来得到实时的文件流或者用`pm2 logs`获取pm2进程的输出流，考虑为每个流加上一个`订阅id`，这样就可以实现多端同时订阅了\n\n#### 去\n\n在web页面上说到实时，自然就想到用`websocket`啦，逻辑并不复杂，客户端传来一个`订阅id`，就把它与id对应的流的`data`事件挂钩起来，这样便能将数据传递过去\n\n### 核心代码\n\n本文主要是给出一些实践的思路，所以不会有`socket.io`工作原理的说明\n\n#### 产生流\n\n使用`child_process.exec`运行子进程，该函数所返回的`stdout`属性就是一个可读流：\n\n```javascript\nconst exec = require('child_process').exec;\n//存储所有stream的集合\nconst streams = {};\n\n/**\n * 用tail -f读文件\n * @param file\n * @return id\n */\nfunction watchFile(file) {\n  return watchProcess(`tail -f ${file}`);\n}\n\n/**\n * 自定义的命令行，比如pm2 logs 0\n * @param cmd\n * @return id\n */\nfunction watchProcess(cmd) {\n  return watchStream(exec(cmd).stdout);\n}\n\n/**\n * 对流做一些额外处理\n * @param stream\n * @return id\n */\nfunction watchStream(stream) {\n  const id     = Date.now();\n  streams[id]  = stream;\n  stream._buff = '';\n\n  //处理流的data事件，使其按行(\\n结尾)来触发自定义的line事件\n  stream.on('data', data => {\n    stream._buff += data;\n    let lines    = stream._buff.split('\\n');\n    stream._buff = lines.pop();\n    lines.forEach(line => stream.emit('line', line));\n  });\n}\n```\n\n#### 将流与socket.io订阅绑定\n```javascript\n  const io = SocketIO(httpServer);\n\n  io.on('connection', function (socket) {\n    socket.on('sub', function (id) {\n      if (!streams[id]) return socket.emit('line', `该订阅id不存在: ${id}`);\n\n      //管道函数，收到流的line事件则将控制台的ansi格式内容转成html格式然后触发客户端的line事件\n      const pipe = line => socket.emit('line', ansiHTML(line));\n\n      //订阅流的line事件\n      streams[id].on('line', pipe);\n    });\n  });\n```\n\n#### 前端订阅id\n```javascript\n  var socket = io.connect();\n  socket.on('line', function (data) {\n    app.rawLines.push(data);\n    if (app.rawLines.length > 2000) app.rawLines.splice(0, app.rawLines.length - 2000); //行数上限设为2000\n  });\n\n  socket.on('connect', function () {\n    console.log('connect succeed');\n\n    socket.emit('sub', 'time');//根据各种业务逻辑拿到一个订阅id并订阅\n  });\n```\n\n前端页面为了方便渲染非常多行的元素，使用的是vue，代码就不贴了，最终效果如下\n\n![](https://i2.muimg.com/1949/c9d8ce0256097837.jpg)\n\n### 总结\n\n这个东西功能接近于webshell了，最起码输出是可以显示了，再加个输入的接口就可以远程执行命令了，这里要提醒下允许远程执行命令是 **非常危险** 的。\n\n主要的是思路，代码本身并不难，[demo已上传github](https://github.com/ngtmuzi/webshell-demo)，由于是demo，各种错误捕获和回收处理都不完善，这个还请自己研究了~\n\n### 2017-06-14补充\n\n监听逐行输出可以直接使用Node自带的`readline`模块，示例代码已更新","slug":"使用socket-io在页面上输出实时日志","published":1,"updated":"2017-06-14T08:55:41.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va0j0017i8u0gzcme896","content":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会比较有用</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"来\"><a href=\"#来\" class=\"headerlink\" title=\"来\"></a>来</h4><p>使用<code>tail -f</code>来得到实时的文件流或者用<code>pm2 logs</code>获取pm2进程的输出流，考虑为每个流加上一个<code>订阅id</code>，这样就可以实现多端同时订阅了</p>\n<h4 id=\"去\"><a href=\"#去\" class=\"headerlink\" title=\"去\"></a>去</h4><p>在web页面上说到实时，自然就想到用<code>websocket</code>啦，逻辑并不复杂，客户端传来一个<code>订阅id</code>，就把它与id对应的流的<code>data</code>事件挂钩起来，这样便能将数据传递过去</p>\n<h3 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h3><p>本文主要是给出一些实践的思路，所以不会有<code>socket.io</code>工作原理的说明</p>\n<h4 id=\"产生流\"><a href=\"#产生流\" class=\"headerlink\" title=\"产生流\"></a>产生流</h4><p>使用<code>child_process.exec</code>运行子进程，该函数所返回的<code>stdout</code>属性就是一个可读流：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>).exec;</div><div class=\"line\"><span class=\"comment\">//存储所有stream的集合</span></div><div class=\"line\"><span class=\"keyword\">const</span> streams = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 用tail -f读文件</div><div class=\"line\"> * @param file</div><div class=\"line\"> * @return id</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchFile</span>(<span class=\"params\">file</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> watchProcess(<span class=\"string\">`tail -f <span class=\"subst\">$&#123;file&#125;</span>`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 自定义的命令行，比如pm2 logs 0</div><div class=\"line\"> * @param cmd</div><div class=\"line\"> * @return id</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchProcess</span>(<span class=\"params\">cmd</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> watchStream(exec(cmd).stdout);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对流做一些额外处理</div><div class=\"line\"> * @param stream</div><div class=\"line\"> * @return id</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchStream</span>(<span class=\"params\">stream</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> id     = <span class=\"built_in\">Date</span>.now();</div><div class=\"line\">  streams[id]  = stream;</div><div class=\"line\">  stream._buff = <span class=\"string\">''</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//处理流的data事件，使其按行(\\n结尾)来触发自定义的line事件</span></div><div class=\"line\">  stream.on(<span class=\"string\">'data'</span>, data =&gt; &#123;</div><div class=\"line\">    stream._buff += data;</div><div class=\"line\">    <span class=\"keyword\">let</span> lines    = stream._buff.split(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    stream._buff = lines.pop();</div><div class=\"line\">    lines.forEach(<span class=\"function\"><span class=\"params\">line</span> =&gt;</span> stream.emit(<span class=\"string\">'line'</span>, line));</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"将流与socket-io订阅绑定\"><a href=\"#将流与socket-io订阅绑定\" class=\"headerlink\" title=\"将流与socket.io订阅绑定\"></a>将流与socket.io订阅绑定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> io = SocketIO(httpServer);</div><div class=\"line\"></div><div class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</div><div class=\"line\">  socket.on(<span class=\"string\">'sub'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!streams[id]) <span class=\"keyword\">return</span> socket.emit(<span class=\"string\">'line'</span>, <span class=\"string\">`该订阅id不存在: <span class=\"subst\">$&#123;id&#125;</span>`</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//管道函数，收到流的line事件则将控制台的ansi格式内容转成html格式然后触发客户端的line事件</span></div><div class=\"line\">    <span class=\"keyword\">const</span> pipe = <span class=\"function\"><span class=\"params\">line</span> =&gt;</span> socket.emit(<span class=\"string\">'line'</span>, ansiHTML(line));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//订阅流的line事件</span></div><div class=\"line\">    streams[id].on(<span class=\"string\">'line'</span>, pipe);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"前端订阅id\"><a href=\"#前端订阅id\" class=\"headerlink\" title=\"前端订阅id\"></a>前端订阅id</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> socket = io.connect();</div><div class=\"line\">socket.on(<span class=\"string\">'line'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  app.rawLines.push(data);</div><div class=\"line\">  <span class=\"keyword\">if</span> (app.rawLines.length &gt; <span class=\"number\">2000</span>) app.rawLines.splice(<span class=\"number\">0</span>, app.rawLines.length - <span class=\"number\">2000</span>); <span class=\"comment\">//行数上限设为2000</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'connect succeed'</span>);</div><div class=\"line\"></div><div class=\"line\">  socket.emit(<span class=\"string\">'sub'</span>, <span class=\"string\">'time'</span>);<span class=\"comment\">//根据各种业务逻辑拿到一个订阅id并订阅</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>前端页面为了方便渲染非常多行的元素，使用的是vue，代码就不贴了，最终效果如下</p>\n<p><img src=\"https://i2.muimg.com/1949/c9d8ce0256097837.jpg\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这个东西功能接近于webshell了，最起码输出是可以显示了，再加个输入的接口就可以远程执行命令了，这里要提醒下允许远程执行命令是 <strong>非常危险</strong> 的。</p>\n<p>主要的是思路，代码本身并不难，<a href=\"https://github.com/ngtmuzi/webshell-demo\" target=\"_blank\" rel=\"external\">demo已上传github</a>，由于是demo，各种错误捕获和回收处理都不完善，这个还请自己研究了~</p>\n<h3 id=\"2017-06-14补充\"><a href=\"#2017-06-14补充\" class=\"headerlink\" title=\"2017-06-14补充\"></a>2017-06-14补充</h3><p>监听逐行输出可以直接使用Node自带的<code>readline</code>模块，示例代码已更新</p>\n","excerpt":"","more":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会比较有用</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"来\"><a href=\"#来\" class=\"headerlink\" title=\"来\"></a>来</h4><p>使用<code>tail -f</code>来得到实时的文件流或者用<code>pm2 logs</code>获取pm2进程的输出流，考虑为每个流加上一个<code>订阅id</code>，这样就可以实现多端同时订阅了</p>\n<h4 id=\"去\"><a href=\"#去\" class=\"headerlink\" title=\"去\"></a>去</h4><p>在web页面上说到实时，自然就想到用<code>websocket</code>啦，逻辑并不复杂，客户端传来一个<code>订阅id</code>，就把它与id对应的流的<code>data</code>事件挂钩起来，这样便能将数据传递过去</p>\n<h3 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h3><p>本文主要是给出一些实践的思路，所以不会有<code>socket.io</code>工作原理的说明</p>\n<h4 id=\"产生流\"><a href=\"#产生流\" class=\"headerlink\" title=\"产生流\"></a>产生流</h4><p>使用<code>child_process.exec</code>运行子进程，该函数所返回的<code>stdout</code>属性就是一个可读流：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>).exec;</div><div class=\"line\"><span class=\"comment\">//存储所有stream的集合</span></div><div class=\"line\"><span class=\"keyword\">const</span> streams = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 用tail -f读文件</div><div class=\"line\"> * @param file</div><div class=\"line\"> * @return id</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchFile</span>(<span class=\"params\">file</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> watchProcess(<span class=\"string\">`tail -f <span class=\"subst\">$&#123;file&#125;</span>`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 自定义的命令行，比如pm2 logs 0</div><div class=\"line\"> * @param cmd</div><div class=\"line\"> * @return id</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchProcess</span>(<span class=\"params\">cmd</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> watchStream(exec(cmd).stdout);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 对流做一些额外处理</div><div class=\"line\"> * @param stream</div><div class=\"line\"> * @return id</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchStream</span>(<span class=\"params\">stream</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> id     = <span class=\"built_in\">Date</span>.now();</div><div class=\"line\">  streams[id]  = stream;</div><div class=\"line\">  stream._buff = <span class=\"string\">''</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//处理流的data事件，使其按行(\\n结尾)来触发自定义的line事件</span></div><div class=\"line\">  stream.on(<span class=\"string\">'data'</span>, data =&gt; &#123;</div><div class=\"line\">    stream._buff += data;</div><div class=\"line\">    <span class=\"keyword\">let</span> lines    = stream._buff.split(<span class=\"string\">'\\n'</span>);</div><div class=\"line\">    stream._buff = lines.pop();</div><div class=\"line\">    lines.forEach(<span class=\"function\"><span class=\"params\">line</span> =&gt;</span> stream.emit(<span class=\"string\">'line'</span>, line));</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"将流与socket-io订阅绑定\"><a href=\"#将流与socket-io订阅绑定\" class=\"headerlink\" title=\"将流与socket.io订阅绑定\"></a>将流与socket.io订阅绑定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> io = SocketIO(httpServer);</div><div class=\"line\"></div><div class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</div><div class=\"line\">  socket.on(<span class=\"string\">'sub'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!streams[id]) <span class=\"keyword\">return</span> socket.emit(<span class=\"string\">'line'</span>, <span class=\"string\">`该订阅id不存在: <span class=\"subst\">$&#123;id&#125;</span>`</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//管道函数，收到流的line事件则将控制台的ansi格式内容转成html格式然后触发客户端的line事件</span></div><div class=\"line\">    <span class=\"keyword\">const</span> pipe = <span class=\"function\"><span class=\"params\">line</span> =&gt;</span> socket.emit(<span class=\"string\">'line'</span>, ansiHTML(line));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//订阅流的line事件</span></div><div class=\"line\">    streams[id].on(<span class=\"string\">'line'</span>, pipe);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"前端订阅id\"><a href=\"#前端订阅id\" class=\"headerlink\" title=\"前端订阅id\"></a>前端订阅id</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> socket = io.connect();</div><div class=\"line\">socket.on(<span class=\"string\">'line'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  app.rawLines.push(data);</div><div class=\"line\">  <span class=\"keyword\">if</span> (app.rawLines.length &gt; <span class=\"number\">2000</span>) app.rawLines.splice(<span class=\"number\">0</span>, app.rawLines.length - <span class=\"number\">2000</span>); <span class=\"comment\">//行数上限设为2000</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'connect succeed'</span>);</div><div class=\"line\"></div><div class=\"line\">  socket.emit(<span class=\"string\">'sub'</span>, <span class=\"string\">'time'</span>);<span class=\"comment\">//根据各种业务逻辑拿到一个订阅id并订阅</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>前端页面为了方便渲染非常多行的元素，使用的是vue，代码就不贴了，最终效果如下</p>\n<p><img src=\"https://i2.muimg.com/1949/c9d8ce0256097837.jpg\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这个东西功能接近于webshell了，最起码输出是可以显示了，再加个输入的接口就可以远程执行命令了，这里要提醒下允许远程执行命令是 <strong>非常危险</strong> 的。</p>\n<p>主要的是思路，代码本身并不难，<a href=\"https://github.com/ngtmuzi/webshell-demo\">demo已上传github</a>，由于是demo，各种错误捕获和回收处理都不完善，这个还请自己研究了~</p>\n<h3 id=\"2017-06-14补充\"><a href=\"#2017-06-14补充\" class=\"headerlink\" title=\"2017-06-14补充\"></a>2017-06-14补充</h3><p>监听逐行输出可以直接使用Node自带的<code>readline</code>模块，示例代码已更新</p>\n"},{"title":"屏蔽参数中的敏感字段","desc":"难得能写些有趣的代码","author":"ngtmuzi","date":"2017-04-01T07:14:31.000Z","_content":"```javascript\nconst pwdFields = ['password','pwd'];\n\nfunction filterPwdField(obj) {\n  return lodash.mapValues(obj, (value, key) => {\n    if (lodash.isPlainObject(value))\n      return filterPwdField(value);\n\n    if (typeof  value === 'string') {\n      if (pwdFields.some(field => value.toLowerCase().includes(field.toLowerCase()))) { //屏蔽类似password=xxxxx的字符串\n        pwdFields.forEach(field =>\n          value = value.replace(new RegExp(`(${field})=(.+?)(&|$)`, 'gi'), (match, $1, $2, $3) =>\n            `${$1}=${$2.slice(0, -5) + '*****'}${$3 || ''}`\n          ));\n      }\n\n      if (pwdFields.some(field => key.toLowerCase().includes(field.toLowerCase())))\n        value = value.slice(0, -5) + '*****';  //密码字段做屏蔽\n    }\n    return value;\n  });\n}\n```","source":"_posts/屏蔽参数中的敏感字段.md","raw":"---\ntitle: 屏蔽参数中的敏感字段\ndesc: 难得能写些有趣的代码\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2017-04-01 15:14:31\ntags: javaScript\n---\n```javascript\nconst pwdFields = ['password','pwd'];\n\nfunction filterPwdField(obj) {\n  return lodash.mapValues(obj, (value, key) => {\n    if (lodash.isPlainObject(value))\n      return filterPwdField(value);\n\n    if (typeof  value === 'string') {\n      if (pwdFields.some(field => value.toLowerCase().includes(field.toLowerCase()))) { //屏蔽类似password=xxxxx的字符串\n        pwdFields.forEach(field =>\n          value = value.replace(new RegExp(`(${field})=(.+?)(&|$)`, 'gi'), (match, $1, $2, $3) =>\n            `${$1}=${$2.slice(0, -5) + '*****'}${$3 || ''}`\n          ));\n      }\n\n      if (pwdFields.some(field => key.toLowerCase().includes(field.toLowerCase())))\n        value = value.slice(0, -5) + '*****';  //密码字段做屏蔽\n    }\n    return value;\n  });\n}\n```","slug":"屏蔽参数中的敏感字段","published":1,"updated":"2017-04-01T07:22:32.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va1e002yi8u0q0i69sjk","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> pwdFields = [<span class=\"string\">'password'</span>,<span class=\"string\">'pwd'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterPwdField</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> lodash.mapValues(obj, (value, key) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (lodash.isPlainObject(value))</div><div class=\"line\">      <span class=\"keyword\">return</span> filterPwdField(value);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>  value === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (pwdFields.some(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span> value.toLowerCase().includes(field.toLowerCase()))) &#123; <span class=\"comment\">//屏蔽类似password=xxxxx的字符串</span></div><div class=\"line\">        pwdFields.forEach(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span></div><div class=\"line\">          value = value.replace(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`(<span class=\"subst\">$&#123;field&#125;</span>)=(.+?)(&amp;|$)`</span>, <span class=\"string\">'gi'</span>), (match, $<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span>) =&gt;</div><div class=\"line\">            <span class=\"string\">`<span class=\"subst\">$&#123;$<span class=\"number\">1</span>&#125;</span>=<span class=\"subst\">$&#123;$<span class=\"number\">2.</span>slice(<span class=\"number\">0</span>, <span class=\"number\">-5</span>) + <span class=\"string\">'*****'</span>&#125;</span><span class=\"subst\">$&#123;$<span class=\"number\">3</span> || <span class=\"string\">''</span>&#125;</span>`</span></div><div class=\"line\">          ));</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (pwdFields.some(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span> key.toLowerCase().includes(field.toLowerCase())))</div><div class=\"line\">        value = value.slice(<span class=\"number\">0</span>, <span class=\"number\">-5</span>) + <span class=\"string\">'*****'</span>;  <span class=\"comment\">//密码字段做屏蔽</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> pwdFields = [<span class=\"string\">'password'</span>,<span class=\"string\">'pwd'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterPwdField</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> lodash.mapValues(obj, (value, key) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (lodash.isPlainObject(value))</div><div class=\"line\">      <span class=\"keyword\">return</span> filterPwdField(value);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>  value === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (pwdFields.some(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span> value.toLowerCase().includes(field.toLowerCase()))) &#123; <span class=\"comment\">//屏蔽类似password=xxxxx的字符串</span></div><div class=\"line\">        pwdFields.forEach(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span></div><div class=\"line\">          value = value.replace(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`(<span class=\"subst\">$&#123;field&#125;</span>)=(.+?)(&amp;|$)`</span>, <span class=\"string\">'gi'</span>), (match, $<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span>) =&gt;</div><div class=\"line\">            <span class=\"string\">`<span class=\"subst\">$&#123;$<span class=\"number\">1</span>&#125;</span>=<span class=\"subst\">$&#123;$<span class=\"number\">2.</span>slice(<span class=\"number\">0</span>, <span class=\"number\">-5</span>) + <span class=\"string\">'*****'</span>&#125;</span><span class=\"subst\">$&#123;$<span class=\"number\">3</span> || <span class=\"string\">''</span>&#125;</span>`</span></div><div class=\"line\">          ));</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (pwdFields.some(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span> key.toLowerCase().includes(field.toLowerCase())))</div><div class=\"line\">        value = value.slice(<span class=\"number\">0</span>, <span class=\"number\">-5</span>) + <span class=\"string\">'*****'</span>;  <span class=\"comment\">//密码字段做屏蔽</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"解决vue无法捕获input变动的问题","desc":"手动触发Input事件就好了","author":"ngtmuzi","date":"2017-06-05T05:35:42.000Z","_content":"## 问题\n\n自己的页面使用了vue和一款jquery的时间选择插件`datepicker`，但选好时间后input框的变动并没有被vue捕获到\n\n## 参考资料\n\n> [Vue表单控件绑定](http://cn.vuejs.org/v2/guide/forms.html#基础用法)  \n> [Vue源码](https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090)  \n> [Jquery的val()方法说明](http://api.jquery.com/val/#val-value)  \n> [从vue.js的源码分析...](http://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html)  \n> [MDN: Event对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Event)\n\n## 分析\n\njquery的val方法文档写得很清楚：\n\n> Setting values using this method (or using the native value property) does not cause the dispatch of the change event.\n\n在类似使用`jquery`的`val()`方法时或者原生dom方法改动input的值时，不会触发任何事件。\n\n> [vue.js #L6090](https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090)\n ```javascript\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n```\n\n而vue是通过绑定事件（默认是`input`）来获知表单元素的变动的，因此这个问题就是因为插件直接用`.val()`设置了值，而vue无法获知。\n\n## 解决方案\n\n我们可以在改动值后手动触发`input`事件，注意这里我们需要使用DOM原生的`event`对象，而不能直接使用jquery的`.trigger()`方法\n```javascript\n//.get(0)返回DOM原生对象\n$('#input1').val('something').get(0).dispatchEvent(new Event('input'));\n```\n在我这个具体问题中，监听插件的自定义事件就可以了\n```javascript\n$(\".form_datetime\").datepicker()\n  .on('changeDate', function (e) {\n    //触发DOM对象上的原生input事件\n    this.dispatchEvent(new Event('input'))\n  });\n```\n注意如果input使用的修饰符带有`.lazy`则应该触发`change`事件\n\n当然最好的办法还是避免使用其他库来改动表单，改为使用基于vue的插件之类的，省心省力","source":"_posts/解决vue无法捕获input变动的问题.md","raw":"---\ntitle: 解决vue无法捕获input变动的问题\ndesc: 手动触发Input事件就好了\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2017-06-05 13:35:42\ntags:\n- vue\n- jquery\n- javascript\n---\n## 问题\n\n自己的页面使用了vue和一款jquery的时间选择插件`datepicker`，但选好时间后input框的变动并没有被vue捕获到\n\n## 参考资料\n\n> [Vue表单控件绑定](http://cn.vuejs.org/v2/guide/forms.html#基础用法)  \n> [Vue源码](https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090)  \n> [Jquery的val()方法说明](http://api.jquery.com/val/#val-value)  \n> [从vue.js的源码分析...](http://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html)  \n> [MDN: Event对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Event)\n\n## 分析\n\njquery的val方法文档写得很清楚：\n\n> Setting values using this method (or using the native value property) does not cause the dispatch of the change event.\n\n在类似使用`jquery`的`val()`方法时或者原生dom方法改动input的值时，不会触发任何事件。\n\n> [vue.js #L6090](https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090)\n ```javascript\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n```\n\n而vue是通过绑定事件（默认是`input`）来获知表单元素的变动的，因此这个问题就是因为插件直接用`.val()`设置了值，而vue无法获知。\n\n## 解决方案\n\n我们可以在改动值后手动触发`input`事件，注意这里我们需要使用DOM原生的`event`对象，而不能直接使用jquery的`.trigger()`方法\n```javascript\n//.get(0)返回DOM原生对象\n$('#input1').val('something').get(0).dispatchEvent(new Event('input'));\n```\n在我这个具体问题中，监听插件的自定义事件就可以了\n```javascript\n$(\".form_datetime\").datepicker()\n  .on('changeDate', function (e) {\n    //触发DOM对象上的原生input事件\n    this.dispatchEvent(new Event('input'))\n  });\n```\n注意如果input使用的修饰符带有`.lazy`则应该触发`change`事件\n\n当然最好的办法还是避免使用其他库来改动表单，改为使用基于vue的插件之类的，省心省力","slug":"解决vue无法捕获input变动的问题","published":1,"updated":"2017-06-08T03:07:47.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj481va1h002zi8u0brq4qfnc","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>自己的页面使用了vue和一款jquery的时间选择插件<code>datepicker</code>，但选好时间后input框的变动并没有被vue捕获到</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><blockquote>\n<p><a href=\"http://cn.vuejs.org/v2/guide/forms.html#基础用法\" target=\"_blank\" rel=\"external\">Vue表单控件绑定</a><br><a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090\" target=\"_blank\" rel=\"external\">Vue源码</a><br><a href=\"http://api.jquery.com/val/#val-value\" target=\"_blank\" rel=\"external\">Jquery的val()方法说明</a><br><a href=\"http://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html\" target=\"_blank\" rel=\"external\">从vue.js的源码分析…</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Event\" target=\"_blank\" rel=\"external\">MDN: Event对象</a></p>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>jquery的val方法文档写得很清楚：</p>\n<blockquote>\n<p>Setting values using this method (or using the native value property) does not cause the dispatch of the change event.</p>\n</blockquote>\n<p>在类似使用<code>jquery</code>的<code>val()</code>方法时或者原生dom方法改动input的值时，不会触发任何事件。</p>\n<blockquote>\n<p><a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090\" target=\"_blank\" rel=\"external\">vue.js #L6090</a><br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> event = lazy</div><div class=\"line\">  ? <span class=\"string\">'change'</span></div><div class=\"line\">  : type === <span class=\"string\">'range'</span></div><div class=\"line\">    ? RANGE_TOKEN</div><div class=\"line\">    : <span class=\"string\">'input'</span>;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>而vue是通过绑定事件（默认是<code>input</code>）来获知表单元素的变动的，因此这个问题就是因为插件直接用<code>.val()</code>设置了值，而vue无法获知。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>我们可以在改动值后手动触发<code>input</code>事件，注意这里我们需要使用DOM原生的<code>event</code>对象，而不能直接使用jquery的<code>.trigger()</code>方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//.get(0)返回DOM原生对象</span></div><div class=\"line\">$(<span class=\"string\">'#input1'</span>).val(<span class=\"string\">'something'</span>).get(<span class=\"number\">0</span>).dispatchEvent(<span class=\"keyword\">new</span> Event(<span class=\"string\">'input'</span>));</div></pre></td></tr></table></figure></p>\n<p>在我这个具体问题中，监听插件的自定义事件就可以了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\".form_datetime\"</span>).datepicker()</div><div class=\"line\">  .on(<span class=\"string\">'changeDate'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//触发DOM对象上的原生input事件</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.dispatchEvent(<span class=\"keyword\">new</span> Event(<span class=\"string\">'input'</span>))</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>注意如果input使用的修饰符带有<code>.lazy</code>则应该触发<code>change</code>事件</p>\n<p>当然最好的办法还是避免使用其他库来改动表单，改为使用基于vue的插件之类的，省心省力</p>\n","excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>自己的页面使用了vue和一款jquery的时间选择插件<code>datepicker</code>，但选好时间后input框的变动并没有被vue捕获到</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><blockquote>\n<p><a href=\"http://cn.vuejs.org/v2/guide/forms.html#基础用法\">Vue表单控件绑定</a><br><a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090\">Vue源码</a><br><a href=\"http://api.jquery.com/val/#val-value\">Jquery的val()方法说明</a><br><a href=\"http://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html\">从vue.js的源码分析…</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Event\">MDN: Event对象</a></p>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>jquery的val方法文档写得很清楚：</p>\n<blockquote>\n<p>Setting values using this method (or using the native value property) does not cause the dispatch of the change event.</p>\n</blockquote>\n<p>在类似使用<code>jquery</code>的<code>val()</code>方法时或者原生dom方法改动input的值时，不会触发任何事件。</p>\n<blockquote>\n<p><a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090\">vue.js #L6090</a><br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> event = lazy</div><div class=\"line\">  ? <span class=\"string\">'change'</span></div><div class=\"line\">  : type === <span class=\"string\">'range'</span></div><div class=\"line\">    ? RANGE_TOKEN</div><div class=\"line\">    : <span class=\"string\">'input'</span>;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>而vue是通过绑定事件（默认是<code>input</code>）来获知表单元素的变动的，因此这个问题就是因为插件直接用<code>.val()</code>设置了值，而vue无法获知。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>我们可以在改动值后手动触发<code>input</code>事件，注意这里我们需要使用DOM原生的<code>event</code>对象，而不能直接使用jquery的<code>.trigger()</code>方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//.get(0)返回DOM原生对象</span></div><div class=\"line\">$(<span class=\"string\">'#input1'</span>).val(<span class=\"string\">'something'</span>).get(<span class=\"number\">0</span>).dispatchEvent(<span class=\"keyword\">new</span> Event(<span class=\"string\">'input'</span>));</div></pre></td></tr></table></figure></p>\n<p>在我这个具体问题中，监听插件的自定义事件就可以了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\".form_datetime\"</span>).datepicker()</div><div class=\"line\">  .on(<span class=\"string\">'changeDate'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//触发DOM对象上的原生input事件</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.dispatchEvent(<span class=\"keyword\">new</span> Event(<span class=\"string\">'input'</span>))</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>注意如果input使用的修饰符带有<code>.lazy</code>则应该触发<code>change</code>事件</p>\n<p>当然最好的办法还是避免使用其他库来改动表单，改为使用基于vue的插件之类的，省心省力</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj481v9zm0005i8u0g8szsdpm","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481v9zt000ai8u0dbao02ot"},{"post_id":"cj481v9z40000i8u0f4o4k36g","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481v9zv000ei8u05tq1ixgv"},{"post_id":"cj481v9z90001i8u0qhl1z5cl","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481v9zz000hi8u05vyv0dv9"},{"post_id":"cj481v9zw000fi8u0uqecvpda","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481va03000ni8u04wbui3yq"},{"post_id":"cj481v9zj0004i8u0e4zxppm3","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481va05000ri8u0lh2pihzq"},{"post_id":"cj481v9zq0006i8u0veo7c7zp","category_id":"cj481va00000ji8u046vs0p4k","_id":"cj481va07000vi8u01mxdg00c"},{"post_id":"cj481va05000si8u0afis3fyw","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481va0a0010i8u02yd9t9qb"},{"post_id":"cj481v9zs0009i8u0s7ahzfoh","category_id":"cj481va00000ji8u046vs0p4k","_id":"cj481va0c0013i8u0jmzrqmsu"},{"post_id":"cj481va06000ui8u01gyozwcp","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481va0j0016i8u0t6684i4q"},{"post_id":"cj481va09000zi8u05nia5uvh","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481va0k001ai8u0g79bh9sf"},{"post_id":"cj481v9zu000bi8u09w4pantu","category_id":"cj481va00000ji8u046vs0p4k","_id":"cj481va0l001ci8u0wh4wrdri"},{"post_id":"cj481va0b0011i8u0x1scpu3q","category_id":"cj481va00000ji8u046vs0p4k","_id":"cj481va0m001ei8u007pe5g5k"},{"post_id":"cj481va0d0014i8u0y1o6s2h9","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481va0o001ii8u0mivs77dj"},{"post_id":"cj481v9zz000ii8u03d39h9qd","category_id":"cj481va0c0012i8u07p4or8ne","_id":"cj481va0o001ki8u0vw3gixru"},{"post_id":"cj481va0j0017i8u0gzcme896","category_id":"cj481va00000ji8u046vs0p4k","_id":"cj481va0p001mi8u0btlo0gnc"},{"post_id":"cj481va02000mi8u0zzg4tb12","category_id":"cj481va0k0018i8u0xlu0ujii","_id":"cj481va0p001ni8u0emql0kcu"},{"post_id":"cj481va03000oi8u0escmzz07","category_id":"cj481va0k0018i8u0xlu0ujii","_id":"cj481va0r001pi8u0ph500bjy"},{"post_id":"cj481va1e002yi8u0q0i69sjk","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481va1i0032i8u0bo5skyah"},{"post_id":"cj481va1h002zi8u0brq4qfnc","category_id":"cj481v9ze0002i8u0j817tbpk","_id":"cj481va1i0033i8u0f3rfxsou"}],"PostTag":[{"post_id":"cj481v9z40000i8u0f4o4k36g","tag_id":"cj481v9zj0003i8u04q84y5ng","_id":"cj481v9zx000gi8u02hy0lc00"},{"post_id":"cj481v9z40000i8u0f4o4k36g","tag_id":"cj481v9zr0008i8u0a9zny7ve","_id":"cj481va01000ki8u0bg67aods"},{"post_id":"cj481v9z90001i8u0qhl1z5cl","tag_id":"cj481v9zj0003i8u04q84y5ng","_id":"cj481va06000ti8u0mgzu2x4t"},{"post_id":"cj481v9z90001i8u0qhl1z5cl","tag_id":"cj481va02000li8u0vvvaz74w","_id":"cj481va08000xi8u0lzjwevo3"},{"post_id":"cj481va0d0014i8u0y1o6s2h9","tag_id":"cj481v9zj0003i8u04q84y5ng","_id":"cj481va0k0019i8u0q9lbh5oh"},{"post_id":"cj481v9zj0004i8u0e4zxppm3","tag_id":"cj481va04000qi8u03pfo68sh","_id":"cj481va0m001di8u09a7buzd0"},{"post_id":"cj481v9zj0004i8u0e4zxppm3","tag_id":"cj481va09000yi8u0aooddo03","_id":"cj481va0m001gi8u03trrr29y"},{"post_id":"cj481v9zj0004i8u0e4zxppm3","tag_id":"cj481va0g0015i8u07dkow1gs","_id":"cj481va0o001ji8u0zk3nj86a"},{"post_id":"cj481v9zm0005i8u0g8szsdpm","tag_id":"cj481va04000qi8u03pfo68sh","_id":"cj481va0s001ri8u0v1yq1y1g"},{"post_id":"cj481v9zm0005i8u0g8szsdpm","tag_id":"cj481va0g0015i8u07dkow1gs","_id":"cj481va0t001si8u05blg1skq"},{"post_id":"cj481v9zm0005i8u0g8szsdpm","tag_id":"cj481va0o001li8u05nfx9p7a","_id":"cj481va0t001ui8u01711xnan"},{"post_id":"cj481v9zm0005i8u0g8szsdpm","tag_id":"cj481va0r001oi8u0m40j54ul","_id":"cj481va0u001vi8u0anexwdi2"},{"post_id":"cj481v9zq0006i8u0veo7c7zp","tag_id":"cj481va04000qi8u03pfo68sh","_id":"cj481va0v001xi8u0edtpcmdx"},{"post_id":"cj481v9zs0009i8u0s7ahzfoh","tag_id":"cj481va04000qi8u03pfo68sh","_id":"cj481va0y001yi8u0j85j0wku"},{"post_id":"cj481v9zu000bi8u09w4pantu","tag_id":"cj481v9zj0003i8u04q84y5ng","_id":"cj481va100022i8u05anlwefv"},{"post_id":"cj481v9zu000bi8u09w4pantu","tag_id":"cj481va04000qi8u03pfo68sh","_id":"cj481va100023i8u07feg45ai"},{"post_id":"cj481v9zu000bi8u09w4pantu","tag_id":"cj481va0y001zi8u0fe3wzmo5","_id":"cj481va110025i8u083dwbg6j"},{"post_id":"cj481v9zu000bi8u09w4pantu","tag_id":"cj481va0z0020i8u0pkx83t1t","_id":"cj481va110026i8u0550865ry"},{"post_id":"cj481v9zw000fi8u0uqecvpda","tag_id":"cj481va0z0021i8u0pq2i388t","_id":"cj481va120028i8u0jv87z87d"},{"post_id":"cj481v9zz000ii8u03d39h9qd","tag_id":"cj481va100024i8u05nhlg6ty","_id":"cj481va120029i8u0lbg3x70e"},{"post_id":"cj481va05000si8u0afis3fyw","tag_id":"cj481va0o001li8u05nfx9p7a","_id":"cj481va14002di8u0yg31phbr"},{"post_id":"cj481va05000si8u0afis3fyw","tag_id":"cj481va13002ai8u01v4f32xy","_id":"cj481va14002ei8u0vksdgjof"},{"post_id":"cj481va05000si8u0afis3fyw","tag_id":"cj481va13002bi8u0tomrmwk1","_id":"cj481va14002gi8u05ms8xld3"},{"post_id":"cj481va06000ui8u01gyozwcp","tag_id":"cj481va04000qi8u03pfo68sh","_id":"cj481va15002ii8u0keb78diy"},{"post_id":"cj481va06000ui8u01gyozwcp","tag_id":"cj481va0o001li8u05nfx9p7a","_id":"cj481va15002ji8u0axergihg"},{"post_id":"cj481va06000ui8u01gyozwcp","tag_id":"cj481va0r001oi8u0m40j54ul","_id":"cj481va16002li8u09vafv171"},{"post_id":"cj481va09000zi8u05nia5uvh","tag_id":"cj481va0y001zi8u0fe3wzmo5","_id":"cj481va18002oi8u0mxfm78gc"},{"post_id":"cj481va09000zi8u05nia5uvh","tag_id":"cj481va15002ki8u080y3ynao","_id":"cj481va18002pi8u0zxhlkdth"},{"post_id":"cj481va09000zi8u05nia5uvh","tag_id":"cj481va17002mi8u04qk1sn5u","_id":"cj481va19002ri8u0mp2t7bq7"},{"post_id":"cj481va0b0011i8u0x1scpu3q","tag_id":"cj481va0o001li8u05nfx9p7a","_id":"cj481va1a002ti8u0j2xqseky"},{"post_id":"cj481va0b0011i8u0x1scpu3q","tag_id":"cj481va0r001oi8u0m40j54ul","_id":"cj481va1a002ui8u0se9t582w"},{"post_id":"cj481va0j0017i8u0gzcme896","tag_id":"cj481va19002si8u0a5kmcsdi","_id":"cj481va1b002wi8u0cp68bakh"},{"post_id":"cj481va0j0017i8u0gzcme896","tag_id":"cj481va1a002vi8u058ksv59i","_id":"cj481va1b002xi8u045coxgqu"},{"post_id":"cj481va1e002yi8u0q0i69sjk","tag_id":"cj481va13002ai8u01v4f32xy","_id":"cj481va1i0030i8u0bq2r0ewy"},{"post_id":"cj481va1h002zi8u0brq4qfnc","tag_id":"cj481va1i0031i8u0ubhgc1b3","_id":"cj481va1j0035i8u08zj4szez"},{"post_id":"cj481va1h002zi8u0brq4qfnc","tag_id":"cj481va1j0034i8u0nsii1zxy","_id":"cj481va1j0036i8u005faijoe"},{"post_id":"cj481va1h002zi8u0brq4qfnc","tag_id":"cj481va04000qi8u03pfo68sh","_id":"cj481va1j0037i8u05aq5dfdx"}],"Tag":[{"name":"nodejs","_id":"cj481v9zj0003i8u04q84y5ng"},{"name":"encoding","_id":"cj481v9zr0008i8u0a9zny7ve"},{"name":"stream","_id":"cj481va02000li8u0vvvaz74w"},{"name":"javascript","_id":"cj481va04000qi8u03pfo68sh"},{"name":"es6","_id":"cj481va09000yi8u0aooddo03"},{"name":"Proxy","_id":"cj481va0g0015i8u07dkow1gs"},{"name":"Promise","_id":"cj481va0o001li8u05nfx9p7a"},{"name":"ES6","_id":"cj481va0r001oi8u0m40j54ul"},{"name":"promise","_id":"cj481va0y001zi8u0fe3wzmo5"},{"name":"express","_id":"cj481va0z0020i8u0pkx83t1t"},{"name":"C++","_id":"cj481va0z0021i8u0pq2i388t"},{"name":"node","_id":"cj481va100024i8u05nhlg6ty"},{"name":"javaScript","_id":"cj481va13002ai8u01v4f32xy"},{"name":"前端","_id":"cj481va13002bi8u0tomrmwk1"},{"name":"async","_id":"cj481va15002ki8u080y3ynao"},{"name":"es7","_id":"cj481va17002mi8u04qk1sn5u"},{"name":"node.js","_id":"cj481va19002si8u0a5kmcsdi"},{"name":"socket.io","_id":"cj481va1a002vi8u058ksv59i"},{"name":"vue","_id":"cj481va1i0031i8u0ubhgc1b3"},{"name":"jquery","_id":"cj481va1j0034i8u0nsii1zxy"}]}}