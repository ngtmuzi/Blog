{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/img/elk_desc_1.png","path":"img/elk_desc_1.png","modified":1,"renderable":0},{"_id":"source/img/elk_desc_2.png","path":"img/elk_desc_2.png","modified":1,"renderable":0},{"_id":"source/img/node_cmd_1.jpg","path":"img/node_cmd_1.jpg","modified":1,"renderable":0},{"_id":"source/img/streamII-1.png","path":"img/streamII-1.png","modified":1,"renderable":0},{"_id":"source/img/streamII-2.png","path":"img/streamII-2.png","modified":1,"renderable":0},{"_id":"source/img/streamII-3.png","path":"img/streamII-3.png","modified":1,"renderable":0},{"_id":"source/img/webshell_1.png","path":"img/webshell_1.png","modified":1,"renderable":0},{"_id":"themes/clean-blog/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/robots.txt","path":"robots.txt","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/article.styl","path":"css/article.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/mixins.styl","path":"css/mixins.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/variables.styl","path":"css/variables.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/home-bg_bk2.jpg","path":"img/home-bg_bk2.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/home-bg_bk1.jpg","path":"img/home-bg_bk1.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/streamII-1.png","path":"img/streamII-1.png","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/streamII-2.png","path":"img/streamII-2.png","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/streamII-3.png","path":"img/streamII-3.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_drafts/TypeScript学习笔记.md","hash":"38c3bf3ad93a4e7ae14b77e99c6a1037accea603","modified":1603935880784},{"_id":"source/_posts/2017年终小结.md","hash":"adc2a83a7681f9797710edc2641ab4b33ee3649e","modified":1592389600461},{"_id":"source/_posts/NodeJS：Stream研究笔记.md","hash":"e80c2b9fef7d1342fdec17bdf1ba750147577f2e","modified":1592389600462},{"_id":"source/_posts/NodeJS：Stream研究笔记II.md","hash":"120952a0f96366ed994b3187d4ba6e4ff398afde","modified":1596781126579},{"_id":"source/_posts/Node处理字符编码相关经验.md","hash":"e64a51c105ea4c5db3d7d9a63d42f4481ee52988","modified":1592389600463},{"_id":"source/_posts/Node实现简单的redis同步锁.md","hash":"7453ced4fa62b550b1ab50454b87d11fbf8a8456","modified":1592389600463},{"_id":"source/_posts/Node对流的Promise包装和并发控制.md","hash":"63a53f8c2378ae65d6101e51124675e88d661b19","modified":1592389600463},{"_id":"source/_posts/Node开发命令行工具的经验总结.md","hash":"4b3371001f72635c7d76de21c4843959d8921c50","modified":1592389600464},{"_id":"source/_posts/Node监视文件以实现热更新.md","hash":"2f77b3a485428eefe13e9729a4a32a5ba123e484","modified":1592389600464},{"_id":"source/_posts/Nuxt-js试用小结.md","hash":"fd4a7bba874b2810524641e711739ada10c5e4bd","modified":1592389600465},{"_id":"source/_posts/PWA脚手架Lavas试用小结.md","hash":"2e38431b0de59c748ff15cc7abebbba6a4560c72","modified":1592389600465},{"_id":"source/_posts/Proxy实现Promise同步调用逻辑.md","hash":"6209215597cd26ff66463483fc9d8809ffa2747f","modified":1592389600465},{"_id":"source/_posts/Proxy对象仿Scala的通配符函数调用.md","hash":"8b8c58747d158edabb4549e137aeb7b1fd6bb727","modified":1592389600466},{"_id":"source/_posts/javaScript实现一个分数计算的类.md","hash":"b51caf7b0ecc7366e7344a2f5cb91bcd81a48822","modified":1592389600466},{"_id":"source/_posts/javaScript的函数柯里化.md","hash":"62e5c45c691c0e93ef0584182ce5a913224edb51","modified":1592389600467},{"_id":"source/_posts/javascript模板渲染研究笔记（一）.md","hash":"6bf1d81463e2a70515c8b03b0d1332fbca21bf93","modified":1592389600467},{"_id":"source/_posts/mingw32缺少posix_memalign函数.md","hash":"2bcf86db38961bdec74ddc7f2f54d6a0b0183ebc","modified":1592389600467},{"_id":"source/_posts/mysql插入uuid主键时引起的死锁问题.md","hash":"55ff3feb299d306b3140d2556e56b01715d0d9ee","modified":1592389600468},{"_id":"source/_posts/promise的日常应用.md","hash":"d218f23926e29ff9fab84b2c8bc811e37c48e196","modified":1592389600468},{"_id":"source/_posts/《凤凰项目》读书笔记.md","hash":"2afeecbca93efba467fb94d92659512cd4c4444e","modified":1596781126530},{"_id":"source/_posts/一次Node代码bug的追踪过程.md","hash":"ef856f7d909c078b456565b16a9b801332d2b247","modified":1592389600469},{"_id":"source/_posts/个人使用Elastic-Kibana的一些经验.md","hash":"059cecf55e61de3607565abd66e91c2c2b3f9793","modified":1592389600469},{"_id":"source/_posts/个人博客绝赞内测中.md","hash":"dd90f54fc7ec218b31e9593f370a84a05f629d23","modified":1592389600469},{"_id":"source/_posts/使用bash命令清理MSSQL内存.md","hash":"aca3330f6d6ce349f86ba29d4d633d185a203bd4","modified":1592389600470},{"_id":"source/_posts/使用socket-io在页面上输出实时日志.md","hash":"a12c955b553d2c6ff4210856e9e55d99a23749ec","modified":1592389600470},{"_id":"source/_posts/博客迁移到hexo.md","hash":"bdca0a904b83b92e9f55e00eea42340e772b4afa","modified":1592389600471},{"_id":"source/_posts/在前端确认框上套用Promise.md","hash":"a9167c929f9dda2328ad5364c78969d483c3eba7","modified":1592389600471},{"_id":"source/_posts/实现一个嵌套对象式的路由中间件.md","hash":"ad8911d2829c09f24e6a9680bf299cadb560f4e0","modified":1592389600472},{"_id":"source/_posts/实现一个简单的promise队列.md","hash":"1663d352311315f4c3c9c58156da98ce63d2132a","modified":1592389600472},{"_id":"source/_posts/屏蔽参数中的敏感字段.md","hash":"3a9a21eebc2a61d7f852a4e509d0fd97fa391dad","modified":1592389600472},{"_id":"source/_posts/异步编程，asyncawait还是promise？.md","hash":"5f0d65f37c118ffecbbc02d79fc57734624ced9f","modified":1592389600473},{"_id":"source/_posts/维持一个超长时间的mongodb游标.md","hash":"d0fcbc1d30b9b2fea4dfa596da3948343941fa9f","modified":1592393601804},{"_id":"source/_posts/第一次面试官经验.md","hash":"c730f8371ce22508a0940c22e07e411015ff0af4","modified":1592389600473},{"_id":"source/_posts/自己撸一个Promise库的过程.md","hash":"8b82aa1b5bbf351c2888d1cec6835d4df08f7c1d","modified":1592389600474},{"_id":"source/_posts/解决vue无法捕获input变动的问题.md","hash":"8ade01d6b0dfa1f6c100b122e191ee06b49c7166","modified":1592389600474},{"_id":"source/img/elk_desc_1.png","hash":"e9ffb13dd89fdda54efc32dfaf0d4be5d6619819","modified":1592389600489},{"_id":"source/img/elk_desc_2.png","hash":"3f6db8afc37a5818c31d88b32ef1555ffe429b75","modified":1592389600490},{"_id":"source/img/node_cmd_1.jpg","hash":"319c3983a77a47284366bb59bfa21a1d9daf9efd","modified":1592389600492},{"_id":"source/img/webshell_1.png","hash":"cddefb4a22ba3fb4b81b6fa83cd66235802c4995","modified":1592389600493},{"_id":"source/img/streamII-2.png","hash":"ae1f7196110852e6a256c3844a5f57f3fb4b29b6","modified":1593411508136},{"_id":"source/img/streamII-3.png","hash":"7e1390bfb0d9d1bc59835cc6072e3235d4c0b51a","modified":1593411529287},{"_id":"source/img/streamII-1.png","hash":"b755ef962fce3df1e3680a5f8e259039c31cf645","modified":1593411486018},{"_id":"themes/clean-blog/LICENSE","hash":"8726b416df4f067cff579e859f05c4b594b8be09","modified":1592389600475},{"_id":"themes/clean-blog/README.md","hash":"c5c7b0fd01aa229304e7b00697517aaca51de577","modified":1592389600475},{"_id":"themes/clean-blog/_config.yml","hash":"f638bc512c5ab5a10bf3fb21b41147db2e7cd529","modified":1592389600475},{"_id":"themes/clean-blog/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1592389600476},{"_id":"themes/clean-blog/languages/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1592389600476},{"_id":"themes/clean-blog/languages/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1592389600477},{"_id":"themes/clean-blog/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1592389600477},{"_id":"themes/clean-blog/languages/fr.yml","hash":"e9e6f7cb362ebb7997f11027498a2748fe3bac95","modified":1592389600477},{"_id":"themes/clean-blog/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1592389600478},{"_id":"themes/clean-blog/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1592389600478},{"_id":"themes/clean-blog/languages/pt.yml","hash":"1d0c3689eb32fe13f37f8f6f303af7624ebfbaf0","modified":1592389600478},{"_id":"themes/clean-blog/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1592389600479},{"_id":"themes/clean-blog/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1592389600479},{"_id":"themes/clean-blog/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1592389600479},{"_id":"themes/clean-blog/layout/archive.ejs","hash":"ad0da72df13ce3566985bb390c2c9a9352cf4f07","modified":1592389600485},{"_id":"themes/clean-blog/layout/index.ejs","hash":"0f423d91d7ccfdf7465ff4e6fa5aa610868e1537","modified":1592389600485},{"_id":"themes/clean-blog/layout/layout.ejs","hash":"da2f9018047924ddaf376aee5996c7ddc06cebc1","modified":1592389600485},{"_id":"themes/clean-blog/layout/page.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1592389600486},{"_id":"themes/clean-blog/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1592389600486},{"_id":"themes/clean-blog/source/favicon.ico","hash":"11c8f3376cd3d5c578f72b15265614b1c91c0921","modified":1592389600489},{"_id":"themes/clean-blog/source/robots.txt","hash":"ef4399f3fc2e27fc7a15db3b2dafcc8a69ce9d44","modified":1592791549485},{"_id":"themes/clean-blog/layout/_partial/after-footer.ejs","hash":"e454a4a66d8cdd30e41af565375148559fa88d17","modified":1596781126531},{"_id":"themes/clean-blog/layout/_partial/article-archive.ejs","hash":"3d8d98c6545b8332a6d6ed4f8b00327df03ea945","modified":1592389600480},{"_id":"themes/clean-blog/layout/_partial/article-categories.ejs","hash":"5a0bf5a20f670621d8013c9b9d7976b45c8aa80f","modified":1592389600481},{"_id":"themes/clean-blog/layout/_partial/article-full.ejs","hash":"f3b7e5ed523ef7f3777ef4adcc4805417af268e8","modified":1596781126532},{"_id":"themes/clean-blog/layout/_partial/article-index.ejs","hash":"b4d946abfe4d40739aa92c805ef8d6ab5dc9c2d5","modified":1592389600482},{"_id":"themes/clean-blog/layout/_partial/article-tags.ejs","hash":"6136434be09056c1466149cecb3cc2e80d107999","modified":1592389600482},{"_id":"themes/clean-blog/layout/_partial/comments.ejs","hash":"cc6194c98ce4f3c8e2b4ea15e39e0666d88804ed","modified":1592390082844},{"_id":"themes/clean-blog/layout/_partial/footer.ejs","hash":"fcced5acef1a61b4fa90e31e8c2228909ce1399b","modified":1596781126532},{"_id":"themes/clean-blog/layout/_partial/gallery.ejs","hash":"d3b825edfd9e6fbca2392b42eed5ed1568779ed7","modified":1596781126533},{"_id":"themes/clean-blog/layout/_partial/google-analytics.ejs","hash":"c88f50cb26efa0e1becec86b120ce4eb08660580","modified":1603935951571},{"_id":"themes/clean-blog/layout/_partial/head.ejs","hash":"ddf664809a5d70ce8935513eba7150f8c08575e7","modified":1596781126534},{"_id":"themes/clean-blog/layout/_partial/menu.ejs","hash":"ba299316400499e9ede154e9627cafb7ce411888","modified":1592389600484},{"_id":"themes/clean-blog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1592389600484},{"_id":"themes/clean-blog/source/css/article.styl","hash":"1543966aa5af7b26c3bab70bb3364158a89b1bf6","modified":1603421790194},{"_id":"themes/clean-blog/source/css/base.styl","hash":"433ebbf949b47b3038226fce11f38cd527626a1b","modified":1592389600487},{"_id":"themes/clean-blog/source/css/mixins.styl","hash":"4b224ddda978e19d8c1797097941fb183a3e18c8","modified":1592389600487},{"_id":"themes/clean-blog/source/css/style.styl","hash":"c40dc495a41007d21c59f342ee42b2d31d7b5ff4","modified":1592389600488},{"_id":"themes/clean-blog/source/css/variables.styl","hash":"cd82df5ca8dfbcfec12d833f01adfac00878e835","modified":1592389600488},{"_id":"themes/clean-blog/source/img/streamII-2.png","hash":"5f17ebece5b94457e7f90ad2a98ce6a7fb564710","modified":1596781126547},{"_id":"themes/clean-blog/source/img/streamII-3.png","hash":"7675abe24e0530b13450c018e1da0e0cff80adde","modified":1596781126548},{"_id":"themes/clean-blog/source/img/home-bg_bk2.jpg","hash":"c2c0806abebcf420976af95400da29e295d442da","modified":1596781126543},{"_id":"themes/clean-blog/source/img/streamII-1.png","hash":"37c14b3db9c182330dc6f738de8d58d45f5b8a70","modified":1596781126545},{"_id":"themes/clean-blog/source/img/home-bg.jpg","hash":"4291c55c57c96cb0a48d12073e621913fae761c7","modified":1596781126536},{"_id":"themes/clean-blog/source/img/home-bg_bk1.jpg","hash":"3f106a5c8a1edb5c5dc865b8f293d58b5ef9d03e","modified":1592389600492},{"_id":"public/rss2.xml","hash":"8fac71ea51398b2d5c25fc696e6b4655346c66bb","modified":1603936447975},{"_id":"public/sitemap.xml","hash":"a5dbaaf18a7f17d19b51334db4358e2480d4ee35","modified":1603936447975},{"_id":"public/使用bash命令清理MSSQL内存/index.html","hash":"78a31dda852eeb5e13f0173e0c0a3566b4bfdc7c","modified":1603936447975},{"_id":"public/mysql插入uuid主键时引起的死锁问题/index.html","hash":"80de0a115f8b6470905c4814498206e733cfea4c","modified":1603936447975},{"_id":"public/第一次面试官经验/index.html","hash":"c0271c2128ed3a47d8140449ddfd1cbd7cdba440","modified":1603936447975},{"_id":"public/实现一个嵌套对象式的路由中间件/index.html","hash":"8a0c37a3c4d16e00e135bdcd526f0b33964948fa","modified":1603936447975},{"_id":"public/2017年终小结/index.html","hash":"0d3897b2c7d80ad640c61412226fcd887bcac08c","modified":1603936447975},{"_id":"public/个人使用Elastic-Kibana的一些经验/index.html","hash":"b0792acf93639f02f1f1c4bf4a9e71c2050a3559","modified":1603936447975},{"_id":"public/解决vue无法捕获input变动的问题/index.html","hash":"699ac77b6a75223e31981b6f5a25c62bca347ee5","modified":1603936447975},{"_id":"public/异步编程，asyncawait还是promise？/index.html","hash":"2b640e04579ba7c425bc40a75c9090b9d1cb30e3","modified":1603936447975},{"_id":"public/屏蔽参数中的敏感字段/index.html","hash":"3f7ebaeb1e81447bed7ee17ac2b1a5bf8237450d","modified":1603936447975},{"_id":"public/在前端确认框上套用Promise/index.html","hash":"7aa83a037a4309285e336b2511e76ced3321c2ad","modified":1603936447975},{"_id":"public/博客迁移到hexo/index.html","hash":"1e657fc25fb02e175b793a5a33f0c50d2cbe1931","modified":1603936447975},{"_id":"public/自己撸一个Promise库的过程/index.html","hash":"1cafa2d651a2e0cca706de65993ff8a2b499363c","modified":1603936447975},{"_id":"public/javaScript的函数柯里化/index.html","hash":"22a4178c135c929c9acfa1b706036cd7aca198e4","modified":1603936447975},{"_id":"public/mingw32缺少posix_memalign函数/index.html","hash":"9dcc7617aba29f0e955b5aba0c7c9c90630756cb","modified":1603936447975},{"_id":"public/个人博客绝赞内测中/index.html","hash":"1d843a4b0c552d4d6ace131cbd6176feffae06ac","modified":1603936447975},{"_id":"public/archives/index.html","hash":"a37daa8cf231f459341017e090e7c81fe11b47f7","modified":1603936447975},{"_id":"public/archives/page/2/index.html","hash":"df482b67595f835d8862392725d8b459c2b4675b","modified":1603936447975},{"_id":"public/archives/page/3/index.html","hash":"9248aec24851cfe8d51636cfb14c8490819bf254","modified":1603936447975},{"_id":"public/archives/page/4/index.html","hash":"9db1525475ff02073e60318cda439d715664b01a","modified":1603936447975},{"_id":"public/archives/page/5/index.html","hash":"902dfdfe1b17a34ff7cc80c07a4e506d46983933","modified":1603936447975},{"_id":"public/archives/page/6/index.html","hash":"d46f3f57656ee2310c913ff10841eb07de9ee975","modified":1603936447975},{"_id":"public/archives/2015/index.html","hash":"7c36dd607764d61afefdc78ee118cded1c0fb313","modified":1603936447975},{"_id":"public/archives/2015/11/index.html","hash":"2ba13dc9617ccaeac89e1ed04d4d00a57a97bf41","modified":1603936447975},{"_id":"public/archives/2015/12/index.html","hash":"e8601d22d97c93a4fa331e3708153aff373077b1","modified":1603936447975},{"_id":"public/archives/2016/index.html","hash":"cb67c92d5745baf848543707e0d677b92fbd718f","modified":1603936447975},{"_id":"public/archives/2016/01/index.html","hash":"d19d1809abf358d5d95f0b1a829f02df2f52b308","modified":1603936447975},{"_id":"public/archives/2016/02/index.html","hash":"6259afbcd7e27ebafc00273404305ecb2a9e600b","modified":1603936447975},{"_id":"public/archives/2016/04/index.html","hash":"a5bc95e69b044b0589e18c1f7ecfa4eccc893863","modified":1603936447975},{"_id":"public/archives/2016/05/index.html","hash":"12ca56c1861d75745f6611c04d8f5df7539ec48e","modified":1603936447975},{"_id":"public/archives/2016/08/index.html","hash":"d88b9f6f7c362da0cce215a1c09a5346119ed070","modified":1603936447975},{"_id":"public/archives/2017/index.html","hash":"c31886423efe61a2fdaaf0a45d47c2fbdf97bdb0","modified":1603936447975},{"_id":"public/archives/2017/page/2/index.html","hash":"4e10490a65092981100cbd6270fe9346356a8e4a","modified":1603936447975},{"_id":"public/archives/2017/page/3/index.html","hash":"ba60e1397561670858f31b258078957bb1632b02","modified":1603936447975},{"_id":"public/archives/2017/01/index.html","hash":"d6c5118d427df0b52402b6b62fc051bb18dfe958","modified":1603936447975},{"_id":"public/archives/2017/02/index.html","hash":"b1f313f40e07aeb4debfb1dddd49a9eb27133eae","modified":1603936447975},{"_id":"public/archives/2017/04/index.html","hash":"73c3fd43580de193710fd9db18b2e0642aa4a4c6","modified":1603936447975},{"_id":"public/archives/2017/05/index.html","hash":"8f3cdc008295ee6ad05a650617bda72a18617cf6","modified":1603936447975},{"_id":"public/archives/2017/06/index.html","hash":"b74a3f7040af9963935bf9ce41c44d17dafdc085","modified":1603936447975},{"_id":"public/archives/2017/07/index.html","hash":"fc4cb114a1c6244663d74511c9a79edfc4291d52","modified":1603936447975},{"_id":"public/archives/2017/09/index.html","hash":"12682dd938e68aa4cc49884a879c34112c91aae2","modified":1603936447975},{"_id":"public/archives/2018/index.html","hash":"73011920006420352c5c6b56bf60e28cea9399f8","modified":1603936447975},{"_id":"public/archives/2018/page/2/index.html","hash":"68ce11553f1b8f9fc6fcac812ded80e3b4f48a8c","modified":1603936447975},{"_id":"public/archives/2018/01/index.html","hash":"829aba919ae9e51d180f62e26ac985482e563a71","modified":1603936447975},{"_id":"public/archives/2018/03/index.html","hash":"94ecf604f9d37622524765b570a09e091c8d8e2e","modified":1603936447975},{"_id":"public/archives/2018/05/index.html","hash":"576cbfc2aa2c57065fb183c40ae3f9ae79e353b2","modified":1603936447975},{"_id":"public/archives/2018/06/index.html","hash":"042bb8464b99304b2ac022448bed4088fac48b95","modified":1603936447975},{"_id":"public/archives/2018/09/index.html","hash":"fedd5b7a66f76f910b8b5e06a556bc6c6189d1dc","modified":1603936447975},{"_id":"public/archives/2018/11/index.html","hash":"04c09e16e658f4adcd6807a8f00f100ddb807501","modified":1603936447975},{"_id":"public/archives/2019/index.html","hash":"63aa374f2b43870050c6af022946fc962d393bc4","modified":1603936447975},{"_id":"public/archives/2019/03/index.html","hash":"575e37e9f3cb61a668423d5d0ef9b4534b8f24f3","modified":1603936447975},{"_id":"public/archives/2019/07/index.html","hash":"baf42027f654c92255720fbe6420e72689c4f27f","modified":1603936447975},{"_id":"public/archives/2019/09/index.html","hash":"799df3f2701e3d2f2180074ff2f8e3a4626d3414","modified":1603936447975},{"_id":"public/archives/2020/index.html","hash":"1fba838683f2ed90e37c75b37858b29aa16771d7","modified":1603936447975},{"_id":"public/archives/2020/04/index.html","hash":"250e59d587d5414eb443a44f3cfe41c77d718d81","modified":1603936447975},{"_id":"public/archives/2020/06/index.html","hash":"37fdd6d60a1fea3cfef5750e807998df6acf6c22","modified":1603936447975},{"_id":"public/categories/班门弄斧/index.html","hash":"7ca876be06e380d8e8be72c468d7537554445b63","modified":1603936447975},{"_id":"public/categories/班门弄斧/page/2/index.html","hash":"4d19ec3f915f654fb157df392d6c9087e5775011","modified":1603936447975},{"_id":"public/categories/随笔/index.html","hash":"735a33731c7654e30211ce10649d3a219573dc11","modified":1603936447975},{"_id":"public/categories/神秘代码/index.html","hash":"bbf336a887e6220bcd5f089ee5273a658a6f3ce6","modified":1603936447975},{"_id":"public/categories/神秘代码/page/2/index.html","hash":"30aa34961ef648cf4221bae98645fd91b9637cf1","modified":1603936447975},{"_id":"public/categories/神秘代码/page/3/index.html","hash":"2291bc7e7581d48d8cd41f335125a66dcd9dd2c5","modified":1603936447975},{"_id":"public/categories/亡羊补牢/index.html","hash":"38610b49681a05f4028107c6784c89df0f92306f","modified":1603936447975},{"_id":"public/index.html","hash":"eb9756232cbd6ad9993fa231c48d0f2385fecd8a","modified":1603936447975},{"_id":"public/page/2/index.html","hash":"160894d630e364bb25a73e8e45ee843ae82b66a4","modified":1603936447975},{"_id":"public/page/3/index.html","hash":"54c6e61b437fbaa122d182087c24de505079a52e","modified":1603936447975},{"_id":"public/page/4/index.html","hash":"583aee3091f5311a8689fb444f293e33097cb9de","modified":1603936447975},{"_id":"public/page/5/index.html","hash":"0264736a4b99fc3386cbfbc2df5dc414188d4373","modified":1603936447975},{"_id":"public/page/6/index.html","hash":"dd093858dc77388b2e4409b0b8e7bce69e7daf27","modified":1603936447975},{"_id":"public/tags/总结/index.html","hash":"022ab9282c37a527eb975839db1f9d366fb2b913","modified":1603936447975},{"_id":"public/tags/nodejs/index.html","hash":"79f23fb0b5dff6e33cbd8a8b6e1c1f8fa7fa886c","modified":1603936447975},{"_id":"public/tags/nodejs/page/2/index.html","hash":"f0226499f7abfd50da180359c1bd7b7718e77a8a","modified":1603936447975},{"_id":"public/tags/stream/index.html","hash":"dcf1a7f8158c1fa0bf0e086d8fedd86b8f4a2e27","modified":1603936447975},{"_id":"public/tags/encoding/index.html","hash":"5b773427e436891736449a38ebdaef2071928002","modified":1603936447975},{"_id":"public/tags/redis/index.html","hash":"b95fd3f1f506e8c52c569034f55e77d027374697","modified":1603936447975},{"_id":"public/tags/promise/index.html","hash":"ad985ab8a5d471f13517f657e4e3fb3dd46eb9df","modified":1603936447975},{"_id":"public/tags/shell/index.html","hash":"8e3937697afa852474a351a5f6e7d7e65b5f318b","modified":1603936447975},{"_id":"public/tags/cli/index.html","hash":"a49436668464f8fefddb6a3c551e82b0936736db","modified":1603936447975},{"_id":"public/tags/vue/index.html","hash":"0f78bec1e34f48bdb945fe94d38143e38381f56c","modified":1603936447975},{"_id":"public/tags/前端/index.html","hash":"f12369c87e5ffe51e677ea49dacc78201efb8b64","modified":1603936447975},{"_id":"public/tags/javascript/index.html","hash":"f10fc4aa35bb3493b0825393f6b00ab9d0354099","modified":1603936447975},{"_id":"public/tags/javascript/page/2/index.html","hash":"f24171652bc68f3e8b3fdb39934934ee212a6d97","modified":1603936447975},{"_id":"public/tags/Tool/index.html","hash":"cee21f048da0ab6cf12c7413ca50635390d7a989","modified":1603936447975},{"_id":"public/tags/Proxy/index.html","hash":"aea05492e4d15f59a11b14aad4b6078fd91d76f1","modified":1603936447975},{"_id":"public/tags/Promise/index.html","hash":"a3d5e4ff4c10bfd4ed8f7241b643a616740d616c","modified":1603936447975},{"_id":"public/tags/ES6/index.html","hash":"f3f08d3f690eb35a43b1d8a1d474e5a5c4fdb35c","modified":1603936447975},{"_id":"public/tags/es6/index.html","hash":"a0357c84004a36e3c26af6b85dde0c3f1a326efe","modified":1603936447975},{"_id":"public/tags/Class/index.html","hash":"d0b01a9eaa76493e786e992a7f9367825ff7aa0f","modified":1603936447975},{"_id":"public/tags/C/index.html","hash":"2e880851a545469a84274ba612bea2b466538be3","modified":1603936447975},{"_id":"public/tags/mysql/index.html","hash":"5bbd12affec96f22f98c62ab0ec2b1cd65f1395a","modified":1603936447975},{"_id":"public/tags/express/index.html","hash":"7871c25215a26f531172cbda16d467113e2d182e","modified":1603936447975},{"_id":"public/tags/ElasticSearch/index.html","hash":"159b03b2f58c5bc2c54802f736d62f800a4239c2","modified":1603936447975},{"_id":"public/tags/Bash/index.html","hash":"523604c61509fccdc148c2b25ed3cb9dc8cb62d5","modified":1603936447975},{"_id":"public/tags/MSSQL/index.html","hash":"685c628bd077f658f459511d19355bbb646615e3","modified":1603936447975},{"_id":"public/tags/socket-io/index.html","hash":"a393fd3df7c4c5ad0ab96b2a61f007796cd2f304","modified":1603936447975},{"_id":"public/tags/javaScript/index.html","hash":"69f019d66c35589e2916cfdced623365a1869faf","modified":1603936447975},{"_id":"public/tags/koa/index.html","hash":"ec08fc437408ac33821c6c9d954c08d27b024e12","modified":1603936447975},{"_id":"public/tags/async/index.html","hash":"b34280b1745be3547f49b13bdd8c332abd3a9c3c","modified":1603936447975},{"_id":"public/tags/es7/index.html","hash":"64fa4b4c2bdc0c968771062f2a801a81c3939e97","modified":1603936447975},{"_id":"public/tags/mongodb/index.html","hash":"05d10403a09a191c4d522b0207f2ee1a0d791eaa","modified":1603936447975},{"_id":"public/tags/jquery/index.html","hash":"641d4b7dbf75bd4f9c3c3daa688b42097ccf9dbf","modified":1603936447975},{"_id":"public/维持一个超长时间的mongodb游标/index.html","hash":"3e890fb1d8326cecaae16a23740696ee0b2604ff","modified":1603936447975},{"_id":"public/NodeJS：Stream研究笔记II/index.html","hash":"0ad72a94f7027c62d406c4303f2693f6f99ecda4","modified":1603936447975},{"_id":"public/《凤凰项目》读书笔记/index.html","hash":"66a2f19916f0a9bc8e346599d9f03abaad45f955","modified":1603936447975},{"_id":"public/Node开发命令行工具的经验总结/index.html","hash":"4cea015b6e5a659d53f3d768443dc6f379e07bfc","modified":1603936447975},{"_id":"public/Node对流的Promise包装和并发控制/index.html","hash":"8f337e95a80bfcaf1e42d911b0b78b1bb7c53074","modified":1603936447975},{"_id":"public/javaScript实现一个分数计算的类/index.html","hash":"3c8088a4ab8fb12179f2b115fbe23488a69eb173","modified":1603936447975},{"_id":"public/Node实现简单的redis同步锁/index.html","hash":"ce96d3ac37c71477351d0d0d541a6aa7a202c42d","modified":1603936447975},{"_id":"public/PWA脚手架Lavas试用小结/index.html","hash":"882540e2cc5f95f4f736d925be13cc3f87bee409","modified":1603936447975},{"_id":"public/Nuxt-js试用小结/index.html","hash":"572f64e8d9ff941d6fc426f62785296cb0b607a6","modified":1603936447975},{"_id":"public/实现一个简单的promise队列/index.html","hash":"1d0ff98f91554b6ea5c27d338e3982e0b4c9741e","modified":1603936447975},{"_id":"public/Node监视文件以实现热更新/index.html","hash":"24526e34149cdc0d8cf2d294c0d7ded19fc73475","modified":1603936447975},{"_id":"public/使用socket-io在页面上输出实时日志/index.html","hash":"f1cc2342ced1b6b4c21f0c6c31b6b1e8ed7ce836","modified":1603936447975},{"_id":"public/一次Node代码bug的追踪过程/index.html","hash":"868f5d2f0b2c41f2a747e12ffa68fa985de93fee","modified":1603936447975},{"_id":"public/Proxy实现Promise同步调用逻辑/index.html","hash":"1b87880d15fb58412f7af32a255ebb066cb0ac30","modified":1603936447975},{"_id":"public/Node处理字符编码相关经验/index.html","hash":"6f67385e2979cb508b16e45eec64c9466804d9f3","modified":1603936447975},{"_id":"public/Proxy对象仿Scala的通配符函数调用/index.html","hash":"f6b5a30a31ce7e3dbabffa466c26efc2f5da75b4","modified":1603936447975},{"_id":"public/NodeJS：Stream研究笔记/index.html","hash":"2b69707b1a6f4faa1301a0e4f0197316b1c78c81","modified":1603936447975},{"_id":"public/javascript模板渲染研究笔记（一）/index.html","hash":"3efbff50390756a250a2cad18760c8fafad4dcd3","modified":1603936447975},{"_id":"public/promise的日常应用/index.html","hash":"a3483182b65b34e2bd9be9723c2effa64330f31c","modified":1603936447975},{"_id":"public/img/elk_desc_1.png","hash":"e9ffb13dd89fdda54efc32dfaf0d4be5d6619819","modified":1603936447975},{"_id":"public/img/elk_desc_2.png","hash":"3f6db8afc37a5818c31d88b32ef1555ffe429b75","modified":1603936447975},{"_id":"public/img/node_cmd_1.jpg","hash":"319c3983a77a47284366bb59bfa21a1d9daf9efd","modified":1603936447975},{"_id":"public/img/webshell_1.png","hash":"cddefb4a22ba3fb4b81b6fa83cd66235802c4995","modified":1603936447975},{"_id":"public/favicon.ico","hash":"11c8f3376cd3d5c578f72b15265614b1c91c0921","modified":1603936447975},{"_id":"public/robots.txt","hash":"ef4399f3fc2e27fc7a15db3b2dafcc8a69ce9d44","modified":1603936447975},{"_id":"public/img/streamII-2.png","hash":"5f17ebece5b94457e7f90ad2a98ce6a7fb564710","modified":1603936447975},{"_id":"public/img/streamII-3.png","hash":"7675abe24e0530b13450c018e1da0e0cff80adde","modified":1603936447975},{"_id":"public/img/home-bg_bk2.jpg","hash":"c2c0806abebcf420976af95400da29e295d442da","modified":1603936447975},{"_id":"public/css/article.css","hash":"46d5fe4fbb9ca73bb930f2894cdd2e620c9b54df","modified":1603936447975},{"_id":"public/css/base.css","hash":"566335e15bd0b72a122a10056a172c736d6589b4","modified":1603936447975},{"_id":"public/css/mixins.css","hash":"b9e01ee658f10b7b381d209f384c1593237a965c","modified":1603936447975},{"_id":"public/css/style.css","hash":"302275783d059ba04d2bf4ae04fdd8ef8191e140","modified":1603936447975},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603936447975},{"_id":"public/img/home-bg.jpg","hash":"4291c55c57c96cb0a48d12073e621913fae761c7","modified":1603936447975},{"_id":"public/img/home-bg_bk1.jpg","hash":"3f106a5c8a1edb5c5dc865b8f293d58b5ef9d03e","modified":1603936447975},{"_id":"public/img/streamII-1.png","hash":"37c14b3db9c182330dc6f738de8d58d45f5b8a70","modified":1603936447975}],"Category":[{"name":"班门弄斧","_id":"ckgu6ckc4000zsou5edxzeswm"},{"name":"随笔","_id":"ckgu6ckcc0011sou52pixd9tu"},{"name":"神秘代码","_id":"ckgu6ckcf0013sou5emlr8ee1"},{"name":"亡羊补牢","_id":"ckgu6ckcr001xsou57w05c575"}],"Data":[],"Page":[],"Post":[{"title":"TypeScript 学习笔记（后端）","desc":"凡是能用js实现的，都应该用ts……","author":"ngtmuzi","date":"2020-10-06T05:22:22.000Z","_content":"\n说来惭愧，我是在换了工作之后才考虑在项目中完整使用 TypeScript（后简称 TS）的，因此接触时间并不算很长，加上网上介绍 TS 的文章应该是多如牛毛了，在这里总结一下自己的开发和学习经验，摘抄一些文档内容，权当记录参考。\n\n## Why TS?\n\n- 为 JS 补充上静态类型定义系统\n  - 在编码时就能发现类型和语法错误\n  - 更好的编辑器开发支持（尤其是 vscode）\n- 提供最新的 JS 特性支持（类似 babel）\n- 迎合 deno（？）\n\n## JS 迁移到 TS\n\n### 语法上的迁移\n\n单文件的 JS 到 TS 实际是很简单的，改扩展名，然后有问题解决问题即可，一般会碰到的常见问题会有：\n\n#### `require`引用的模块没有类型定义\n\n尝试查找有没有官方定义文件`npm i @types/xxx -D`，没有的话可以自己在`d.ts`内简单定义`declare module xxx;`，或者自己为其写一个完整的类型定义\n\n#### 变量/参数缺乏类型定义\n\n这就是应该手动补充的内容，如果结构较为复杂或者暂时还对 TS 掌握不够好，可以先简单用 `any` 占位\n\n### 项目上的迁移\n\n我一开始也在这个问题上纠结很久，总感觉项目中做部分迁移的话，会让其他开发人员困扰，但实际只要调整好`tsconfig.json`配置文件（比如将 JS 输出目录设为原目录，直接替换原文件），我们是可以做到不改动其他 JS 来逐步迁移的，最终执行的也还是 JS 文件，整体上不会有什么变化\n\n## 开发技巧\n\n比较简单的用法可以直接看官方文档，就不赘述了，下面说一些日常开发总结的\n\n### 善用工具类型\n\n| 语法                           | 简述&示例                                                                                                                     |\n| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------- |\n| `Partial<Type>`                | 将`Type`内所有属性改为可选的类型 <br> `Partial<{a:string}>` => `{a?:string}`                                                  |\n| `Required<Type>`               | 与 Partial 相反，将`Type`内所有属性改为必须类型 <br> `Partial<{a:string}>` => `{a?:string}`                                   |\n| `Readonly<Type>`               | 将`Type`内所有属性改为只读的类型 <br> `Readonly<{a:string}>` => `{readonly a:string}`                                         |\n| `Record<Keys,Type>`            | 构建一个键类型为`Keys`，值类型为`Type`的类型 <br> `Record<'a' 丨 'b',string>` => `{a:string,b:string}`                        |\n| `Pick<Type, Keys>`             | 根据`Keys`键列表构建`Type`的子集类型 <br> `Pick<{a:string,b:string}, 'a'>` => `{a:string}`                                    |\n| `Omit<Type, Keys>`             | 排除`Keys`键列表构建`Type`的子集类型 <br> `Omit<{a:string,b:string}, 'a'>` => `{b:string}`                                    |\n| `Exclude<Type, ExcludedUnion>` | 对联合类型`Type`做排除计算 <br> `Exclude<'a' 丨 'b' 丨 'c', 'a'>` => `'b' 丨 'c'`                                             |\n| `Extract<Type, Union>`         | 对联合类型`Type`做交集计算 <br> `Extract<'a' 丨 'b' 丨 'c', 'a' 丨 'd'>` => `'a'`                                             |\n| `NonNullable<Type>`            | 对联合类型`Type`排除空类型(`null`和`undefined`)，但实际上还是能赋空值 <br> `NonNullable<string 丨 null>` => `string`          |\n| `Parameters<Type>`             | 返回函数类型`Type`的参数类型元组 <br> `Parameters<(a: string, b: any) => any>` => `[a: string, b: any]`                       |\n| `ConstructorParameters<Type>`  | 返回类型`Type`的构造函数的参数类型元组 <br> `ConstructorParameters<typeof Date>` => `[value: string 丨 number 丨 Date]`       |\n| `ReturnType<Type>`             | 返回函数类型`Type`的返回值类型 <br> `ReturnType<typeof Number>` => `number`                                                   |\n| `InstanceType<Type>`           | 返回构造函数类型`Type`的实例类型 <br> `InstanceType<typeof Number>` => `Number`                                               |\n| `ThisParameterType<Type>`      | 返回函数类型`Type`的上下文`this`的类型，若未指定则返回`unknown`<br> `ThisParameterType<(this: string) => number>` => `string` |\n| `OmitThisParameter<Type>`      | 返回不包含`this`参数的`Type`函数类型<br> `OmitThisParameter<(this: string) => number>` => `() => number`                      |\n\n### 容易混淆的点\n\n#### 值和类型没有区分清楚\n\n这是一个比较常见的错误，我觉得还是要靠多写自己去总结，总结如下\n\n","source":"_drafts/TypeScript学习笔记.md","raw":"---\ntitle: TypeScript 学习笔记（后端）\ndesc: 凡是能用js实现的，都应该用ts……\nauthor: ngtmuzi\ncategory: 班门弄斧\ndate: 2020-10-06 13:22:22\ntags:\n  - TypeScript\n  - TS\n---\n\n说来惭愧，我是在换了工作之后才考虑在项目中完整使用 TypeScript（后简称 TS）的，因此接触时间并不算很长，加上网上介绍 TS 的文章应该是多如牛毛了，在这里总结一下自己的开发和学习经验，摘抄一些文档内容，权当记录参考。\n\n## Why TS?\n\n- 为 JS 补充上静态类型定义系统\n  - 在编码时就能发现类型和语法错误\n  - 更好的编辑器开发支持（尤其是 vscode）\n- 提供最新的 JS 特性支持（类似 babel）\n- 迎合 deno（？）\n\n## JS 迁移到 TS\n\n### 语法上的迁移\n\n单文件的 JS 到 TS 实际是很简单的，改扩展名，然后有问题解决问题即可，一般会碰到的常见问题会有：\n\n#### `require`引用的模块没有类型定义\n\n尝试查找有没有官方定义文件`npm i @types/xxx -D`，没有的话可以自己在`d.ts`内简单定义`declare module xxx;`，或者自己为其写一个完整的类型定义\n\n#### 变量/参数缺乏类型定义\n\n这就是应该手动补充的内容，如果结构较为复杂或者暂时还对 TS 掌握不够好，可以先简单用 `any` 占位\n\n### 项目上的迁移\n\n我一开始也在这个问题上纠结很久，总感觉项目中做部分迁移的话，会让其他开发人员困扰，但实际只要调整好`tsconfig.json`配置文件（比如将 JS 输出目录设为原目录，直接替换原文件），我们是可以做到不改动其他 JS 来逐步迁移的，最终执行的也还是 JS 文件，整体上不会有什么变化\n\n## 开发技巧\n\n比较简单的用法可以直接看官方文档，就不赘述了，下面说一些日常开发总结的\n\n### 善用工具类型\n\n| 语法                           | 简述&示例                                                                                                                     |\n| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------- |\n| `Partial<Type>`                | 将`Type`内所有属性改为可选的类型 <br> `Partial<{a:string}>` => `{a?:string}`                                                  |\n| `Required<Type>`               | 与 Partial 相反，将`Type`内所有属性改为必须类型 <br> `Partial<{a:string}>` => `{a?:string}`                                   |\n| `Readonly<Type>`               | 将`Type`内所有属性改为只读的类型 <br> `Readonly<{a:string}>` => `{readonly a:string}`                                         |\n| `Record<Keys,Type>`            | 构建一个键类型为`Keys`，值类型为`Type`的类型 <br> `Record<'a' 丨 'b',string>` => `{a:string,b:string}`                        |\n| `Pick<Type, Keys>`             | 根据`Keys`键列表构建`Type`的子集类型 <br> `Pick<{a:string,b:string}, 'a'>` => `{a:string}`                                    |\n| `Omit<Type, Keys>`             | 排除`Keys`键列表构建`Type`的子集类型 <br> `Omit<{a:string,b:string}, 'a'>` => `{b:string}`                                    |\n| `Exclude<Type, ExcludedUnion>` | 对联合类型`Type`做排除计算 <br> `Exclude<'a' 丨 'b' 丨 'c', 'a'>` => `'b' 丨 'c'`                                             |\n| `Extract<Type, Union>`         | 对联合类型`Type`做交集计算 <br> `Extract<'a' 丨 'b' 丨 'c', 'a' 丨 'd'>` => `'a'`                                             |\n| `NonNullable<Type>`            | 对联合类型`Type`排除空类型(`null`和`undefined`)，但实际上还是能赋空值 <br> `NonNullable<string 丨 null>` => `string`          |\n| `Parameters<Type>`             | 返回函数类型`Type`的参数类型元组 <br> `Parameters<(a: string, b: any) => any>` => `[a: string, b: any]`                       |\n| `ConstructorParameters<Type>`  | 返回类型`Type`的构造函数的参数类型元组 <br> `ConstructorParameters<typeof Date>` => `[value: string 丨 number 丨 Date]`       |\n| `ReturnType<Type>`             | 返回函数类型`Type`的返回值类型 <br> `ReturnType<typeof Number>` => `number`                                                   |\n| `InstanceType<Type>`           | 返回构造函数类型`Type`的实例类型 <br> `InstanceType<typeof Number>` => `Number`                                               |\n| `ThisParameterType<Type>`      | 返回函数类型`Type`的上下文`this`的类型，若未指定则返回`unknown`<br> `ThisParameterType<(this: string) => number>` => `string` |\n| `OmitThisParameter<Type>`      | 返回不包含`this`参数的`Type`函数类型<br> `OmitThisParameter<(this: string) => number>` => `() => number`                      |\n\n### 容易混淆的点\n\n#### 值和类型没有区分清楚\n\n这是一个比较常见的错误，我觉得还是要靠多写自己去总结，总结如下\n\n","slug":"TypeScript学习笔记","published":0,"updated":"2020-10-29T01:44:40.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckb70000sou561h2hyb2","content":"<p>说来惭愧，我是在换了工作之后才考虑在项目中完整使用 TypeScript（后简称 TS）的，因此接触时间并不算很长，加上网上介绍 TS 的文章应该是多如牛毛了，在这里总结一下自己的开发和学习经验，摘抄一些文档内容，权当记录参考。</p>\n<h2 id=\"Why-TS\"><a href=\"#Why-TS\" class=\"headerlink\" title=\"Why TS?\"></a>Why TS?</h2><ul>\n<li>为 JS 补充上静态类型定义系统<ul>\n<li>在编码时就能发现类型和语法错误</li>\n<li>更好的编辑器开发支持（尤其是 vscode）</li>\n</ul>\n</li>\n<li>提供最新的 JS 特性支持（类似 babel）</li>\n<li>迎合 deno（？）</li>\n</ul>\n<h2 id=\"JS-迁移到-TS\"><a href=\"#JS-迁移到-TS\" class=\"headerlink\" title=\"JS 迁移到 TS\"></a>JS 迁移到 TS</h2><h3 id=\"语法上的迁移\"><a href=\"#语法上的迁移\" class=\"headerlink\" title=\"语法上的迁移\"></a>语法上的迁移</h3><p>单文件的 JS 到 TS 实际是很简单的，改扩展名，然后有问题解决问题即可，一般会碰到的常见问题会有：</p>\n<h4 id=\"require引用的模块没有类型定义\"><a href=\"#require引用的模块没有类型定义\" class=\"headerlink\" title=\"require引用的模块没有类型定义\"></a><code>require</code>引用的模块没有类型定义</h4><p>尝试查找有没有官方定义文件<code>npm i @types/xxx -D</code>，没有的话可以自己在<code>d.ts</code>内简单定义<code>declare module xxx;</code>，或者自己为其写一个完整的类型定义</p>\n<h4 id=\"变量-参数缺乏类型定义\"><a href=\"#变量-参数缺乏类型定义\" class=\"headerlink\" title=\"变量/参数缺乏类型定义\"></a>变量/参数缺乏类型定义</h4><p>这就是应该手动补充的内容，如果结构较为复杂或者暂时还对 TS 掌握不够好，可以先简单用 <code>any</code> 占位</p>\n<h3 id=\"项目上的迁移\"><a href=\"#项目上的迁移\" class=\"headerlink\" title=\"项目上的迁移\"></a>项目上的迁移</h3><p>我一开始也在这个问题上纠结很久，总感觉项目中做部分迁移的话，会让其他开发人员困扰，但实际只要调整好<code>tsconfig.json</code>配置文件（比如将 JS 输出目录设为原目录，直接替换原文件），我们是可以做到不改动其他 JS 来逐步迁移的，最终执行的也还是 JS 文件，整体上不会有什么变化</p>\n<h2 id=\"开发技巧\"><a href=\"#开发技巧\" class=\"headerlink\" title=\"开发技巧\"></a>开发技巧</h2><p>比较简单的用法可以直接看官方文档，就不赘述了，下面说一些日常开发总结的</p>\n<h3 id=\"善用工具类型\"><a href=\"#善用工具类型\" class=\"headerlink\" title=\"善用工具类型\"></a>善用工具类型</h3><table>\n<thead>\n<tr>\n<th>语法</th>\n<th>简述&amp;示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Partial&lt;Type&gt;</code></td>\n<td>将<code>Type</code>内所有属性改为可选的类型 <br> <code>Partial&lt;&#123;a:string&#125;&gt;</code> =&gt; <code>&#123;a?:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Required&lt;Type&gt;</code></td>\n<td>与 Partial 相反，将<code>Type</code>内所有属性改为必须类型 <br> <code>Partial&lt;&#123;a:string&#125;&gt;</code> =&gt; <code>&#123;a?:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Readonly&lt;Type&gt;</code></td>\n<td>将<code>Type</code>内所有属性改为只读的类型 <br> <code>Readonly&lt;&#123;a:string&#125;&gt;</code> =&gt; <code>&#123;readonly a:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Record&lt;Keys,Type&gt;</code></td>\n<td>构建一个键类型为<code>Keys</code>，值类型为<code>Type</code>的类型 <br> <code>Record&lt;&#39;a&#39; 丨 &#39;b&#39;,string&gt;</code> =&gt; <code>&#123;a:string,b:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Pick&lt;Type, Keys&gt;</code></td>\n<td>根据<code>Keys</code>键列表构建<code>Type</code>的子集类型 <br> <code>Pick&lt;&#123;a:string,b:string&#125;, &#39;a&#39;&gt;</code> =&gt; <code>&#123;a:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Omit&lt;Type, Keys&gt;</code></td>\n<td>排除<code>Keys</code>键列表构建<code>Type</code>的子集类型 <br> <code>Omit&lt;&#123;a:string,b:string&#125;, &#39;a&#39;&gt;</code> =&gt; <code>&#123;b:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Exclude&lt;Type, ExcludedUnion&gt;</code></td>\n<td>对联合类型<code>Type</code>做排除计算 <br> <code>Exclude&lt;&#39;a&#39; 丨 &#39;b&#39; 丨 &#39;c&#39;, &#39;a&#39;&gt;</code> =&gt; <code>&#39;b&#39; 丨 &#39;c&#39;</code></td>\n</tr>\n<tr>\n<td><code>Extract&lt;Type, Union&gt;</code></td>\n<td>对联合类型<code>Type</code>做交集计算 <br> <code>Extract&lt;&#39;a&#39; 丨 &#39;b&#39; 丨 &#39;c&#39;, &#39;a&#39; 丨 &#39;d&#39;&gt;</code> =&gt; <code>&#39;a&#39;</code></td>\n</tr>\n<tr>\n<td><code>NonNullable&lt;Type&gt;</code></td>\n<td>对联合类型<code>Type</code>排除空类型(<code>null</code>和<code>undefined</code>)，但实际上还是能赋空值 <br> <code>NonNullable&lt;string 丨 null&gt;</code> =&gt; <code>string</code></td>\n</tr>\n<tr>\n<td><code>Parameters&lt;Type&gt;</code></td>\n<td>返回函数类型<code>Type</code>的参数类型元组 <br> <code>Parameters&lt;(a: string, b: any) =&gt; any&gt;</code> =&gt; <code>[a: string, b: any]</code></td>\n</tr>\n<tr>\n<td><code>ConstructorParameters&lt;Type&gt;</code></td>\n<td>返回类型<code>Type</code>的构造函数的参数类型元组 <br> <code>ConstructorParameters&lt;typeof Date&gt;</code> =&gt; <code>[value: string 丨 number 丨 Date]</code></td>\n</tr>\n<tr>\n<td><code>ReturnType&lt;Type&gt;</code></td>\n<td>返回函数类型<code>Type</code>的返回值类型 <br> <code>ReturnType&lt;typeof Number&gt;</code> =&gt; <code>number</code></td>\n</tr>\n<tr>\n<td><code>InstanceType&lt;Type&gt;</code></td>\n<td>返回构造函数类型<code>Type</code>的实例类型 <br> <code>InstanceType&lt;typeof Number&gt;</code> =&gt; <code>Number</code></td>\n</tr>\n<tr>\n<td><code>ThisParameterType&lt;Type&gt;</code></td>\n<td>返回函数类型<code>Type</code>的上下文<code>this</code>的类型，若未指定则返回<code>unknown</code><br> <code>ThisParameterType&lt;(this: string) =&gt; number&gt;</code> =&gt; <code>string</code></td>\n</tr>\n<tr>\n<td><code>OmitThisParameter&lt;Type&gt;</code></td>\n<td>返回不包含<code>this</code>参数的<code>Type</code>函数类型<br> <code>OmitThisParameter&lt;(this: string) =&gt; number&gt;</code> =&gt; <code>() =&gt; number</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"容易混淆的点\"><a href=\"#容易混淆的点\" class=\"headerlink\" title=\"容易混淆的点\"></a>容易混淆的点</h3><h4 id=\"值和类型没有区分清楚\"><a href=\"#值和类型没有区分清楚\" class=\"headerlink\" title=\"值和类型没有区分清楚\"></a>值和类型没有区分清楚</h4><p>这是一个比较常见的错误，我觉得还是要靠多写自己去总结，总结如下</p>\n","site":{"data":{}},"excerpt":"","more":"<p>说来惭愧，我是在换了工作之后才考虑在项目中完整使用 TypeScript（后简称 TS）的，因此接触时间并不算很长，加上网上介绍 TS 的文章应该是多如牛毛了，在这里总结一下自己的开发和学习经验，摘抄一些文档内容，权当记录参考。</p>\n<h2 id=\"Why-TS\"><a href=\"#Why-TS\" class=\"headerlink\" title=\"Why TS?\"></a>Why TS?</h2><ul>\n<li>为 JS 补充上静态类型定义系统<ul>\n<li>在编码时就能发现类型和语法错误</li>\n<li>更好的编辑器开发支持（尤其是 vscode）</li>\n</ul>\n</li>\n<li>提供最新的 JS 特性支持（类似 babel）</li>\n<li>迎合 deno（？）</li>\n</ul>\n<h2 id=\"JS-迁移到-TS\"><a href=\"#JS-迁移到-TS\" class=\"headerlink\" title=\"JS 迁移到 TS\"></a>JS 迁移到 TS</h2><h3 id=\"语法上的迁移\"><a href=\"#语法上的迁移\" class=\"headerlink\" title=\"语法上的迁移\"></a>语法上的迁移</h3><p>单文件的 JS 到 TS 实际是很简单的，改扩展名，然后有问题解决问题即可，一般会碰到的常见问题会有：</p>\n<h4 id=\"require引用的模块没有类型定义\"><a href=\"#require引用的模块没有类型定义\" class=\"headerlink\" title=\"require引用的模块没有类型定义\"></a><code>require</code>引用的模块没有类型定义</h4><p>尝试查找有没有官方定义文件<code>npm i @types/xxx -D</code>，没有的话可以自己在<code>d.ts</code>内简单定义<code>declare module xxx;</code>，或者自己为其写一个完整的类型定义</p>\n<h4 id=\"变量-参数缺乏类型定义\"><a href=\"#变量-参数缺乏类型定义\" class=\"headerlink\" title=\"变量/参数缺乏类型定义\"></a>变量/参数缺乏类型定义</h4><p>这就是应该手动补充的内容，如果结构较为复杂或者暂时还对 TS 掌握不够好，可以先简单用 <code>any</code> 占位</p>\n<h3 id=\"项目上的迁移\"><a href=\"#项目上的迁移\" class=\"headerlink\" title=\"项目上的迁移\"></a>项目上的迁移</h3><p>我一开始也在这个问题上纠结很久，总感觉项目中做部分迁移的话，会让其他开发人员困扰，但实际只要调整好<code>tsconfig.json</code>配置文件（比如将 JS 输出目录设为原目录，直接替换原文件），我们是可以做到不改动其他 JS 来逐步迁移的，最终执行的也还是 JS 文件，整体上不会有什么变化</p>\n<h2 id=\"开发技巧\"><a href=\"#开发技巧\" class=\"headerlink\" title=\"开发技巧\"></a>开发技巧</h2><p>比较简单的用法可以直接看官方文档，就不赘述了，下面说一些日常开发总结的</p>\n<h3 id=\"善用工具类型\"><a href=\"#善用工具类型\" class=\"headerlink\" title=\"善用工具类型\"></a>善用工具类型</h3><table>\n<thead>\n<tr>\n<th>语法</th>\n<th>简述&amp;示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Partial&lt;Type&gt;</code></td>\n<td>将<code>Type</code>内所有属性改为可选的类型 <br> <code>Partial&lt;&#123;a:string&#125;&gt;</code> =&gt; <code>&#123;a?:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Required&lt;Type&gt;</code></td>\n<td>与 Partial 相反，将<code>Type</code>内所有属性改为必须类型 <br> <code>Partial&lt;&#123;a:string&#125;&gt;</code> =&gt; <code>&#123;a?:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Readonly&lt;Type&gt;</code></td>\n<td>将<code>Type</code>内所有属性改为只读的类型 <br> <code>Readonly&lt;&#123;a:string&#125;&gt;</code> =&gt; <code>&#123;readonly a:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Record&lt;Keys,Type&gt;</code></td>\n<td>构建一个键类型为<code>Keys</code>，值类型为<code>Type</code>的类型 <br> <code>Record&lt;&#39;a&#39; 丨 &#39;b&#39;,string&gt;</code> =&gt; <code>&#123;a:string,b:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Pick&lt;Type, Keys&gt;</code></td>\n<td>根据<code>Keys</code>键列表构建<code>Type</code>的子集类型 <br> <code>Pick&lt;&#123;a:string,b:string&#125;, &#39;a&#39;&gt;</code> =&gt; <code>&#123;a:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Omit&lt;Type, Keys&gt;</code></td>\n<td>排除<code>Keys</code>键列表构建<code>Type</code>的子集类型 <br> <code>Omit&lt;&#123;a:string,b:string&#125;, &#39;a&#39;&gt;</code> =&gt; <code>&#123;b:string&#125;</code></td>\n</tr>\n<tr>\n<td><code>Exclude&lt;Type, ExcludedUnion&gt;</code></td>\n<td>对联合类型<code>Type</code>做排除计算 <br> <code>Exclude&lt;&#39;a&#39; 丨 &#39;b&#39; 丨 &#39;c&#39;, &#39;a&#39;&gt;</code> =&gt; <code>&#39;b&#39; 丨 &#39;c&#39;</code></td>\n</tr>\n<tr>\n<td><code>Extract&lt;Type, Union&gt;</code></td>\n<td>对联合类型<code>Type</code>做交集计算 <br> <code>Extract&lt;&#39;a&#39; 丨 &#39;b&#39; 丨 &#39;c&#39;, &#39;a&#39; 丨 &#39;d&#39;&gt;</code> =&gt; <code>&#39;a&#39;</code></td>\n</tr>\n<tr>\n<td><code>NonNullable&lt;Type&gt;</code></td>\n<td>对联合类型<code>Type</code>排除空类型(<code>null</code>和<code>undefined</code>)，但实际上还是能赋空值 <br> <code>NonNullable&lt;string 丨 null&gt;</code> =&gt; <code>string</code></td>\n</tr>\n<tr>\n<td><code>Parameters&lt;Type&gt;</code></td>\n<td>返回函数类型<code>Type</code>的参数类型元组 <br> <code>Parameters&lt;(a: string, b: any) =&gt; any&gt;</code> =&gt; <code>[a: string, b: any]</code></td>\n</tr>\n<tr>\n<td><code>ConstructorParameters&lt;Type&gt;</code></td>\n<td>返回类型<code>Type</code>的构造函数的参数类型元组 <br> <code>ConstructorParameters&lt;typeof Date&gt;</code> =&gt; <code>[value: string 丨 number 丨 Date]</code></td>\n</tr>\n<tr>\n<td><code>ReturnType&lt;Type&gt;</code></td>\n<td>返回函数类型<code>Type</code>的返回值类型 <br> <code>ReturnType&lt;typeof Number&gt;</code> =&gt; <code>number</code></td>\n</tr>\n<tr>\n<td><code>InstanceType&lt;Type&gt;</code></td>\n<td>返回构造函数类型<code>Type</code>的实例类型 <br> <code>InstanceType&lt;typeof Number&gt;</code> =&gt; <code>Number</code></td>\n</tr>\n<tr>\n<td><code>ThisParameterType&lt;Type&gt;</code></td>\n<td>返回函数类型<code>Type</code>的上下文<code>this</code>的类型，若未指定则返回<code>unknown</code><br> <code>ThisParameterType&lt;(this: string) =&gt; number&gt;</code> =&gt; <code>string</code></td>\n</tr>\n<tr>\n<td><code>OmitThisParameter&lt;Type&gt;</code></td>\n<td>返回不包含<code>this</code>参数的<code>Type</code>函数类型<br> <code>OmitThisParameter&lt;(this: string) =&gt; number&gt;</code> =&gt; <code>() =&gt; number</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"容易混淆的点\"><a href=\"#容易混淆的点\" class=\"headerlink\" title=\"容易混淆的点\"></a>容易混淆的点</h3><h4 id=\"值和类型没有区分清楚\"><a href=\"#值和类型没有区分清楚\" class=\"headerlink\" title=\"值和类型没有区分清楚\"></a>值和类型没有区分清楚</h4><p>这是一个比较常见的错误，我觉得还是要靠多写自己去总结，总结如下</p>\n"},{"title":"2017年终小结","date":"2018-01-08T13:11:33.000Z","author":"ngtmuzi","_content":"2017年刚开始的时候写年度目标，是每月至少一篇博客，结果到最后还是没坚持下来，但随便找些东西充数，好像也不好\n\n主要是最后几个月开始把一个完全无关的项目硬合并到原先在维护的项目里，我开始庆幸原项目被我重构了2次，框架封装得还算可以，因此接入新的功能也不难\n\n难点在于协调别人写的代码，表面上说遵守你的开发规范，但提交代码总是一堆的warn+error，还要图方便弄出一些“封装函数”，把抛出的错误都内部消化\n\n不过工作大概都是这样吧，习惯就好了\n\n## 工作小结\n\n### JS方面的\n\n* 自己出于好玩写的一个路由模块在`express`上用顺手了，也在`koa`上实现了一遍，觉得还可以，有时间再整理下放github上\n* 前后端基本都改用async/await写法了，效率比之前高了不少\n* VUE2抽空把官方的文档看完了，试了一下几个前端的VUE框架/脚手架，还挺好玩的，不过webpack还是没仔细研究\n\n### 其他方面的\n\n* docker年中的时候研究了一阵，不过正式环境没用上\n* rabbitmq在正式服炸了几次，难受，不过升级了版本之后就没出现了，另外那个Shovel方式来做集群的方式很好用，做cluster集群炸过一次有阴影了\n* redis今年在正式服搭了个分片+主从的集群，步骤还算简单但是要跑起来命令行工具挺麻烦\n* mongodb今年在正式服搭了复制集，自动切换主从没出过问题，还行\n* elk今年用来做了日志收集分析，挺好用也挺强大的工具，不过挺吃硬件资源\n* 研究了一下区块链，不过感觉虚拟货币交易的精髓应该是UTXO而不是一直在鼓吹的区块链\n* iptables那一套还是不懂\n* 变成老油条了\n\n## 生活小结\n\n* 搬了个宿舍可以拉窗帘睡觉了\n* 斗鱼房间解封之后晚上可以开直播了\n* 想回家\n\n## 关于2018\n\n本命年已经过了不过没发生什么改变，也过了《九局下半》的年纪，感觉已经三振出局了\n","source":"_posts/2017年终小结.md","raw":"---\ntitle: 2017年终小结  \ndate: 2018-01-08 21:11:33\ntags: \n- 总结\nauthor: ngtmuzi  \ncategory: 随笔\n---\n2017年刚开始的时候写年度目标，是每月至少一篇博客，结果到最后还是没坚持下来，但随便找些东西充数，好像也不好\n\n主要是最后几个月开始把一个完全无关的项目硬合并到原先在维护的项目里，我开始庆幸原项目被我重构了2次，框架封装得还算可以，因此接入新的功能也不难\n\n难点在于协调别人写的代码，表面上说遵守你的开发规范，但提交代码总是一堆的warn+error，还要图方便弄出一些“封装函数”，把抛出的错误都内部消化\n\n不过工作大概都是这样吧，习惯就好了\n\n## 工作小结\n\n### JS方面的\n\n* 自己出于好玩写的一个路由模块在`express`上用顺手了，也在`koa`上实现了一遍，觉得还可以，有时间再整理下放github上\n* 前后端基本都改用async/await写法了，效率比之前高了不少\n* VUE2抽空把官方的文档看完了，试了一下几个前端的VUE框架/脚手架，还挺好玩的，不过webpack还是没仔细研究\n\n### 其他方面的\n\n* docker年中的时候研究了一阵，不过正式环境没用上\n* rabbitmq在正式服炸了几次，难受，不过升级了版本之后就没出现了，另外那个Shovel方式来做集群的方式很好用，做cluster集群炸过一次有阴影了\n* redis今年在正式服搭了个分片+主从的集群，步骤还算简单但是要跑起来命令行工具挺麻烦\n* mongodb今年在正式服搭了复制集，自动切换主从没出过问题，还行\n* elk今年用来做了日志收集分析，挺好用也挺强大的工具，不过挺吃硬件资源\n* 研究了一下区块链，不过感觉虚拟货币交易的精髓应该是UTXO而不是一直在鼓吹的区块链\n* iptables那一套还是不懂\n* 变成老油条了\n\n## 生活小结\n\n* 搬了个宿舍可以拉窗帘睡觉了\n* 斗鱼房间解封之后晚上可以开直播了\n* 想回家\n\n## 关于2018\n\n本命年已经过了不过没发生什么改变，也过了《九局下半》的年纪，感觉已经三振出局了\n","slug":"2017年终小结","published":1,"updated":"2020-06-17T10:26:40.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbc0001sou56ebc5ce4","content":"<p>2017年刚开始的时候写年度目标，是每月至少一篇博客，结果到最后还是没坚持下来，但随便找些东西充数，好像也不好</p>\n<p>主要是最后几个月开始把一个完全无关的项目硬合并到原先在维护的项目里，我开始庆幸原项目被我重构了2次，框架封装得还算可以，因此接入新的功能也不难</p>\n<p>难点在于协调别人写的代码，表面上说遵守你的开发规范，但提交代码总是一堆的warn+error，还要图方便弄出一些“封装函数”，把抛出的错误都内部消化</p>\n<p>不过工作大概都是这样吧，习惯就好了</p>\n<h2 id=\"工作小结\"><a href=\"#工作小结\" class=\"headerlink\" title=\"工作小结\"></a>工作小结</h2><h3 id=\"JS方面的\"><a href=\"#JS方面的\" class=\"headerlink\" title=\"JS方面的\"></a>JS方面的</h3><ul>\n<li>自己出于好玩写的一个路由模块在<code>express</code>上用顺手了，也在<code>koa</code>上实现了一遍，觉得还可以，有时间再整理下放github上</li>\n<li>前后端基本都改用async/await写法了，效率比之前高了不少</li>\n<li>VUE2抽空把官方的文档看完了，试了一下几个前端的VUE框架/脚手架，还挺好玩的，不过webpack还是没仔细研究</li>\n</ul>\n<h3 id=\"其他方面的\"><a href=\"#其他方面的\" class=\"headerlink\" title=\"其他方面的\"></a>其他方面的</h3><ul>\n<li>docker年中的时候研究了一阵，不过正式环境没用上</li>\n<li>rabbitmq在正式服炸了几次，难受，不过升级了版本之后就没出现了，另外那个Shovel方式来做集群的方式很好用，做cluster集群炸过一次有阴影了</li>\n<li>redis今年在正式服搭了个分片+主从的集群，步骤还算简单但是要跑起来命令行工具挺麻烦</li>\n<li>mongodb今年在正式服搭了复制集，自动切换主从没出过问题，还行</li>\n<li>elk今年用来做了日志收集分析，挺好用也挺强大的工具，不过挺吃硬件资源</li>\n<li>研究了一下区块链，不过感觉虚拟货币交易的精髓应该是UTXO而不是一直在鼓吹的区块链</li>\n<li>iptables那一套还是不懂</li>\n<li>变成老油条了</li>\n</ul>\n<h2 id=\"生活小结\"><a href=\"#生活小结\" class=\"headerlink\" title=\"生活小结\"></a>生活小结</h2><ul>\n<li>搬了个宿舍可以拉窗帘睡觉了</li>\n<li>斗鱼房间解封之后晚上可以开直播了</li>\n<li>想回家</li>\n</ul>\n<h2 id=\"关于2018\"><a href=\"#关于2018\" class=\"headerlink\" title=\"关于2018\"></a>关于2018</h2><p>本命年已经过了不过没发生什么改变，也过了《九局下半》的年纪，感觉已经三振出局了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2017年刚开始的时候写年度目标，是每月至少一篇博客，结果到最后还是没坚持下来，但随便找些东西充数，好像也不好</p>\n<p>主要是最后几个月开始把一个完全无关的项目硬合并到原先在维护的项目里，我开始庆幸原项目被我重构了2次，框架封装得还算可以，因此接入新的功能也不难</p>\n<p>难点在于协调别人写的代码，表面上说遵守你的开发规范，但提交代码总是一堆的warn+error，还要图方便弄出一些“封装函数”，把抛出的错误都内部消化</p>\n<p>不过工作大概都是这样吧，习惯就好了</p>\n<h2 id=\"工作小结\"><a href=\"#工作小结\" class=\"headerlink\" title=\"工作小结\"></a>工作小结</h2><h3 id=\"JS方面的\"><a href=\"#JS方面的\" class=\"headerlink\" title=\"JS方面的\"></a>JS方面的</h3><ul>\n<li>自己出于好玩写的一个路由模块在<code>express</code>上用顺手了，也在<code>koa</code>上实现了一遍，觉得还可以，有时间再整理下放github上</li>\n<li>前后端基本都改用async/await写法了，效率比之前高了不少</li>\n<li>VUE2抽空把官方的文档看完了，试了一下几个前端的VUE框架/脚手架，还挺好玩的，不过webpack还是没仔细研究</li>\n</ul>\n<h3 id=\"其他方面的\"><a href=\"#其他方面的\" class=\"headerlink\" title=\"其他方面的\"></a>其他方面的</h3><ul>\n<li>docker年中的时候研究了一阵，不过正式环境没用上</li>\n<li>rabbitmq在正式服炸了几次，难受，不过升级了版本之后就没出现了，另外那个Shovel方式来做集群的方式很好用，做cluster集群炸过一次有阴影了</li>\n<li>redis今年在正式服搭了个分片+主从的集群，步骤还算简单但是要跑起来命令行工具挺麻烦</li>\n<li>mongodb今年在正式服搭了复制集，自动切换主从没出过问题，还行</li>\n<li>elk今年用来做了日志收集分析，挺好用也挺强大的工具，不过挺吃硬件资源</li>\n<li>研究了一下区块链，不过感觉虚拟货币交易的精髓应该是UTXO而不是一直在鼓吹的区块链</li>\n<li>iptables那一套还是不懂</li>\n<li>变成老油条了</li>\n</ul>\n<h2 id=\"生活小结\"><a href=\"#生活小结\" class=\"headerlink\" title=\"生活小结\"></a>生活小结</h2><ul>\n<li>搬了个宿舍可以拉窗帘睡觉了</li>\n<li>斗鱼房间解封之后晚上可以开直播了</li>\n<li>想回家</li>\n</ul>\n<h2 id=\"关于2018\"><a href=\"#关于2018\" class=\"headerlink\" title=\"关于2018\"></a>关于2018</h2><p>本命年已经过了不过没发生什么改变，也过了《九局下半》的年纪，感觉已经三振出局了</p>\n"},{"title":"NodeJS:Stream研究笔记","desc":"相信学过nodejs的人都必然会接触到nodejs中的流（stream）","date":"2016-02-15T13:00:21.199Z","author":"ngtmuzi","_content":"\n相信学过`nodejs`的人都必然会接触到`nodejs`中的流（`stream`），不提从`fs`、`net`、`http`这些基础模块，到`express`、`request`、`mongodb`这些常用模块，处处都有流的身影。在初学时我也曾被`pipe`方法的强大特性吓到，参看`request`的文档：\n\n```javascript\nrequest('http://google.com/doodle.png').pipe(fs.createWriteStream('doodle.png'));\n\nfs.createReadStream('file.json').pipe(request.put('http://mysite.com/obj.json'));\n\nrequest.get('http://google.com/img.png').pipe(request.put('http://mysite.com/img.png'));\n```\n\n从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。\n\n\n流在`nodejs`内部提供的方法都是事件式的，需要用`on`方法将我们的回调函数挂在相应的事件上，如`close`、`end`、`data`、`drain`等，这种形式与`nodejs`异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。\n\n\n流的`pipe`方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个`pipe`就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现`pipe`也不是很复杂，主要的业务代码如下\n\n```javascript\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n};\n```\n\n就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。\n\n---\n\n以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：\n\n* `net.createServer`方法接收一个函数，用于获得`socket`套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次`data`事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……\n\n* `http`也是跟流打交道很多的模块，比如`http.request`函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过`error`事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。\n\n```javascript\nvar req = http.request('http://baidu.com', function (res) {\n  console.log(res.headers);     //调用回调的时候，已经获取到了http头\n  res.on('data', console.log);  //读http正文（表单部分存储于此）\n});\nreq.end('hello');  //只有请求流写完之后，才后真正进行http请求\n````\n* fs模块的文件流有一个很实用的特性，那就是指定读写位置，如`fs.createReadStream`函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，`express`模块中负责静态文件服务的`send`模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句\n```javascript\n// pipe\nvar stream = fs.createReadStream(path, options)\nstream.pipe(res);\n```\n* 而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是`options`中的`flags`参数，当取默认值'w'时，它每次都会重写文件，而改成'r+'，就不会将文件清空。\n\n* `mongodb`的node模块为配合`GridFS`功能，也使用了流的特性来进行文件读写，参见`GridFSBucket`类。\n\n\n在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用`on('error')`来自行捕获，之后就可以愉快地使用各种`pipe`了~","source":"_posts/NodeJS：Stream研究笔记.md","raw":"---\ntitle: NodeJS:Stream研究笔记    \ndesc: 相信学过nodejs的人都必然会接触到nodejs中的流（stream） \ndate: 2016-2-15 21:00:21.199\ntags: \n- nodejs\n- stream  \nauthor: ngtmuzi  \ncategory: 神秘代码\n---\n\n相信学过`nodejs`的人都必然会接触到`nodejs`中的流（`stream`），不提从`fs`、`net`、`http`这些基础模块，到`express`、`request`、`mongodb`这些常用模块，处处都有流的身影。在初学时我也曾被`pipe`方法的强大特性吓到，参看`request`的文档：\n\n```javascript\nrequest('http://google.com/doodle.png').pipe(fs.createWriteStream('doodle.png'));\n\nfs.createReadStream('file.json').pipe(request.put('http://mysite.com/obj.json'));\n\nrequest.get('http://google.com/img.png').pipe(request.put('http://mysite.com/img.png'));\n```\n\n从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。\n\n\n流在`nodejs`内部提供的方法都是事件式的，需要用`on`方法将我们的回调函数挂在相应的事件上，如`close`、`end`、`data`、`drain`等，这种形式与`nodejs`异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。\n\n\n流的`pipe`方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个`pipe`就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现`pipe`也不是很复杂，主要的业务代码如下\n\n```javascript\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n};\n```\n\n就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。\n\n---\n\n以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：\n\n* `net.createServer`方法接收一个函数，用于获得`socket`套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次`data`事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……\n\n* `http`也是跟流打交道很多的模块，比如`http.request`函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过`error`事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。\n\n```javascript\nvar req = http.request('http://baidu.com', function (res) {\n  console.log(res.headers);     //调用回调的时候，已经获取到了http头\n  res.on('data', console.log);  //读http正文（表单部分存储于此）\n});\nreq.end('hello');  //只有请求流写完之后，才后真正进行http请求\n````\n* fs模块的文件流有一个很实用的特性，那就是指定读写位置，如`fs.createReadStream`函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，`express`模块中负责静态文件服务的`send`模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句\n```javascript\n// pipe\nvar stream = fs.createReadStream(path, options)\nstream.pipe(res);\n```\n* 而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是`options`中的`flags`参数，当取默认值'w'时，它每次都会重写文件，而改成'r+'，就不会将文件清空。\n\n* `mongodb`的node模块为配合`GridFS`功能，也使用了流的特性来进行文件读写，参见`GridFSBucket`类。\n\n\n在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用`on('error')`来自行捕获，之后就可以愉快地使用各种`pipe`了~","slug":"NodeJS：Stream研究笔记","published":1,"updated":"2020-06-17T10:26:40.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbd0002sou51dxqdwxu","content":"<p>相信学过<code>nodejs</code>的人都必然会接触到<code>nodejs</code>中的流（<code>stream</code>），不提从<code>fs</code>、<code>net</code>、<code>http</code>这些基础模块，到<code>express</code>、<code>request</code>、<code>mongodb</code>这些常用模块，处处都有流的身影。在初学时我也曾被<code>pipe</code>方法的强大特性吓到，参看<code>request</code>的文档：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request(<span class=\"string\">&#x27;http://google.com/doodle.png&#x27;</span>).pipe(fs.createWriteStream(<span class=\"string\">&#x27;doodle.png&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">fs.createReadStream(<span class=\"string\">&#x27;file.json&#x27;</span>).pipe(request.put(<span class=\"string\">&#x27;http://mysite.com/obj.json&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">request.get(<span class=\"string\">&#x27;http://google.com/img.png&#x27;</span>).pipe(request.put(<span class=\"string\">&#x27;http://mysite.com/img.png&#x27;</span>));</span><br></pre></td></tr></table></figure>\n<p>从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。</p>\n<p>流在<code>nodejs</code>内部提供的方法都是事件式的，需要用<code>on</code>方法将我们的回调函数挂在相应的事件上，如<code>close</code>、<code>end</code>、<code>data</code>、<code>drain</code>等，这种形式与<code>nodejs</code>异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。</p>\n<p>流的<code>pipe</code>方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个<code>pipe</code>就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现<code>pipe</code>也不是很复杂，主要的业务代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.prototype.pipe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dest, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> source = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondata</span>(<span class=\"params\">chunk</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dest.writable) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === dest.write(chunk) &amp;&amp; source.pause) &#123;</span><br><span class=\"line\">        source.pause();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  source.on(<span class=\"string\">&#x27;data&#x27;</span>, ondata);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondrain</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (source.readable &amp;&amp; source.resume) &#123;</span><br><span class=\"line\">      source.resume();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dest.on(<span class=\"string\">&#x27;drain&#x27;</span>, ondrain);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。</p>\n<hr>\n<p>以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：</p>\n<ul>\n<li><p><code>net.createServer</code>方法接收一个函数，用于获得<code>socket</code>套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次<code>data</code>事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……</p>\n</li>\n<li><p><code>http</code>也是跟流打交道很多的模块，比如<code>http.request</code>函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过<code>error</code>事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> req = http.request(<span class=\"string\">&#x27;http://baidu.com&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.headers);     <span class=\"comment\">//调用回调的时候，已经获取到了http头</span></span><br><span class=\"line\">  res.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"built_in\">console</span>.log);  <span class=\"comment\">//读http正文（表单部分存储于此）</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">req.end(<span class=\"string\">&#x27;hello&#x27;</span>);  <span class=\"comment\">//只有请求流写完之后，才后真正进行http请求</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">``</span></span><br><span class=\"line\">* fs模块的文件流有一个很实用的特性，那就是指定读写位置，如<span class=\"string\">`fs.createReadStream`</span>函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，<span class=\"string\">`express`</span>模块中负责静态文件服务的<span class=\"string\">`send`</span>模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`javascript</span></span><br><span class=\"line\"><span class=\"string\">// pipe</span></span><br><span class=\"line\"><span class=\"string\">var stream = fs.createReadStream(path, options)</span></span><br><span class=\"line\"><span class=\"string\">stream.pipe(res);</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是<code>options</code>中的<code>flags</code>参数，当取默认值’w’时，它每次都会重写文件，而改成’r+’，就不会将文件清空。</p>\n</li>\n<li><p><code>mongodb</code>的node模块为配合<code>GridFS</code>功能，也使用了流的特性来进行文件读写，参见<code>GridFSBucket</code>类。</p>\n</li>\n</ul>\n<p>在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用<code>on(&#39;error&#39;)</code>来自行捕获，之后就可以愉快地使用各种<code>pipe</code>了~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信学过<code>nodejs</code>的人都必然会接触到<code>nodejs</code>中的流（<code>stream</code>），不提从<code>fs</code>、<code>net</code>、<code>http</code>这些基础模块，到<code>express</code>、<code>request</code>、<code>mongodb</code>这些常用模块，处处都有流的身影。在初学时我也曾被<code>pipe</code>方法的强大特性吓到，参看<code>request</code>的文档：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request(<span class=\"string\">&#x27;http://google.com/doodle.png&#x27;</span>).pipe(fs.createWriteStream(<span class=\"string\">&#x27;doodle.png&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">fs.createReadStream(<span class=\"string\">&#x27;file.json&#x27;</span>).pipe(request.put(<span class=\"string\">&#x27;http://mysite.com/obj.json&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">request.get(<span class=\"string\">&#x27;http://google.com/img.png&#x27;</span>).pipe(request.put(<span class=\"string\">&#x27;http://mysite.com/img.png&#x27;</span>));</span><br></pre></td></tr></table></figure>\n<p>从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。</p>\n<p>流在<code>nodejs</code>内部提供的方法都是事件式的，需要用<code>on</code>方法将我们的回调函数挂在相应的事件上，如<code>close</code>、<code>end</code>、<code>data</code>、<code>drain</code>等，这种形式与<code>nodejs</code>异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。</p>\n<p>流的<code>pipe</code>方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个<code>pipe</code>就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现<code>pipe</code>也不是很复杂，主要的业务代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.prototype.pipe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dest, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> source = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondata</span>(<span class=\"params\">chunk</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dest.writable) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === dest.write(chunk) &amp;&amp; source.pause) &#123;</span><br><span class=\"line\">        source.pause();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  source.on(<span class=\"string\">&#x27;data&#x27;</span>, ondata);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondrain</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (source.readable &amp;&amp; source.resume) &#123;</span><br><span class=\"line\">      source.resume();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dest.on(<span class=\"string\">&#x27;drain&#x27;</span>, ondrain);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。</p>\n<hr>\n<p>以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：</p>\n<ul>\n<li><p><code>net.createServer</code>方法接收一个函数，用于获得<code>socket</code>套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次<code>data</code>事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……</p>\n</li>\n<li><p><code>http</code>也是跟流打交道很多的模块，比如<code>http.request</code>函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过<code>error</code>事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> req = http.request(<span class=\"string\">&#x27;http://baidu.com&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.headers);     <span class=\"comment\">//调用回调的时候，已经获取到了http头</span></span><br><span class=\"line\">  res.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"built_in\">console</span>.log);  <span class=\"comment\">//读http正文（表单部分存储于此）</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">req.end(<span class=\"string\">&#x27;hello&#x27;</span>);  <span class=\"comment\">//只有请求流写完之后，才后真正进行http请求</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">``</span></span><br><span class=\"line\">* fs模块的文件流有一个很实用的特性，那就是指定读写位置，如<span class=\"string\">`fs.createReadStream`</span>函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，<span class=\"string\">`express`</span>模块中负责静态文件服务的<span class=\"string\">`send`</span>模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`javascript</span></span><br><span class=\"line\"><span class=\"string\">// pipe</span></span><br><span class=\"line\"><span class=\"string\">var stream = fs.createReadStream(path, options)</span></span><br><span class=\"line\"><span class=\"string\">stream.pipe(res);</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是<code>options</code>中的<code>flags</code>参数，当取默认值’w’时，它每次都会重写文件，而改成’r+’，就不会将文件清空。</p>\n</li>\n<li><p><code>mongodb</code>的node模块为配合<code>GridFS</code>功能，也使用了流的特性来进行文件读写，参见<code>GridFSBucket</code>类。</p>\n</li>\n</ul>\n<p>在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用<code>on(&#39;error&#39;)</code>来自行捕获，之后就可以愉快地使用各种<code>pipe</code>了~</p>\n"},{"title":"NodeJS：Stream研究笔记II","desc":"主要是Node源码阅读理解","author":"ngtmuzi","date":"2020-04-05T12:19:39.000Z","_content":"几年前写的[研究笔记](/NodeJS：Stream研究笔记)现在回头看感觉全是在抄官方文档里的东西，近期真正在写stream的时候又发现其实根本没算了解，都没自己实现过读流和写流，于是补充一篇。\n\n以下内容主要来自官方文档及自行阅读源码，较多内部逻辑及细节已被省略，只抽象其主干思想：\n\n## Readable可读流\n\n> [官方文档-实现一个可读流](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_readable_stream)\n\n* 所有可读流都必须提供`_read()`方法的实现，以从基础资源中获取数据。\n* 当调用`_read()`时，如果资源中已有可用数据，则应该使用`this.push(dataChunk)`将数据加入到读流的缓冲区队列中，然后`_read()`应该持续以上操作直到`push()`返回`false`。\n\n![](/img/streamII-1.png)\n\n从结论来说，如果你不调用`push()`，可读流永远不会产生数据。\n\n关于可读流的两种读取模式在这里就不再赘述了，有趣的是可读流内部的缓冲区`buffer`并不是一个`Buffer`对象（因为流要支持对象模式，不能只支持二进制数据）或者`Array`，而是一个自己实现的单链表，带头尾指针，这里应该是考虑方便缓冲区的前后读写，并且不需要使用数组的索引功能。\n\n`push()`函数还提到说当它返回`false`时就不应该继续写入了，其实代码内部中只是返回了缓冲区与`highWaterMark`的大小对比，其实并不会抛弃超过的数据，所以自己实现时多写一些内容进去是没问题的（比如一次批量拿到了N个数据，总不能写一半丢一半）。\n\n## Writable可写流\n\n> [官方文档-实现一个可写流](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_writable_stream)\n\n* 所有可写流实现必须提供`_write`方法，以将数据发送到基础资源\n* 必须调用回调方法来表示本次写入的成功或失败\n* 在调用`_write()`和回调被调用之间如果有新的`write()`调用，则这些数据会先被放入缓冲区。调用回调时，流可能会发出“`drain`事件。\n\n![](/img/streamII-2.png)\n\n可写流相对比可读流逻辑简单一点，就是包裹一下用户自定义的写方法，并且做缓冲队列，从这里我们能知道很重要的一点：可写流的`write()`是串行调用的，不支持并发，因此才有了一个`writev()`方法作为批量写入的替代。`write()`返回的`true/false`也仅是表示数据量是否达到了它的水位线，但继续向其写入也是没问题的（当然要注意内存用量）。\n\n## pipe方法\n\n结合上面两张图之后再去看`pipe()`方法就会比较好理解了\n\n![](/img/streamII-3.png)\n\n## Duplex双工流\n\n> [官方文档-实现一个双工流](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_duplex_stream)\n\n就是简单继承了可读流和可写流而已，注意它并不是像一根水管一样一边写了一边就可以读，需要用户自己去实现读写方法，换言之你可以让流入和流出的数据完全无关。双工流与分开实现一个可读流一个可写流的区别，主要在于它可以帮你管理一些流的状态，比如`allowHalfOpen`不允许半开，这样读流触发`end`事件（如`push(null)`）时会去关闭写流。不过我们一般需求的场景是反过来的：写流end后就结束读流，但双工流无法实现，因为它没有与你约定好中间的数据流转逻辑，不知道读流何时才能正确被结束，因此我们一般使用它的子类`Transform`转换流。\n\n## Transform转换流\n\n> [官方文档-实现一个转换流](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_transform_stream)\n\n* `_transform()`可以当作是可写流的`_write()`的用途\n* `_flush()`是上游流发出`end`事件时触发的方法，可以在这里将残余的中间数据处理并输出到下游去\n\n转换流是双工流的子类，封装了一些转换的逻辑，主要思路就是：\n\n可写流`write()`接收数据 => _transform()方法 => push()方法 => 可读流产生数据输出\n\n因为它本质上还是对可读流、可写流的封装，因此类似可写流的`highWaterMark`与串行写入实现的流速控制、`pipe()`管道方法等特性都是可以享受的，Node内常见的对流的加密压缩也都是用它实现的，注意的一点是`_transform()`方法本身是不会帮你把数据`push()`到可读流的（只有用户自己知道什么时候数据才是可以被输出的），因此要注意自己保留中间数据、及时调用`push()`输出、以及在`_flush()`接口内处理残余数据。\n\n![](/img/streamII-3.png)\n\n这里附一个简单易懂的例子：\n\n```javascript\nconst stream = require('stream');\n\n/**\n * 将逐条数据缓存在内存，达到batchSize或上游流结束时，才向下游发出一条打包的data消息\n */\nclass BatchStream extends stream.Transform {\n  /**\n   * @param {*} batchSize 批量大小\n   * @param {*} options 传递给基类stream的options，部分属性固定\n   */\n  constructor(batchSize = 500, options = {}) {\n    options.allowHalfOpen = false;\n    options.writableObjectMode = true;\n    options.readableObjectMode = true;\n    options.highWaterMark= 1024;\n    super(options);\n    this.batchSize = batchSize;\n    this._chunks = [];\n  }\n  async _transform(chunk, encoding, callback) {\n    this._chunks = this._chunks.concat(chunk);\n\n    while (this._chunks.length >= this.batchSize) {\n      const batch = this._chunks.splice(0, this.batchSize);\n      this.push(batch);\n    }\n\n    callback();\n  }\n  _flush(cb) {\n    if (this._chunks.length) this.push(this._chunks)\n    cb();\n  }\n}\nmodule.exports = BatchStream;\n```\n\n刚开始编写流的实现时可能要注意的一点是，流本身带有的那些数据缓冲区、写入队列并不是给你用的，因此如果要你保留一些中间状态，必须要自己建变量存着，比如上面例子的`this._chunks`。\n\n## 总结\n\nNode的流设计与Promise一样，本质上都是对回调、异步控制的封装和抽象，由于基于事件订阅的机制实现，它可以实现流速控制，更适合用于持续的异步过程，并可用`pipe()`管道方法将其简化，在使用中有以下点可以关注：\n\n* 可读流`on('data',cb)`形式订阅数据事件的形式，无法直接控制并发量，可以考虑用类似[streamQueue](/Node对流的Promise包装和并发控制/)这样的形式再做一层控制，或者自己实现一个可写流，使用`pipe()`来做自动的流速控制\n* 可写流的`write()`实际是串行处理写入数据，本身虽然保证了数据的有序性，但不一定高效，在追求效率的时候，可以考虑实现`_writev()`接口，或者不在`_write()`内等待异步执行，直接回调`cb`，如果出现问题想要中断流程，可以再手动触发错误`ws.emit('error')`\n\n","source":"_posts/NodeJS：Stream研究笔记II.md","raw":"---\ntitle: NodeJS：Stream研究笔记II\ndesc: 主要是Node源码阅读理解\ntags: \n- nodejs\n- stream  \nauthor: ngtmuzi\ncategory: 班门弄斧\ndate: 2020-04-05 20:19:39\n---\n几年前写的[研究笔记](/NodeJS：Stream研究笔记)现在回头看感觉全是在抄官方文档里的东西，近期真正在写stream的时候又发现其实根本没算了解，都没自己实现过读流和写流，于是补充一篇。\n\n以下内容主要来自官方文档及自行阅读源码，较多内部逻辑及细节已被省略，只抽象其主干思想：\n\n## Readable可读流\n\n> [官方文档-实现一个可读流](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_readable_stream)\n\n* 所有可读流都必须提供`_read()`方法的实现，以从基础资源中获取数据。\n* 当调用`_read()`时，如果资源中已有可用数据，则应该使用`this.push(dataChunk)`将数据加入到读流的缓冲区队列中，然后`_read()`应该持续以上操作直到`push()`返回`false`。\n\n![](/img/streamII-1.png)\n\n从结论来说，如果你不调用`push()`，可读流永远不会产生数据。\n\n关于可读流的两种读取模式在这里就不再赘述了，有趣的是可读流内部的缓冲区`buffer`并不是一个`Buffer`对象（因为流要支持对象模式，不能只支持二进制数据）或者`Array`，而是一个自己实现的单链表，带头尾指针，这里应该是考虑方便缓冲区的前后读写，并且不需要使用数组的索引功能。\n\n`push()`函数还提到说当它返回`false`时就不应该继续写入了，其实代码内部中只是返回了缓冲区与`highWaterMark`的大小对比，其实并不会抛弃超过的数据，所以自己实现时多写一些内容进去是没问题的（比如一次批量拿到了N个数据，总不能写一半丢一半）。\n\n## Writable可写流\n\n> [官方文档-实现一个可写流](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_writable_stream)\n\n* 所有可写流实现必须提供`_write`方法，以将数据发送到基础资源\n* 必须调用回调方法来表示本次写入的成功或失败\n* 在调用`_write()`和回调被调用之间如果有新的`write()`调用，则这些数据会先被放入缓冲区。调用回调时，流可能会发出“`drain`事件。\n\n![](/img/streamII-2.png)\n\n可写流相对比可读流逻辑简单一点，就是包裹一下用户自定义的写方法，并且做缓冲队列，从这里我们能知道很重要的一点：可写流的`write()`是串行调用的，不支持并发，因此才有了一个`writev()`方法作为批量写入的替代。`write()`返回的`true/false`也仅是表示数据量是否达到了它的水位线，但继续向其写入也是没问题的（当然要注意内存用量）。\n\n## pipe方法\n\n结合上面两张图之后再去看`pipe()`方法就会比较好理解了\n\n![](/img/streamII-3.png)\n\n## Duplex双工流\n\n> [官方文档-实现一个双工流](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_duplex_stream)\n\n就是简单继承了可读流和可写流而已，注意它并不是像一根水管一样一边写了一边就可以读，需要用户自己去实现读写方法，换言之你可以让流入和流出的数据完全无关。双工流与分开实现一个可读流一个可写流的区别，主要在于它可以帮你管理一些流的状态，比如`allowHalfOpen`不允许半开，这样读流触发`end`事件（如`push(null)`）时会去关闭写流。不过我们一般需求的场景是反过来的：写流end后就结束读流，但双工流无法实现，因为它没有与你约定好中间的数据流转逻辑，不知道读流何时才能正确被结束，因此我们一般使用它的子类`Transform`转换流。\n\n## Transform转换流\n\n> [官方文档-实现一个转换流](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_transform_stream)\n\n* `_transform()`可以当作是可写流的`_write()`的用途\n* `_flush()`是上游流发出`end`事件时触发的方法，可以在这里将残余的中间数据处理并输出到下游去\n\n转换流是双工流的子类，封装了一些转换的逻辑，主要思路就是：\n\n可写流`write()`接收数据 => _transform()方法 => push()方法 => 可读流产生数据输出\n\n因为它本质上还是对可读流、可写流的封装，因此类似可写流的`highWaterMark`与串行写入实现的流速控制、`pipe()`管道方法等特性都是可以享受的，Node内常见的对流的加密压缩也都是用它实现的，注意的一点是`_transform()`方法本身是不会帮你把数据`push()`到可读流的（只有用户自己知道什么时候数据才是可以被输出的），因此要注意自己保留中间数据、及时调用`push()`输出、以及在`_flush()`接口内处理残余数据。\n\n![](/img/streamII-3.png)\n\n这里附一个简单易懂的例子：\n\n```javascript\nconst stream = require('stream');\n\n/**\n * 将逐条数据缓存在内存，达到batchSize或上游流结束时，才向下游发出一条打包的data消息\n */\nclass BatchStream extends stream.Transform {\n  /**\n   * @param {*} batchSize 批量大小\n   * @param {*} options 传递给基类stream的options，部分属性固定\n   */\n  constructor(batchSize = 500, options = {}) {\n    options.allowHalfOpen = false;\n    options.writableObjectMode = true;\n    options.readableObjectMode = true;\n    options.highWaterMark= 1024;\n    super(options);\n    this.batchSize = batchSize;\n    this._chunks = [];\n  }\n  async _transform(chunk, encoding, callback) {\n    this._chunks = this._chunks.concat(chunk);\n\n    while (this._chunks.length >= this.batchSize) {\n      const batch = this._chunks.splice(0, this.batchSize);\n      this.push(batch);\n    }\n\n    callback();\n  }\n  _flush(cb) {\n    if (this._chunks.length) this.push(this._chunks)\n    cb();\n  }\n}\nmodule.exports = BatchStream;\n```\n\n刚开始编写流的实现时可能要注意的一点是，流本身带有的那些数据缓冲区、写入队列并不是给你用的，因此如果要你保留一些中间状态，必须要自己建变量存着，比如上面例子的`this._chunks`。\n\n## 总结\n\nNode的流设计与Promise一样，本质上都是对回调、异步控制的封装和抽象，由于基于事件订阅的机制实现，它可以实现流速控制，更适合用于持续的异步过程，并可用`pipe()`管道方法将其简化，在使用中有以下点可以关注：\n\n* 可读流`on('data',cb)`形式订阅数据事件的形式，无法直接控制并发量，可以考虑用类似[streamQueue](/Node对流的Promise包装和并发控制/)这样的形式再做一层控制，或者自己实现一个可写流，使用`pipe()`来做自动的流速控制\n* 可写流的`write()`实际是串行处理写入数据，本身虽然保证了数据的有序性，但不一定高效，在追求效率的时候，可以考虑实现`_writev()`接口，或者不在`_write()`内等待异步执行，直接回调`cb`，如果出现问题想要中断流程，可以再手动触发错误`ws.emit('error')`\n\n","slug":"NodeJS：Stream研究笔记II","published":1,"updated":"2020-08-07T06:18:46.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbd0003sou551fs58wv","content":"<p>几年前写的<a href=\"/NodeJS：Stream研究笔记\">研究笔记</a>现在回头看感觉全是在抄官方文档里的东西，近期真正在写stream的时候又发现其实根本没算了解，都没自己实现过读流和写流，于是补充一篇。</p>\n<p>以下内容主要来自官方文档及自行阅读源码，较多内部逻辑及细节已被省略，只抽象其主干思想：</p>\n<h2 id=\"Readable可读流\"><a href=\"#Readable可读流\" class=\"headerlink\" title=\"Readable可读流\"></a>Readable可读流</h2><blockquote>\n<p><a href=\"https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_readable_stream\">官方文档-实现一个可读流</a></p>\n</blockquote>\n<ul>\n<li>所有可读流都必须提供<code>_read()</code>方法的实现，以从基础资源中获取数据。</li>\n<li>当调用<code>_read()</code>时，如果资源中已有可用数据，则应该使用<code>this.push(dataChunk)</code>将数据加入到读流的缓冲区队列中，然后<code>_read()</code>应该持续以上操作直到<code>push()</code>返回<code>false</code>。</li>\n</ul>\n<p><img src=\"/img/streamII-1.png\" alt=\"\"></p>\n<p>从结论来说，如果你不调用<code>push()</code>，可读流永远不会产生数据。</p>\n<p>关于可读流的两种读取模式在这里就不再赘述了，有趣的是可读流内部的缓冲区<code>buffer</code>并不是一个<code>Buffer</code>对象（因为流要支持对象模式，不能只支持二进制数据）或者<code>Array</code>，而是一个自己实现的单链表，带头尾指针，这里应该是考虑方便缓冲区的前后读写，并且不需要使用数组的索引功能。</p>\n<p><code>push()</code>函数还提到说当它返回<code>false</code>时就不应该继续写入了，其实代码内部中只是返回了缓冲区与<code>highWaterMark</code>的大小对比，其实并不会抛弃超过的数据，所以自己实现时多写一些内容进去是没问题的（比如一次批量拿到了N个数据，总不能写一半丢一半）。</p>\n<h2 id=\"Writable可写流\"><a href=\"#Writable可写流\" class=\"headerlink\" title=\"Writable可写流\"></a>Writable可写流</h2><blockquote>\n<p><a href=\"https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_writable_stream\">官方文档-实现一个可写流</a></p>\n</blockquote>\n<ul>\n<li>所有可写流实现必须提供<code>_write</code>方法，以将数据发送到基础资源</li>\n<li>必须调用回调方法来表示本次写入的成功或失败</li>\n<li>在调用<code>_write()</code>和回调被调用之间如果有新的<code>write()</code>调用，则这些数据会先被放入缓冲区。调用回调时，流可能会发出“<code>drain</code>事件。</li>\n</ul>\n<p><img src=\"/img/streamII-2.png\" alt=\"\"></p>\n<p>可写流相对比可读流逻辑简单一点，就是包裹一下用户自定义的写方法，并且做缓冲队列，从这里我们能知道很重要的一点：可写流的<code>write()</code>是串行调用的，不支持并发，因此才有了一个<code>writev()</code>方法作为批量写入的替代。<code>write()</code>返回的<code>true/false</code>也仅是表示数据量是否达到了它的水位线，但继续向其写入也是没问题的（当然要注意内存用量）。</p>\n<h2 id=\"pipe方法\"><a href=\"#pipe方法\" class=\"headerlink\" title=\"pipe方法\"></a>pipe方法</h2><p>结合上面两张图之后再去看<code>pipe()</code>方法就会比较好理解了</p>\n<p><img src=\"/img/streamII-3.png\" alt=\"\"></p>\n<h2 id=\"Duplex双工流\"><a href=\"#Duplex双工流\" class=\"headerlink\" title=\"Duplex双工流\"></a>Duplex双工流</h2><blockquote>\n<p><a href=\"https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_duplex_stream\">官方文档-实现一个双工流</a></p>\n</blockquote>\n<p>就是简单继承了可读流和可写流而已，注意它并不是像一根水管一样一边写了一边就可以读，需要用户自己去实现读写方法，换言之你可以让流入和流出的数据完全无关。双工流与分开实现一个可读流一个可写流的区别，主要在于它可以帮你管理一些流的状态，比如<code>allowHalfOpen</code>不允许半开，这样读流触发<code>end</code>事件（如<code>push(null)</code>）时会去关闭写流。不过我们一般需求的场景是反过来的：写流end后就结束读流，但双工流无法实现，因为它没有与你约定好中间的数据流转逻辑，不知道读流何时才能正确被结束，因此我们一般使用它的子类<code>Transform</code>转换流。</p>\n<h2 id=\"Transform转换流\"><a href=\"#Transform转换流\" class=\"headerlink\" title=\"Transform转换流\"></a>Transform转换流</h2><blockquote>\n<p><a href=\"https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_transform_stream\">官方文档-实现一个转换流</a></p>\n</blockquote>\n<ul>\n<li><code>_transform()</code>可以当作是可写流的<code>_write()</code>的用途</li>\n<li><code>_flush()</code>是上游流发出<code>end</code>事件时触发的方法，可以在这里将残余的中间数据处理并输出到下游去</li>\n</ul>\n<p>转换流是双工流的子类，封装了一些转换的逻辑，主要思路就是：</p>\n<p>可写流<code>write()</code>接收数据 =&gt; _transform()方法 =&gt; push()方法 =&gt; 可读流产生数据输出</p>\n<p>因为它本质上还是对可读流、可写流的封装，因此类似可写流的<code>highWaterMark</code>与串行写入实现的流速控制、<code>pipe()</code>管道方法等特性都是可以享受的，Node内常见的对流的加密压缩也都是用它实现的，注意的一点是<code>_transform()</code>方法本身是不会帮你把数据<code>push()</code>到可读流的（只有用户自己知道什么时候数据才是可以被输出的），因此要注意自己保留中间数据、及时调用<code>push()</code>输出、以及在<code>_flush()</code>接口内处理残余数据。</p>\n<p><img src=\"/img/streamII-3.png\" alt=\"\"></p>\n<p>这里附一个简单易懂的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stream = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;stream&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将逐条数据缓存在内存，达到batchSize或上游流结束时，才向下游发出一条打包的data消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BatchStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">stream</span>.<span class=\"title\">Transform</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>batchSize 批量大小</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>options 传递给基类stream的options，部分属性固定</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">batchSize = <span class=\"number\">500</span>, options = &#123;&#125;</span>)</span> &#123;</span><br><span class=\"line\">    options.allowHalfOpen = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    options.writableObjectMode = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    options.readableObjectMode = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    options.highWaterMark= <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(options);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.batchSize = batchSize;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._chunks = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">_transform</span>(<span class=\"params\">chunk, encoding, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._chunks = <span class=\"built_in\">this</span>._chunks.concat(chunk);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>._chunks.length &gt;= <span class=\"built_in\">this</span>.batchSize) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> batch = <span class=\"built_in\">this</span>._chunks.splice(<span class=\"number\">0</span>, <span class=\"built_in\">this</span>.batchSize);</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.push(batch);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">_flush</span>(<span class=\"params\">cb</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>._chunks.length) <span class=\"built_in\">this</span>.push(<span class=\"built_in\">this</span>._chunks)</span><br><span class=\"line\">    cb();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = BatchStream;</span><br></pre></td></tr></table></figure>\n<p>刚开始编写流的实现时可能要注意的一点是，流本身带有的那些数据缓冲区、写入队列并不是给你用的，因此如果要你保留一些中间状态，必须要自己建变量存着，比如上面例子的<code>this._chunks</code>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Node的流设计与Promise一样，本质上都是对回调、异步控制的封装和抽象，由于基于事件订阅的机制实现，它可以实现流速控制，更适合用于持续的异步过程，并可用<code>pipe()</code>管道方法将其简化，在使用中有以下点可以关注：</p>\n<ul>\n<li>可读流<code>on(&#39;data&#39;,cb)</code>形式订阅数据事件的形式，无法直接控制并发量，可以考虑用类似<a href=\"/Node对流的Promise包装和并发控制/\">streamQueue</a>这样的形式再做一层控制，或者自己实现一个可写流，使用<code>pipe()</code>来做自动的流速控制</li>\n<li>可写流的<code>write()</code>实际是串行处理写入数据，本身虽然保证了数据的有序性，但不一定高效，在追求效率的时候，可以考虑实现<code>_writev()</code>接口，或者不在<code>_write()</code>内等待异步执行，直接回调<code>cb</code>，如果出现问题想要中断流程，可以再手动触发错误<code>ws.emit(&#39;error&#39;)</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>几年前写的<a href=\"/NodeJS：Stream研究笔记\">研究笔记</a>现在回头看感觉全是在抄官方文档里的东西，近期真正在写stream的时候又发现其实根本没算了解，都没自己实现过读流和写流，于是补充一篇。</p>\n<p>以下内容主要来自官方文档及自行阅读源码，较多内部逻辑及细节已被省略，只抽象其主干思想：</p>\n<h2 id=\"Readable可读流\"><a href=\"#Readable可读流\" class=\"headerlink\" title=\"Readable可读流\"></a>Readable可读流</h2><blockquote>\n<p><a href=\"https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_readable_stream\">官方文档-实现一个可读流</a></p>\n</blockquote>\n<ul>\n<li>所有可读流都必须提供<code>_read()</code>方法的实现，以从基础资源中获取数据。</li>\n<li>当调用<code>_read()</code>时，如果资源中已有可用数据，则应该使用<code>this.push(dataChunk)</code>将数据加入到读流的缓冲区队列中，然后<code>_read()</code>应该持续以上操作直到<code>push()</code>返回<code>false</code>。</li>\n</ul>\n<p><img src=\"/img/streamII-1.png\" alt=\"\"></p>\n<p>从结论来说，如果你不调用<code>push()</code>，可读流永远不会产生数据。</p>\n<p>关于可读流的两种读取模式在这里就不再赘述了，有趣的是可读流内部的缓冲区<code>buffer</code>并不是一个<code>Buffer</code>对象（因为流要支持对象模式，不能只支持二进制数据）或者<code>Array</code>，而是一个自己实现的单链表，带头尾指针，这里应该是考虑方便缓冲区的前后读写，并且不需要使用数组的索引功能。</p>\n<p><code>push()</code>函数还提到说当它返回<code>false</code>时就不应该继续写入了，其实代码内部中只是返回了缓冲区与<code>highWaterMark</code>的大小对比，其实并不会抛弃超过的数据，所以自己实现时多写一些内容进去是没问题的（比如一次批量拿到了N个数据，总不能写一半丢一半）。</p>\n<h2 id=\"Writable可写流\"><a href=\"#Writable可写流\" class=\"headerlink\" title=\"Writable可写流\"></a>Writable可写流</h2><blockquote>\n<p><a href=\"https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_writable_stream\">官方文档-实现一个可写流</a></p>\n</blockquote>\n<ul>\n<li>所有可写流实现必须提供<code>_write</code>方法，以将数据发送到基础资源</li>\n<li>必须调用回调方法来表示本次写入的成功或失败</li>\n<li>在调用<code>_write()</code>和回调被调用之间如果有新的<code>write()</code>调用，则这些数据会先被放入缓冲区。调用回调时，流可能会发出“<code>drain</code>事件。</li>\n</ul>\n<p><img src=\"/img/streamII-2.png\" alt=\"\"></p>\n<p>可写流相对比可读流逻辑简单一点，就是包裹一下用户自定义的写方法，并且做缓冲队列，从这里我们能知道很重要的一点：可写流的<code>write()</code>是串行调用的，不支持并发，因此才有了一个<code>writev()</code>方法作为批量写入的替代。<code>write()</code>返回的<code>true/false</code>也仅是表示数据量是否达到了它的水位线，但继续向其写入也是没问题的（当然要注意内存用量）。</p>\n<h2 id=\"pipe方法\"><a href=\"#pipe方法\" class=\"headerlink\" title=\"pipe方法\"></a>pipe方法</h2><p>结合上面两张图之后再去看<code>pipe()</code>方法就会比较好理解了</p>\n<p><img src=\"/img/streamII-3.png\" alt=\"\"></p>\n<h2 id=\"Duplex双工流\"><a href=\"#Duplex双工流\" class=\"headerlink\" title=\"Duplex双工流\"></a>Duplex双工流</h2><blockquote>\n<p><a href=\"https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_duplex_stream\">官方文档-实现一个双工流</a></p>\n</blockquote>\n<p>就是简单继承了可读流和可写流而已，注意它并不是像一根水管一样一边写了一边就可以读，需要用户自己去实现读写方法，换言之你可以让流入和流出的数据完全无关。双工流与分开实现一个可读流一个可写流的区别，主要在于它可以帮你管理一些流的状态，比如<code>allowHalfOpen</code>不允许半开，这样读流触发<code>end</code>事件（如<code>push(null)</code>）时会去关闭写流。不过我们一般需求的场景是反过来的：写流end后就结束读流，但双工流无法实现，因为它没有与你约定好中间的数据流转逻辑，不知道读流何时才能正确被结束，因此我们一般使用它的子类<code>Transform</code>转换流。</p>\n<h2 id=\"Transform转换流\"><a href=\"#Transform转换流\" class=\"headerlink\" title=\"Transform转换流\"></a>Transform转换流</h2><blockquote>\n<p><a href=\"https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_implementing_a_transform_stream\">官方文档-实现一个转换流</a></p>\n</blockquote>\n<ul>\n<li><code>_transform()</code>可以当作是可写流的<code>_write()</code>的用途</li>\n<li><code>_flush()</code>是上游流发出<code>end</code>事件时触发的方法，可以在这里将残余的中间数据处理并输出到下游去</li>\n</ul>\n<p>转换流是双工流的子类，封装了一些转换的逻辑，主要思路就是：</p>\n<p>可写流<code>write()</code>接收数据 =&gt; _transform()方法 =&gt; push()方法 =&gt; 可读流产生数据输出</p>\n<p>因为它本质上还是对可读流、可写流的封装，因此类似可写流的<code>highWaterMark</code>与串行写入实现的流速控制、<code>pipe()</code>管道方法等特性都是可以享受的，Node内常见的对流的加密压缩也都是用它实现的，注意的一点是<code>_transform()</code>方法本身是不会帮你把数据<code>push()</code>到可读流的（只有用户自己知道什么时候数据才是可以被输出的），因此要注意自己保留中间数据、及时调用<code>push()</code>输出、以及在<code>_flush()</code>接口内处理残余数据。</p>\n<p><img src=\"/img/streamII-3.png\" alt=\"\"></p>\n<p>这里附一个简单易懂的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stream = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;stream&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将逐条数据缓存在内存，达到batchSize或上游流结束时，才向下游发出一条打包的data消息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BatchStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">stream</span>.<span class=\"title\">Transform</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>batchSize 批量大小</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>options 传递给基类stream的options，部分属性固定</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">batchSize = <span class=\"number\">500</span>, options = &#123;&#125;</span>)</span> &#123;</span><br><span class=\"line\">    options.allowHalfOpen = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    options.writableObjectMode = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    options.readableObjectMode = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    options.highWaterMark= <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(options);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.batchSize = batchSize;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._chunks = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">_transform</span>(<span class=\"params\">chunk, encoding, callback</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._chunks = <span class=\"built_in\">this</span>._chunks.concat(chunk);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">this</span>._chunks.length &gt;= <span class=\"built_in\">this</span>.batchSize) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> batch = <span class=\"built_in\">this</span>._chunks.splice(<span class=\"number\">0</span>, <span class=\"built_in\">this</span>.batchSize);</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.push(batch);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">_flush</span>(<span class=\"params\">cb</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>._chunks.length) <span class=\"built_in\">this</span>.push(<span class=\"built_in\">this</span>._chunks)</span><br><span class=\"line\">    cb();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = BatchStream;</span><br></pre></td></tr></table></figure>\n<p>刚开始编写流的实现时可能要注意的一点是，流本身带有的那些数据缓冲区、写入队列并不是给你用的，因此如果要你保留一些中间状态，必须要自己建变量存着，比如上面例子的<code>this._chunks</code>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Node的流设计与Promise一样，本质上都是对回调、异步控制的封装和抽象，由于基于事件订阅的机制实现，它可以实现流速控制，更适合用于持续的异步过程，并可用<code>pipe()</code>管道方法将其简化，在使用中有以下点可以关注：</p>\n<ul>\n<li>可读流<code>on(&#39;data&#39;,cb)</code>形式订阅数据事件的形式，无法直接控制并发量，可以考虑用类似<a href=\"/Node对流的Promise包装和并发控制/\">streamQueue</a>这样的形式再做一层控制，或者自己实现一个可写流，使用<code>pipe()</code>来做自动的流速控制</li>\n<li>可写流的<code>write()</code>实际是串行处理写入数据，本身虽然保证了数据的有序性，但不一定高效，在追求效率的时候，可以考虑实现<code>_writev()</code>接口，或者不在<code>_write()</code>内等待异步执行，直接回调<code>cb</code>，如果出现问题想要中断流程，可以再手动触发错误<code>ws.emit(&#39;error&#39;)</code></li>\n</ul>\n"},{"title":"Node处理字符编码相关经验","desc":"在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道","date":"2016-05-25T02:10:55.618Z","author":"ngtmuzi","_content":"\n在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：\n\n\n首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用`iconv-lite`就行了\n\n\n自动判断文本编码并解码为UTF8\n---\n```javascript\nvar iconv     = require('iconv-lite');\nvar jschardet = require('jschardet');\nfunction readText(filePath) {\n  var fileData = fs.readFileSync(filePath);\n  var encoding = jschardet.detect(fileData).encoding;\n  if (!iconv.encodingExists(encoding)) encoding = 'utf8';\n  return iconv.decode(fileData, encoding);\n}\n```\n\n`jschardet`模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用`iconv-lite`转成UTF8即可\n\n\n读取GBK编码页面\n---\n```javascript\nvar request = require('request-promise');\nvar iconv   = require('iconv-lite');\nrequest('http://someurl.com', {encoding: null})\n  .then(s=>iconv.decode(s, 'gbk'))\n  .then(console.log, console.error);\n```\n\n将`encoding`指定为`null`的时候`request`模块会返回一个`buffer`，我们将其手动gbk解码即可\n\n\n处理gbk编码的urlencode\n---\n```javascript\nvar iconv   = require('iconv-lite');\nvar gbkStr = '%c4%e3%ba%c3';\niconv.decode(new Buffer(gbkStr.replace(/%/g, ''), 'hex'), 'gbk');\n```\n\n`express`在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成`buffer`之后再解码\n\n\n\n转发无法被解码的urlencode\n---\n\n假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的`%c4%e3%ba%c3`，这个时候再通过`request`去请求的时候，再次做了urlencode，会把原字符串里的百分号转成`%25`，那么目标方接到参数的时候就变成`%25c4%25e3%25ba%25c3`，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下\n```javascript\nvar qs   = require('querystring');\nvar data = {gbkStr: '%c4%e3%ba%c3'};\n\nfunction urlEncode(s) {\n  return qs.escape(s.replace(/%(\\w{2})/g, '-_-$1')).replace(/-_-(\\W{2})/g, '%$1');\n}\n\n//1、使用原生的queryString\nvar url = 'someurl' + qs.stringify(data, null, null, {encodeURIComponent: urlEncode});\n\n//2、直接用于request\nrequest('someurl', {\n  qs                : data,\n  qsStringifyOptions: {options: {encodeURIComponent: urlEncode}}\n}).then(console.log, console.error);\n```\n\n关于`querystring`更多的细节参看[官方文档](https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options)\n\n\n我们可以让`querystring`结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱","source":"_posts/Node处理字符编码相关经验.md","raw":"---\ntitle: Node处理字符编码相关经验\ndesc: 在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道  \ndate: 2016-5-25 10:10:55.618\ntags: \n- nodejs\n- encoding\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：\n\n\n首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用`iconv-lite`就行了\n\n\n自动判断文本编码并解码为UTF8\n---\n```javascript\nvar iconv     = require('iconv-lite');\nvar jschardet = require('jschardet');\nfunction readText(filePath) {\n  var fileData = fs.readFileSync(filePath);\n  var encoding = jschardet.detect(fileData).encoding;\n  if (!iconv.encodingExists(encoding)) encoding = 'utf8';\n  return iconv.decode(fileData, encoding);\n}\n```\n\n`jschardet`模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用`iconv-lite`转成UTF8即可\n\n\n读取GBK编码页面\n---\n```javascript\nvar request = require('request-promise');\nvar iconv   = require('iconv-lite');\nrequest('http://someurl.com', {encoding: null})\n  .then(s=>iconv.decode(s, 'gbk'))\n  .then(console.log, console.error);\n```\n\n将`encoding`指定为`null`的时候`request`模块会返回一个`buffer`，我们将其手动gbk解码即可\n\n\n处理gbk编码的urlencode\n---\n```javascript\nvar iconv   = require('iconv-lite');\nvar gbkStr = '%c4%e3%ba%c3';\niconv.decode(new Buffer(gbkStr.replace(/%/g, ''), 'hex'), 'gbk');\n```\n\n`express`在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成`buffer`之后再解码\n\n\n\n转发无法被解码的urlencode\n---\n\n假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的`%c4%e3%ba%c3`，这个时候再通过`request`去请求的时候，再次做了urlencode，会把原字符串里的百分号转成`%25`，那么目标方接到参数的时候就变成`%25c4%25e3%25ba%25c3`，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下\n```javascript\nvar qs   = require('querystring');\nvar data = {gbkStr: '%c4%e3%ba%c3'};\n\nfunction urlEncode(s) {\n  return qs.escape(s.replace(/%(\\w{2})/g, '-_-$1')).replace(/-_-(\\W{2})/g, '%$1');\n}\n\n//1、使用原生的queryString\nvar url = 'someurl' + qs.stringify(data, null, null, {encodeURIComponent: urlEncode});\n\n//2、直接用于request\nrequest('someurl', {\n  qs                : data,\n  qsStringifyOptions: {options: {encodeURIComponent: urlEncode}}\n}).then(console.log, console.error);\n```\n\n关于`querystring`更多的细节参看[官方文档](https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options)\n\n\n我们可以让`querystring`结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱","slug":"Node处理字符编码相关经验","published":1,"updated":"2020-06-17T10:26:40.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbe0004sou5ekuk7b69","content":"<p>在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：</p>\n<p>首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用<code>iconv-lite</code>就行了</p>\n<h2 id=\"自动判断文本编码并解码为UTF8\"><a href=\"#自动判断文本编码并解码为UTF8\" class=\"headerlink\" title=\"自动判断文本编码并解码为UTF8\"></a>自动判断文本编码并解码为UTF8</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> iconv     = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;iconv-lite&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jschardet = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;jschardet&#x27;</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readText</span>(<span class=\"params\">filePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fileData = fs.readFileSync(filePath);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> encoding = jschardet.detect(fileData).encoding;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!iconv.encodingExists(encoding)) encoding = <span class=\"string\">&#x27;utf8&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> iconv.decode(fileData, encoding);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>jschardet</code>模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用<code>iconv-lite</code>转成UTF8即可</p>\n<h2 id=\"读取GBK编码页面\"><a href=\"#读取GBK编码页面\" class=\"headerlink\" title=\"读取GBK编码页面\"></a>读取GBK编码页面</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;request-promise&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;iconv-lite&#x27;</span>);</span><br><span class=\"line\">request(<span class=\"string\">&#x27;http://someurl.com&#x27;</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"literal\">null</span>&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">s</span>=&gt;</span>iconv.decode(s, <span class=\"string\">&#x27;gbk&#x27;</span>))</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>将<code>encoding</code>指定为<code>null</code>的时候<code>request</code>模块会返回一个<code>buffer</code>，我们将其手动gbk解码即可</p>\n<h2 id=\"处理gbk编码的urlencode\"><a href=\"#处理gbk编码的urlencode\" class=\"headerlink\" title=\"处理gbk编码的urlencode\"></a>处理gbk编码的urlencode</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;iconv-lite&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> gbkStr = <span class=\"string\">&#x27;%c4%e3%ba%c3&#x27;</span>;</span><br><span class=\"line\">iconv.decode(<span class=\"keyword\">new</span> Buffer(gbkStr.replace(<span class=\"regexp\">/%/g</span>, <span class=\"string\">&#x27;&#x27;</span>), <span class=\"string\">&#x27;hex&#x27;</span>), <span class=\"string\">&#x27;gbk&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p><code>express</code>在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成<code>buffer</code>之后再解码</p>\n<h2 id=\"转发无法被解码的urlencode\"><a href=\"#转发无法被解码的urlencode\" class=\"headerlink\" title=\"转发无法被解码的urlencode\"></a>转发无法被解码的urlencode</h2><p>假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的<code>%c4%e3%ba%c3</code>，这个时候再通过<code>request</code>去请求的时候，再次做了urlencode，会把原字符串里的百分号转成<code>%25</code>，那么目标方接到参数的时候就变成<code>%25c4%25e3%25ba%25c3</code>，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> qs   = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;querystring&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">gbkStr</span>: <span class=\"string\">&#x27;%c4%e3%ba%c3&#x27;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">urlEncode</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> qs.escape(s.replace(<span class=\"regexp\">/%(\\w&#123;2&#125;)/g</span>, <span class=\"string\">&#x27;-_-$1&#x27;</span>)).replace(<span class=\"regexp\">/-_-(\\W&#123;2&#125;)/g</span>, <span class=\"string\">&#x27;%$1&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、使用原生的queryString</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">&#x27;someurl&#x27;</span> + qs.stringify(data, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、直接用于request</span></span><br><span class=\"line\">request(<span class=\"string\">&#x27;someurl&#x27;</span>, &#123;</span><br><span class=\"line\">  qs                : data,</span><br><span class=\"line\">  qsStringifyOptions: &#123;<span class=\"attr\">options</span>: &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;&#125;</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure></p>\n<p>关于<code>querystring</code>更多的细节参看<a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options\">官方文档</a></p>\n<p>我们可以让<code>querystring</code>结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：</p>\n<p>首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用<code>iconv-lite</code>就行了</p>\n<h2 id=\"自动判断文本编码并解码为UTF8\"><a href=\"#自动判断文本编码并解码为UTF8\" class=\"headerlink\" title=\"自动判断文本编码并解码为UTF8\"></a>自动判断文本编码并解码为UTF8</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> iconv     = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;iconv-lite&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jschardet = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;jschardet&#x27;</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readText</span>(<span class=\"params\">filePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fileData = fs.readFileSync(filePath);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> encoding = jschardet.detect(fileData).encoding;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!iconv.encodingExists(encoding)) encoding = <span class=\"string\">&#x27;utf8&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> iconv.decode(fileData, encoding);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>jschardet</code>模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用<code>iconv-lite</code>转成UTF8即可</p>\n<h2 id=\"读取GBK编码页面\"><a href=\"#读取GBK编码页面\" class=\"headerlink\" title=\"读取GBK编码页面\"></a>读取GBK编码页面</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;request-promise&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;iconv-lite&#x27;</span>);</span><br><span class=\"line\">request(<span class=\"string\">&#x27;http://someurl.com&#x27;</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"literal\">null</span>&#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">s</span>=&gt;</span>iconv.decode(s, <span class=\"string\">&#x27;gbk&#x27;</span>))</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>将<code>encoding</code>指定为<code>null</code>的时候<code>request</code>模块会返回一个<code>buffer</code>，我们将其手动gbk解码即可</p>\n<h2 id=\"处理gbk编码的urlencode\"><a href=\"#处理gbk编码的urlencode\" class=\"headerlink\" title=\"处理gbk编码的urlencode\"></a>处理gbk编码的urlencode</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;iconv-lite&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> gbkStr = <span class=\"string\">&#x27;%c4%e3%ba%c3&#x27;</span>;</span><br><span class=\"line\">iconv.decode(<span class=\"keyword\">new</span> Buffer(gbkStr.replace(<span class=\"regexp\">/%/g</span>, <span class=\"string\">&#x27;&#x27;</span>), <span class=\"string\">&#x27;hex&#x27;</span>), <span class=\"string\">&#x27;gbk&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p><code>express</code>在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成<code>buffer</code>之后再解码</p>\n<h2 id=\"转发无法被解码的urlencode\"><a href=\"#转发无法被解码的urlencode\" class=\"headerlink\" title=\"转发无法被解码的urlencode\"></a>转发无法被解码的urlencode</h2><p>假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的<code>%c4%e3%ba%c3</code>，这个时候再通过<code>request</code>去请求的时候，再次做了urlencode，会把原字符串里的百分号转成<code>%25</code>，那么目标方接到参数的时候就变成<code>%25c4%25e3%25ba%25c3</code>，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> qs   = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;querystring&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">gbkStr</span>: <span class=\"string\">&#x27;%c4%e3%ba%c3&#x27;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">urlEncode</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> qs.escape(s.replace(<span class=\"regexp\">/%(\\w&#123;2&#125;)/g</span>, <span class=\"string\">&#x27;-_-$1&#x27;</span>)).replace(<span class=\"regexp\">/-_-(\\W&#123;2&#125;)/g</span>, <span class=\"string\">&#x27;%$1&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1、使用原生的queryString</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">&#x27;someurl&#x27;</span> + qs.stringify(data, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、直接用于request</span></span><br><span class=\"line\">request(<span class=\"string\">&#x27;someurl&#x27;</span>, &#123;</span><br><span class=\"line\">  qs                : data,</span><br><span class=\"line\">  qsStringifyOptions: &#123;<span class=\"attr\">options</span>: &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;&#125;</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure></p>\n<p>关于<code>querystring</code>更多的细节参看<a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options\">官方文档</a></p>\n<p>我们可以让<code>querystring</code>结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱</p>\n"},{"title":"Node实现简单的redis同步锁","desc":"照着作者的思路来实现还是很容易的","author":"ngtmuzi","date":"2018-03-22T06:07:34.000Z","_content":"\n也是实际的需求，某个业务有并发问题，同时处理会引起脏读脏写，之前实现了一个[promise队列](https://ngtmuzi.com/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%E9%98%9F%E5%88%97/)就是来解决这件事的，但现在服务器部署了多台，业务方随机访问，没办法在内存层面做到队列控制了，因此就想到用redis来实现一个简单锁来控制并发\n\n## 参考资料\n> [Distributed locks with Redis](https://redis.io/topics/distlock)\n\n来自官网上redis作者的文章，虽然是讲分布式锁redLock的，但也提到了使用redis实现简单锁的方法，并提出了他认为的简单锁的缺点：\n* 单点故障\n* 有部署主从的情况下，可能主服上的锁定操作还没同步到从服，主服就出现了故障，从服晋升为主服，使得之前的锁定不生效\n\n## 分析\n\n在我这边的实际业务上看，redis的故障是可以容忍的，实话说我接触了redis挺长一段时间还从没见它崩过，因此就直接照着作者的思路来实现一个简单锁就好了：\n\n1. 客户端使用`SET NX`语法设置一个会过期的键，当键存在时返回锁定错误（即表明已经这个键已经被别人锁着了）\n    ```\n    SET resource_name my_random_value NX PX 30000\n    ```\n1. 解锁时向redis服调用一段`lua`脚本\n    ```lua\n    if redis.call(\"get\",KEYS[1]) == ARGV[1] then\n        return redis.call(\"del\",KEYS[1])\n    else\n        return 0\n    end\n    ```\n    解锁时传递的value必须与锁定时的value相等，这是用于防止其他客户端在错误情况下会解锁其他人锁的情况，就是“解铃还须系铃人”的那种感觉\n1. 若超过过期时间，客户端还没发起解锁，那么该键将会因为过期而被redis删除，避免产生死锁的情况\n1. 更完善一点实现还会考虑加时的情况，即延长自己的锁定时间，也需要用lua脚本来做判断value是否相等\n\n## Node代码实现\n\n使用[ioredis模块](https://www.npmjs.com/package/ioredis)\n\n### 构造函数\n```javascript\nclass Locker {\n  constructor(redis) {\n    this.redis   = redis;\n    this.lockMap = new Map();\n\n    //定义lua脚本让它原子化执行\n    this.redis.defineCommand('lua_unlock', {\n      numberOfKeys: 1,\n      lua         : `\n        local remote_value = redis.call(\"get\",KEYS[1])\n        \n        if (not remote_value) then\n          return 0\n        elseif (remote_value == ARGV[1]) then\n          return redis.call(\"del\",KEYS[1])\n        else\n          return -1\n        end`\n    });\n  }\n}\n```\n传递一个ioredis实例进来，`lockMap`用来在内存在维护多组锁定相关的键值对，使用ioredis的功能定义一个解锁用的lua脚本以待后面调用，脚本稍微增加了一点内容\n\n### 加锁\n```javascript\n/**\n * 锁定key，如已被锁定会抛错\n * @param key\n * @param expire    过期时间(毫秒)\n * @return {Promise<void>}\n */\nasync function lock(key, expire = 10000) {\n  const value = crypto.randomBytes(16).toString('hex');\n\n  let result = await this.redis.set(key, value, 'NX', 'PX', expire);\n  if (result === null) throw new Error('lock error: key already exists');\n\n  this.lockMap.set(key, {value, expire, time: Date.now()});\n  return 'OK';\n}\n```\n生成一个随机值做value，写入redis和内存中\n\n### 解锁\n```javascript\n/**\n * 解锁key，无论key是否存在，解锁是否成功，都不会抛错（除网络原因外），具体返回值:\n * null: key在本地不存在    0:key在redis上不存在    1:解锁成功      -1:value不对应，不能解锁\n * @param key\n * @return {Promise<*>}\n */\nasync function unLock(key) {\n  if (!this.lockMap.has(key)) return null;\n  let {value, expire, time} = this.lockMap.get(key);\n  this.lockMap.delete(key);\n\n  return await this.redis.lua_unlock(key, value);\n}\n```\n从内存中找到对应key的value，把它们传给redis，使用lua脚本解锁，因为解锁基本算是个收尾的工作，因此各种没解锁成功的情况我不会抛错，有需要可以根据返回值自己处理\n\n### 等待加锁\n```javascript\n/**\n * 每隔interval时间就尝试一次锁定，当用时超过waitTime就返回失败\n * @param key\n * @param expire\n * @param interval\n * @param waitTime\n * @return {Promise<void>}\n */\nasync function waitLock(key, expire, interval = 500, waitTime = 5000) {\n  let start_time = Date.now();\n  let result;\n  while ((Date.now() - start_time) < waitTime) {\n    result = await this.lock(key, expire).catch(() => {});\n    if (result === 'OK') return 'OK';\n    else await delay(interval);\n  }\n  throw new Error('waitLock timeout');\n}\n\n/**\n * 等待一段时间（毫秒）\n * @param ms\n */\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n```\n对键重复地尝试加锁，直到抢占到锁资源，类似“连接池”的那种感觉\n\n[完整代码](https://github.com/ngtmuzi/wheel/blob/master/services/redisLocker.js)\n\n## 总结  \n\nredisLock的逻辑有点太复杂了，一般业务用简单的同步锁就好了","source":"_posts/Node实现简单的redis同步锁.md","raw":"---\ntitle: Node实现简单的redis同步锁\ndesc: 照着作者的思路来实现还是很容易的\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2018-03-22 14:07:34\ntags:\n- nodejs\n- redis\n---\n\n也是实际的需求，某个业务有并发问题，同时处理会引起脏读脏写，之前实现了一个[promise队列](https://ngtmuzi.com/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%E9%98%9F%E5%88%97/)就是来解决这件事的，但现在服务器部署了多台，业务方随机访问，没办法在内存层面做到队列控制了，因此就想到用redis来实现一个简单锁来控制并发\n\n## 参考资料\n> [Distributed locks with Redis](https://redis.io/topics/distlock)\n\n来自官网上redis作者的文章，虽然是讲分布式锁redLock的，但也提到了使用redis实现简单锁的方法，并提出了他认为的简单锁的缺点：\n* 单点故障\n* 有部署主从的情况下，可能主服上的锁定操作还没同步到从服，主服就出现了故障，从服晋升为主服，使得之前的锁定不生效\n\n## 分析\n\n在我这边的实际业务上看，redis的故障是可以容忍的，实话说我接触了redis挺长一段时间还从没见它崩过，因此就直接照着作者的思路来实现一个简单锁就好了：\n\n1. 客户端使用`SET NX`语法设置一个会过期的键，当键存在时返回锁定错误（即表明已经这个键已经被别人锁着了）\n    ```\n    SET resource_name my_random_value NX PX 30000\n    ```\n1. 解锁时向redis服调用一段`lua`脚本\n    ```lua\n    if redis.call(\"get\",KEYS[1]) == ARGV[1] then\n        return redis.call(\"del\",KEYS[1])\n    else\n        return 0\n    end\n    ```\n    解锁时传递的value必须与锁定时的value相等，这是用于防止其他客户端在错误情况下会解锁其他人锁的情况，就是“解铃还须系铃人”的那种感觉\n1. 若超过过期时间，客户端还没发起解锁，那么该键将会因为过期而被redis删除，避免产生死锁的情况\n1. 更完善一点实现还会考虑加时的情况，即延长自己的锁定时间，也需要用lua脚本来做判断value是否相等\n\n## Node代码实现\n\n使用[ioredis模块](https://www.npmjs.com/package/ioredis)\n\n### 构造函数\n```javascript\nclass Locker {\n  constructor(redis) {\n    this.redis   = redis;\n    this.lockMap = new Map();\n\n    //定义lua脚本让它原子化执行\n    this.redis.defineCommand('lua_unlock', {\n      numberOfKeys: 1,\n      lua         : `\n        local remote_value = redis.call(\"get\",KEYS[1])\n        \n        if (not remote_value) then\n          return 0\n        elseif (remote_value == ARGV[1]) then\n          return redis.call(\"del\",KEYS[1])\n        else\n          return -1\n        end`\n    });\n  }\n}\n```\n传递一个ioredis实例进来，`lockMap`用来在内存在维护多组锁定相关的键值对，使用ioredis的功能定义一个解锁用的lua脚本以待后面调用，脚本稍微增加了一点内容\n\n### 加锁\n```javascript\n/**\n * 锁定key，如已被锁定会抛错\n * @param key\n * @param expire    过期时间(毫秒)\n * @return {Promise<void>}\n */\nasync function lock(key, expire = 10000) {\n  const value = crypto.randomBytes(16).toString('hex');\n\n  let result = await this.redis.set(key, value, 'NX', 'PX', expire);\n  if (result === null) throw new Error('lock error: key already exists');\n\n  this.lockMap.set(key, {value, expire, time: Date.now()});\n  return 'OK';\n}\n```\n生成一个随机值做value，写入redis和内存中\n\n### 解锁\n```javascript\n/**\n * 解锁key，无论key是否存在，解锁是否成功，都不会抛错（除网络原因外），具体返回值:\n * null: key在本地不存在    0:key在redis上不存在    1:解锁成功      -1:value不对应，不能解锁\n * @param key\n * @return {Promise<*>}\n */\nasync function unLock(key) {\n  if (!this.lockMap.has(key)) return null;\n  let {value, expire, time} = this.lockMap.get(key);\n  this.lockMap.delete(key);\n\n  return await this.redis.lua_unlock(key, value);\n}\n```\n从内存中找到对应key的value，把它们传给redis，使用lua脚本解锁，因为解锁基本算是个收尾的工作，因此各种没解锁成功的情况我不会抛错，有需要可以根据返回值自己处理\n\n### 等待加锁\n```javascript\n/**\n * 每隔interval时间就尝试一次锁定，当用时超过waitTime就返回失败\n * @param key\n * @param expire\n * @param interval\n * @param waitTime\n * @return {Promise<void>}\n */\nasync function waitLock(key, expire, interval = 500, waitTime = 5000) {\n  let start_time = Date.now();\n  let result;\n  while ((Date.now() - start_time) < waitTime) {\n    result = await this.lock(key, expire).catch(() => {});\n    if (result === 'OK') return 'OK';\n    else await delay(interval);\n  }\n  throw new Error('waitLock timeout');\n}\n\n/**\n * 等待一段时间（毫秒）\n * @param ms\n */\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n```\n对键重复地尝试加锁，直到抢占到锁资源，类似“连接池”的那种感觉\n\n[完整代码](https://github.com/ngtmuzi/wheel/blob/master/services/redisLocker.js)\n\n## 总结  \n\nredisLock的逻辑有点太复杂了，一般业务用简单的同步锁就好了","slug":"Node实现简单的redis同步锁","published":1,"updated":"2020-06-17T10:26:40.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbf0005sou5bymxenfg","content":"<p>也是实际的需求，某个业务有并发问题，同时处理会引起脏读脏写，之前实现了一个<a href=\"https://ngtmuzi.com/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%E9%98%9F%E5%88%97/\">promise队列</a>就是来解决这件事的，但现在服务器部署了多台，业务方随机访问，没办法在内存层面做到队列控制了，因此就想到用redis来实现一个简单锁来控制并发</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><blockquote>\n<p><a href=\"https://redis.io/topics/distlock\">Distributed locks with Redis</a></p>\n</blockquote>\n<p>来自官网上redis作者的文章，虽然是讲分布式锁redLock的，但也提到了使用redis实现简单锁的方法，并提出了他认为的简单锁的缺点：</p>\n<ul>\n<li>单点故障</li>\n<li>有部署主从的情况下，可能主服上的锁定操作还没同步到从服，主服就出现了故障，从服晋升为主服，使得之前的锁定不生效</li>\n</ul>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>在我这边的实际业务上看，redis的故障是可以容忍的，实话说我接触了redis挺长一段时间还从没见它崩过，因此就直接照着作者的思路来实现一个简单锁就好了：</p>\n<ol>\n<li>客户端使用<code>SET NX</code>语法设置一个会过期的键，当键存在时返回锁定错误（即表明已经这个键已经被别人锁着了） <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure></li>\n<li>解锁时向redis服调用一段<code>lua</code>脚本 <figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> redis.call(<span class=\"string\">&quot;get&quot;</span>,KEYS[<span class=\"number\">1</span>]) == ARGV[<span class=\"number\">1</span>] <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> redis.call(<span class=\"string\">&quot;del&quot;</span>,KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n 解锁时传递的value必须与锁定时的value相等，这是用于防止其他客户端在错误情况下会解锁其他人锁的情况，就是“解铃还须系铃人”的那种感觉</li>\n<li>若超过过期时间，客户端还没发起解锁，那么该键将会因为过期而被redis删除，避免产生死锁的情况</li>\n<li>更完善一点实现还会考虑加时的情况，即延长自己的锁定时间，也需要用lua脚本来做判断value是否相等</li>\n</ol>\n<h2 id=\"Node代码实现\"><a href=\"#Node代码实现\" class=\"headerlink\" title=\"Node代码实现\"></a>Node代码实现</h2><p>使用<a href=\"https://www.npmjs.com/package/ioredis\">ioredis模块</a></p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Locker</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">redis</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.redis   = redis;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lockMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义lua脚本让它原子化执行</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.redis.defineCommand(<span class=\"string\">&#x27;lua_unlock&#x27;</span>, &#123;</span><br><span class=\"line\">      numberOfKeys: <span class=\"number\">1</span>,</span><br><span class=\"line\">      lua         : <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        local remote_value = redis.call(&quot;get&quot;,KEYS[1])</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        if (not remote_value) then</span></span><br><span class=\"line\"><span class=\"string\">          return 0</span></span><br><span class=\"line\"><span class=\"string\">        elseif (remote_value == ARGV[1]) then</span></span><br><span class=\"line\"><span class=\"string\">          return redis.call(&quot;del&quot;,KEYS[1])</span></span><br><span class=\"line\"><span class=\"string\">        else</span></span><br><span class=\"line\"><span class=\"string\">          return -1</span></span><br><span class=\"line\"><span class=\"string\">        end`</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>传递一个ioredis实例进来，<code>lockMap</code>用来在内存在维护多组锁定相关的键值对，使用ioredis的功能定义一个解锁用的lua脚本以待后面调用，脚本稍微增加了一点内容</p>\n<h3 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a>加锁</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 锁定key，如已被锁定会抛错</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">key</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>expire    过期时间(毫秒)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;Promise&lt;void&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lock</span>(<span class=\"params\">key, expire = <span class=\"number\">10000</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = crypto.randomBytes(<span class=\"number\">16</span>).toString(<span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> <span class=\"built_in\">this</span>.redis.set(key, value, <span class=\"string\">&#x27;NX&#x27;</span>, <span class=\"string\">&#x27;PX&#x27;</span>, expire);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result === <span class=\"literal\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;lock error: key already exists&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.lockMap.set(key, &#123;value, expire, <span class=\"attr\">time</span>: <span class=\"built_in\">Date</span>.now()&#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;OK&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成一个随机值做value，写入redis和内存中</p>\n<h3 id=\"解锁\"><a href=\"#解锁\" class=\"headerlink\" title=\"解锁\"></a>解锁</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 解锁key，无论key是否存在，解锁是否成功，都不会抛错（除网络原因外），具体返回值:</span></span><br><span class=\"line\"><span class=\"comment\"> * null: key在本地不存在    0:key在redis上不存在    1:解锁成功      -1:value不对应，不能解锁</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">key</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;Promise&lt;*&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unLock</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.lockMap.has(key)) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;value, expire, time&#125; = <span class=\"built_in\">this</span>.lockMap.get(key);</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.lockMap.delete(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">this</span>.redis.lua_unlock(key, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从内存中找到对应key的value，把它们传给redis，使用lua脚本解锁，因为解锁基本算是个收尾的工作，因此各种没解锁成功的情况我不会抛错，有需要可以根据返回值自己处理</p>\n<h3 id=\"等待加锁\"><a href=\"#等待加锁\" class=\"headerlink\" title=\"等待加锁\"></a>等待加锁</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 每隔interval时间就尝试一次锁定，当用时超过waitTime就返回失败</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">key</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">expire</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">interval</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">waitTime</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;Promise&lt;void&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitLock</span>(<span class=\"params\">key, expire, interval = <span class=\"number\">500</span>, waitTime = <span class=\"number\">5000</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start_time = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((<span class=\"built_in\">Date</span>.now() - start_time) &lt; waitTime) &#123;</span><br><span class=\"line\">    result = <span class=\"keyword\">await</span> <span class=\"built_in\">this</span>.lock(key, expire).catch(<span class=\"function\">() =&gt;</span> &#123;&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result === <span class=\"string\">&#x27;OK&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;OK&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">await</span> delay(interval);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;waitLock timeout&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 等待一段时间（毫秒）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">ms</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">setTimeout</span>(resolve, ms));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对键重复地尝试加锁，直到抢占到锁资源，类似“连接池”的那种感觉</p>\n<p><a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/redisLocker.js\">完整代码</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>redisLock的逻辑有点太复杂了，一般业务用简单的同步锁就好了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>也是实际的需求，某个业务有并发问题，同时处理会引起脏读脏写，之前实现了一个<a href=\"https://ngtmuzi.com/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%E9%98%9F%E5%88%97/\">promise队列</a>就是来解决这件事的，但现在服务器部署了多台，业务方随机访问，没办法在内存层面做到队列控制了，因此就想到用redis来实现一个简单锁来控制并发</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><blockquote>\n<p><a href=\"https://redis.io/topics/distlock\">Distributed locks with Redis</a></p>\n</blockquote>\n<p>来自官网上redis作者的文章，虽然是讲分布式锁redLock的，但也提到了使用redis实现简单锁的方法，并提出了他认为的简单锁的缺点：</p>\n<ul>\n<li>单点故障</li>\n<li>有部署主从的情况下，可能主服上的锁定操作还没同步到从服，主服就出现了故障，从服晋升为主服，使得之前的锁定不生效</li>\n</ul>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>在我这边的实际业务上看，redis的故障是可以容忍的，实话说我接触了redis挺长一段时间还从没见它崩过，因此就直接照着作者的思路来实现一个简单锁就好了：</p>\n<ol>\n<li>客户端使用<code>SET NX</code>语法设置一个会过期的键，当键存在时返回锁定错误（即表明已经这个键已经被别人锁着了） <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure></li>\n<li>解锁时向redis服调用一段<code>lua</code>脚本 <figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> redis.call(<span class=\"string\">&quot;get&quot;</span>,KEYS[<span class=\"number\">1</span>]) == ARGV[<span class=\"number\">1</span>] <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> redis.call(<span class=\"string\">&quot;del&quot;</span>,KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n 解锁时传递的value必须与锁定时的value相等，这是用于防止其他客户端在错误情况下会解锁其他人锁的情况，就是“解铃还须系铃人”的那种感觉</li>\n<li>若超过过期时间，客户端还没发起解锁，那么该键将会因为过期而被redis删除，避免产生死锁的情况</li>\n<li>更完善一点实现还会考虑加时的情况，即延长自己的锁定时间，也需要用lua脚本来做判断value是否相等</li>\n</ol>\n<h2 id=\"Node代码实现\"><a href=\"#Node代码实现\" class=\"headerlink\" title=\"Node代码实现\"></a>Node代码实现</h2><p>使用<a href=\"https://www.npmjs.com/package/ioredis\">ioredis模块</a></p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Locker</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">redis</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.redis   = redis;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.lockMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义lua脚本让它原子化执行</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.redis.defineCommand(<span class=\"string\">&#x27;lua_unlock&#x27;</span>, &#123;</span><br><span class=\"line\">      numberOfKeys: <span class=\"number\">1</span>,</span><br><span class=\"line\">      lua         : <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        local remote_value = redis.call(&quot;get&quot;,KEYS[1])</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        if (not remote_value) then</span></span><br><span class=\"line\"><span class=\"string\">          return 0</span></span><br><span class=\"line\"><span class=\"string\">        elseif (remote_value == ARGV[1]) then</span></span><br><span class=\"line\"><span class=\"string\">          return redis.call(&quot;del&quot;,KEYS[1])</span></span><br><span class=\"line\"><span class=\"string\">        else</span></span><br><span class=\"line\"><span class=\"string\">          return -1</span></span><br><span class=\"line\"><span class=\"string\">        end`</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>传递一个ioredis实例进来，<code>lockMap</code>用来在内存在维护多组锁定相关的键值对，使用ioredis的功能定义一个解锁用的lua脚本以待后面调用，脚本稍微增加了一点内容</p>\n<h3 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a>加锁</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 锁定key，如已被锁定会抛错</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">key</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>expire    过期时间(毫秒)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;Promise&lt;void&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lock</span>(<span class=\"params\">key, expire = <span class=\"number\">10000</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = crypto.randomBytes(<span class=\"number\">16</span>).toString(<span class=\"string\">&#x27;hex&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> <span class=\"built_in\">this</span>.redis.set(key, value, <span class=\"string\">&#x27;NX&#x27;</span>, <span class=\"string\">&#x27;PX&#x27;</span>, expire);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result === <span class=\"literal\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;lock error: key already exists&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.lockMap.set(key, &#123;value, expire, <span class=\"attr\">time</span>: <span class=\"built_in\">Date</span>.now()&#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;OK&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成一个随机值做value，写入redis和内存中</p>\n<h3 id=\"解锁\"><a href=\"#解锁\" class=\"headerlink\" title=\"解锁\"></a>解锁</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 解锁key，无论key是否存在，解锁是否成功，都不会抛错（除网络原因外），具体返回值:</span></span><br><span class=\"line\"><span class=\"comment\"> * null: key在本地不存在    0:key在redis上不存在    1:解锁成功      -1:value不对应，不能解锁</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">key</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;Promise&lt;*&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unLock</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.lockMap.has(key)) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;value, expire, time&#125; = <span class=\"built_in\">this</span>.lockMap.get(key);</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.lockMap.delete(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">this</span>.redis.lua_unlock(key, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从内存中找到对应key的value，把它们传给redis，使用lua脚本解锁，因为解锁基本算是个收尾的工作，因此各种没解锁成功的情况我不会抛错，有需要可以根据返回值自己处理</p>\n<h3 id=\"等待加锁\"><a href=\"#等待加锁\" class=\"headerlink\" title=\"等待加锁\"></a>等待加锁</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 每隔interval时间就尝试一次锁定，当用时超过waitTime就返回失败</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">key</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">expire</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">interval</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">waitTime</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;Promise&lt;void&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitLock</span>(<span class=\"params\">key, expire, interval = <span class=\"number\">500</span>, waitTime = <span class=\"number\">5000</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start_time = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((<span class=\"built_in\">Date</span>.now() - start_time) &lt; waitTime) &#123;</span><br><span class=\"line\">    result = <span class=\"keyword\">await</span> <span class=\"built_in\">this</span>.lock(key, expire).catch(<span class=\"function\">() =&gt;</span> &#123;&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result === <span class=\"string\">&#x27;OK&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;OK&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">await</span> delay(interval);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;waitLock timeout&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 等待一段时间（毫秒）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">ms</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">setTimeout</span>(resolve, ms));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对键重复地尝试加锁，直到抢占到锁资源，类似“连接池”的那种感觉</p>\n<p><a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/redisLocker.js\">完整代码</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>redisLock的逻辑有点太复杂了，一般业务用简单的同步锁就好了</p>\n"},{"title":"Node对流的Promise包装和并发控制","desc":"超简单代码","author":"ngtmuzi","date":"2018-11-06T12:47:28.000Z","_content":"\n最近没有在做直接开发的工作，都是一些旧工作的接手和整理脚本流程之类的，发个之前写的函数吧。主要封装了流（或类似流的类，比如node.js自带的`readline`模块）到`Promise`中，并提供并发数控制的机制（当然需要流本身支持pause才行）。我主要用于读数据库或文件之类的操作，将流的细节封起来感觉还是舒服一点。\n\n```javascript\n/**\n * 将可读流传给遍历器fn（可异步），使用流的特性做并发控制和收集返回（注意内存消耗）\n * @param readable       {ReadableStream} 可读流\n * @param fn             {Function}       遍历器，触发时机为data事件\n * @param concurrency    {Number}         并发处理的数量，当并发数满时，流将会被自动暂停\n * @param collectResults {Boolean}        是否收集fn执行的结果，并最后返回结果的数组\n * @param eventName      {String}         事件名，一般是data\n * @return {Promise}      fn执行的次数或结果数组\n */\nfunction streamQueue(readable, fn, { concurrency = 1, collectResults = false, eventName = 'data' } = {}) {\n  let runCount = 0, index = 0, isOver = false;\n  const results = [];\n  return new Promise((resolve, reject) => {\n    const checkFinish = () => {\n      if (isOver && runCount === 0) resolve(collectResults ? results : index);\n    };\n\n    readable.on(eventName, async data => {\n      let myIdx = index++;\n      runCount++;\n      if (runCount >= concurrency) readable.pause();\n      try {\n        let result = await fn(data);\n        if (collectResults) results[myIdx] = result;\n      } catch (e) {\n        return reject(e);\n      }\n      runCount--;\n      checkFinish();\n      if (runCount < concurrency) readable.resume();\n    });\n    readable.on('close', () => {\n      isOver = true;\n      checkFinish();\n    });\n    readable.on('end', () => {\n      isOver = true;\n      checkFinish();\n    });\n    readable.on('error', reject);\n  });\n}\n```","source":"_posts/Node对流的Promise包装和并发控制.md","raw":"---\ntitle: Node对流的Promise包装和并发控制\ndesc: 超简单代码\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2018-11-06 20:47:28\ntags:\n- stream\n- nodejs\n- promise\n---\n\n最近没有在做直接开发的工作，都是一些旧工作的接手和整理脚本流程之类的，发个之前写的函数吧。主要封装了流（或类似流的类，比如node.js自带的`readline`模块）到`Promise`中，并提供并发数控制的机制（当然需要流本身支持pause才行）。我主要用于读数据库或文件之类的操作，将流的细节封起来感觉还是舒服一点。\n\n```javascript\n/**\n * 将可读流传给遍历器fn（可异步），使用流的特性做并发控制和收集返回（注意内存消耗）\n * @param readable       {ReadableStream} 可读流\n * @param fn             {Function}       遍历器，触发时机为data事件\n * @param concurrency    {Number}         并发处理的数量，当并发数满时，流将会被自动暂停\n * @param collectResults {Boolean}        是否收集fn执行的结果，并最后返回结果的数组\n * @param eventName      {String}         事件名，一般是data\n * @return {Promise}      fn执行的次数或结果数组\n */\nfunction streamQueue(readable, fn, { concurrency = 1, collectResults = false, eventName = 'data' } = {}) {\n  let runCount = 0, index = 0, isOver = false;\n  const results = [];\n  return new Promise((resolve, reject) => {\n    const checkFinish = () => {\n      if (isOver && runCount === 0) resolve(collectResults ? results : index);\n    };\n\n    readable.on(eventName, async data => {\n      let myIdx = index++;\n      runCount++;\n      if (runCount >= concurrency) readable.pause();\n      try {\n        let result = await fn(data);\n        if (collectResults) results[myIdx] = result;\n      } catch (e) {\n        return reject(e);\n      }\n      runCount--;\n      checkFinish();\n      if (runCount < concurrency) readable.resume();\n    });\n    readable.on('close', () => {\n      isOver = true;\n      checkFinish();\n    });\n    readable.on('end', () => {\n      isOver = true;\n      checkFinish();\n    });\n    readable.on('error', reject);\n  });\n}\n```","slug":"Node对流的Promise包装和并发控制","published":1,"updated":"2020-06-17T10:26:40.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbf0006sou5hffj83tp","content":"<p>最近没有在做直接开发的工作，都是一些旧工作的接手和整理脚本流程之类的，发个之前写的函数吧。主要封装了流（或类似流的类，比如node.js自带的<code>readline</code>模块）到<code>Promise</code>中，并提供并发数控制的机制（当然需要流本身支持pause才行）。我主要用于读数据库或文件之类的操作，将流的细节封起来感觉还是舒服一点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将可读流传给遍历器fn（可异步），使用流的特性做并发控制和收集返回（注意内存消耗）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>readable       &#123;ReadableStream&#125; 可读流</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>fn             &#123;Function&#125;       遍历器，触发时机为data事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>concurrency    &#123;Number&#125;         并发处理的数量，当并发数满时，流将会被自动暂停</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>collectResults &#123;Boolean&#125;        是否收集fn执行的结果，并最后返回结果的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>eventName      &#123;String&#125;         事件名，一般是data</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;Promise&#125;</span>      </span>fn执行的次数或结果数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">streamQueue</span>(<span class=\"params\">readable, fn, &#123; concurrency = <span class=\"number\">1</span>, collectResults = <span class=\"literal\">false</span>, eventName = <span class=\"string\">&#x27;data&#x27;</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> runCount = <span class=\"number\">0</span>, index = <span class=\"number\">0</span>, isOver = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> checkFinish = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isOver &amp;&amp; runCount === <span class=\"number\">0</span>) resolve(collectResults ? results : index);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    readable.on(eventName, <span class=\"keyword\">async</span> data =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> myIdx = index++;</span><br><span class=\"line\">      runCount++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runCount &gt;= concurrency) readable.pause();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> fn(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (collectResults) results[myIdx] = result;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      runCount--;</span><br><span class=\"line\">      checkFinish();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runCount &lt; concurrency) readable.resume();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    readable.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      isOver = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      checkFinish();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    readable.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      isOver = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      checkFinish();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    readable.on(<span class=\"string\">&#x27;error&#x27;</span>, reject);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>最近没有在做直接开发的工作，都是一些旧工作的接手和整理脚本流程之类的，发个之前写的函数吧。主要封装了流（或类似流的类，比如node.js自带的<code>readline</code>模块）到<code>Promise</code>中，并提供并发数控制的机制（当然需要流本身支持pause才行）。我主要用于读数据库或文件之类的操作，将流的细节封起来感觉还是舒服一点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将可读流传给遍历器fn（可异步），使用流的特性做并发控制和收集返回（注意内存消耗）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>readable       &#123;ReadableStream&#125; 可读流</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>fn             &#123;Function&#125;       遍历器，触发时机为data事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>concurrency    &#123;Number&#125;         并发处理的数量，当并发数满时，流将会被自动暂停</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>collectResults &#123;Boolean&#125;        是否收集fn执行的结果，并最后返回结果的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>eventName      &#123;String&#125;         事件名，一般是data</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;Promise&#125;</span>      </span>fn执行的次数或结果数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">streamQueue</span>(<span class=\"params\">readable, fn, &#123; concurrency = <span class=\"number\">1</span>, collectResults = <span class=\"literal\">false</span>, eventName = <span class=\"string\">&#x27;data&#x27;</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> runCount = <span class=\"number\">0</span>, index = <span class=\"number\">0</span>, isOver = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> checkFinish = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isOver &amp;&amp; runCount === <span class=\"number\">0</span>) resolve(collectResults ? results : index);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    readable.on(eventName, <span class=\"keyword\">async</span> data =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> myIdx = index++;</span><br><span class=\"line\">      runCount++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runCount &gt;= concurrency) readable.pause();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> fn(data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (collectResults) results[myIdx] = result;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      runCount--;</span><br><span class=\"line\">      checkFinish();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runCount &lt; concurrency) readable.resume();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    readable.on(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      isOver = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      checkFinish();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    readable.on(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      isOver = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      checkFinish();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    readable.on(<span class=\"string\">&#x27;error&#x27;</span>, reject);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Node开发命令行工具的经验总结","desc":"入门之后还是很方便的","author":"ngtmuzi","date":"2019-03-11T16:00:00.000Z","_content":"\n## 背景\n\n近半年接手了一个非web开发类的工作，一直跟数据、数据库和脚本打交道，原项目是windows服bat脚本和.NET命令行程序来跑各种任务的。之前我没有太接触过shell这块，碰到这些bat脚本确实有点把我难到了，各方面相比bash来说还是有很大差距，于是我着手开始做迁移工作\n\n这里推荐一个简单的bash入门教程\n\n> [bash-handbook](https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md)\n\n而复杂逻辑的exe部分，还是用我熟悉的node.js来重构，在此之前我还没有过命令行的开发经验，算是摸着石头过河\n\n### 参考资料\n\n> [Node.js 命令行程序开发教程](http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html)\n\n> [node.js 命令行工具(cli)](https://juejin.im/post/5af2a2cbf265da0b9c109f59)\n\n## 开发\n\n### 链接为全局指令\n\n大多数文档都会提到的一点，在`package.json`里的`bin`属性下写好指令名与代码路径后，执行`npm link`即可全局使用这个指令\n\n### 注意当前目录\n\n记得代码可能会在任意目录上执行，因此用相对定位来读自己的代码目录内的文件是不可取的，如`let s = fs.readFileSync('./a.json')`\n\n而应该改成使用`__dirname`来获取代码目录的绝对路径再去读文件，不过`require`函数不需要考虑这些，它会自己处理\n\n### 获取和解析参数\n\n我参考了npm上较为主流的几款命令行模块，看到大多是与具体函数耦合较紧的，需要用代码来配置命令行解析参数，这样的好处是能实现很多高级功能，如默认值、参数验证、自动生成帮助文档等。\n\n而我希望的是每次传不同的子命令时再去动态require代码，并且希望自定义帮助文档，因此只需要一套比较简单的解析库，拿到参数再自己处理，因此暂定使用了[yargs](https://www.npmjs.com/package/yargs)\n\n### 输出markdown文档到控制台\n\n```javascript\n  const marked = require('marked');\n  const TerminalRenderer = require('marked-terminal');\n\n  marked.setOptions({ renderer: new TerminalRenderer({ showSectionPrefix: false }) });\n  process.stdout.write(marked(fs.readFileSync(path.join(__dirname, './readme.md')).toString()));\n```\n\n`marked-terminal`模块将markdown文本转换为带有颜色信息的ANSI格式，然后输出到控制台，赏心悦目\n\n![marked-terminal输出截图](/img/node_cmd_1.jpg)\n\n### 从输入流读入数据\n\n想实现一个标准的UNIX类控制台程序，支持管道是必不可少的，得益于node的封装，我们有很简单的办法来获取输入流的数据\n\n* 从[process.stdin](https://nodejs.org/dist/latest-v11.x/docs/api/process.html#process_process_stdin)流式读取数据，这个时候我之前写的[Node对流的Promise包装和并发控制](/Node对流的Promise包装和并发控制/)模块就可以派上用场了\n* 直接用`fs.readFileSync(0)`读取全部内容，`0`就是标准输入流的文件句柄，当然前提是数据量不大或者需要完整解析的情况（如json），否则我们还是流式处理比较好\n\n### 调试信息定向到stderr\n\n想保持标准输出，又想在控制台看到调试日志的输出，我们可以将调试的数据都发到`stderr`去，最终的运行结果才输出到`stdout`\n\n在常用的日志模块`log4js`中，只要如此配置就好，这样所有日志输出都不会影响到标准输出流\n\n```javascript\nlog4js.configure({\n  appenders: { err: { type: 'stderr' } },\n  categories: { default: { appenders: ['err'], level: 'all' } }\n});\n```\n\n> [log4js文档](https://log4js-node.github.io/log4js-node/stderr.html)\n\n### 注意等待输出流写完成再关闭进程\n\n如果有输出流或者日志文件的情况，要注意不要轻易调用`process.exit`来主动结束进程，要等待流写入文件完成\n\n```javascript\n  //等待流写入完成\n  await new Promise(resolve => {\n    ws.on('finish', resolve);\n    ws.end();\n  });\n\n  //node4js的处理进程\n  log4js.shutdown(cb);\n```\n\n最好的情况是不写`process.exit`，只要记得`ws.end()`结束写入就行，当活动的流（包括标准输出流）全部完成，文件句柄释放后，进程自己会退出\n\n### 使用更大的内存\n\nnode.js使用的v8引擎默认堆内存上限约1.7GB，而在环境变量中加上`NODE_OPTIONS`=`--max-old-space-size=40960`后可以扩大可使用的内存大小，当然用大内存不一定是好事，优化代码、精简数据结构、流式处理和避免闭包才是合理做法\n\n### 使用烘焙/模板函数\n\n在用一些模板或规则批量处理数据的时候，可以考虑使用预构建函数或烘焙模板来优化效率，前端的编译框架对这个就很有研究了，有兴趣可以了解下\n\n### 对CSV做SQL查询\n\n有些复杂的业务需求需要对文件做数据统计汇总，原先是用[lodash](https://www.npmjs.com/package/lodash)的一套函数来处理，但未免还是有些繁复和难以阅读，后来引入了[alasql](https://www.npmjs.com/package/alasql)，支持流式地对文件进行sql查询，甚至支持连表语法，我目前也还在初步尝试阶段，有相关需求的可以了解下\n\n## 总结\n\n得益于现在基本所有前端渲染/JS预编译框架都会用Node的CLI工具来提供服务，npm上会有很多方便的模块供我们使用，在这之上使用Node来开发命令行工具还是很方便快捷的，在shell上如果有复杂的实现需求，不妨试试用Node编写代码来处理\n\n关于控制台程序的一些理解和指导，推荐阅读《UNIX编程艺术》\n","source":"_posts/Node开发命令行工具的经验总结.md","raw":"---\ntitle: Node开发命令行工具的经验总结\ndesc: 入门之后还是很方便的\nauthor: ngtmuzi\ncategory: 班门弄斧\ndate: 2019-03-12 00:00:00\ntags: \n- nodejs\n- shell\n- cli\n---\n\n## 背景\n\n近半年接手了一个非web开发类的工作，一直跟数据、数据库和脚本打交道，原项目是windows服bat脚本和.NET命令行程序来跑各种任务的。之前我没有太接触过shell这块，碰到这些bat脚本确实有点把我难到了，各方面相比bash来说还是有很大差距，于是我着手开始做迁移工作\n\n这里推荐一个简单的bash入门教程\n\n> [bash-handbook](https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md)\n\n而复杂逻辑的exe部分，还是用我熟悉的node.js来重构，在此之前我还没有过命令行的开发经验，算是摸着石头过河\n\n### 参考资料\n\n> [Node.js 命令行程序开发教程](http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html)\n\n> [node.js 命令行工具(cli)](https://juejin.im/post/5af2a2cbf265da0b9c109f59)\n\n## 开发\n\n### 链接为全局指令\n\n大多数文档都会提到的一点，在`package.json`里的`bin`属性下写好指令名与代码路径后，执行`npm link`即可全局使用这个指令\n\n### 注意当前目录\n\n记得代码可能会在任意目录上执行，因此用相对定位来读自己的代码目录内的文件是不可取的，如`let s = fs.readFileSync('./a.json')`\n\n而应该改成使用`__dirname`来获取代码目录的绝对路径再去读文件，不过`require`函数不需要考虑这些，它会自己处理\n\n### 获取和解析参数\n\n我参考了npm上较为主流的几款命令行模块，看到大多是与具体函数耦合较紧的，需要用代码来配置命令行解析参数，这样的好处是能实现很多高级功能，如默认值、参数验证、自动生成帮助文档等。\n\n而我希望的是每次传不同的子命令时再去动态require代码，并且希望自定义帮助文档，因此只需要一套比较简单的解析库，拿到参数再自己处理，因此暂定使用了[yargs](https://www.npmjs.com/package/yargs)\n\n### 输出markdown文档到控制台\n\n```javascript\n  const marked = require('marked');\n  const TerminalRenderer = require('marked-terminal');\n\n  marked.setOptions({ renderer: new TerminalRenderer({ showSectionPrefix: false }) });\n  process.stdout.write(marked(fs.readFileSync(path.join(__dirname, './readme.md')).toString()));\n```\n\n`marked-terminal`模块将markdown文本转换为带有颜色信息的ANSI格式，然后输出到控制台，赏心悦目\n\n![marked-terminal输出截图](/img/node_cmd_1.jpg)\n\n### 从输入流读入数据\n\n想实现一个标准的UNIX类控制台程序，支持管道是必不可少的，得益于node的封装，我们有很简单的办法来获取输入流的数据\n\n* 从[process.stdin](https://nodejs.org/dist/latest-v11.x/docs/api/process.html#process_process_stdin)流式读取数据，这个时候我之前写的[Node对流的Promise包装和并发控制](/Node对流的Promise包装和并发控制/)模块就可以派上用场了\n* 直接用`fs.readFileSync(0)`读取全部内容，`0`就是标准输入流的文件句柄，当然前提是数据量不大或者需要完整解析的情况（如json），否则我们还是流式处理比较好\n\n### 调试信息定向到stderr\n\n想保持标准输出，又想在控制台看到调试日志的输出，我们可以将调试的数据都发到`stderr`去，最终的运行结果才输出到`stdout`\n\n在常用的日志模块`log4js`中，只要如此配置就好，这样所有日志输出都不会影响到标准输出流\n\n```javascript\nlog4js.configure({\n  appenders: { err: { type: 'stderr' } },\n  categories: { default: { appenders: ['err'], level: 'all' } }\n});\n```\n\n> [log4js文档](https://log4js-node.github.io/log4js-node/stderr.html)\n\n### 注意等待输出流写完成再关闭进程\n\n如果有输出流或者日志文件的情况，要注意不要轻易调用`process.exit`来主动结束进程，要等待流写入文件完成\n\n```javascript\n  //等待流写入完成\n  await new Promise(resolve => {\n    ws.on('finish', resolve);\n    ws.end();\n  });\n\n  //node4js的处理进程\n  log4js.shutdown(cb);\n```\n\n最好的情况是不写`process.exit`，只要记得`ws.end()`结束写入就行，当活动的流（包括标准输出流）全部完成，文件句柄释放后，进程自己会退出\n\n### 使用更大的内存\n\nnode.js使用的v8引擎默认堆内存上限约1.7GB，而在环境变量中加上`NODE_OPTIONS`=`--max-old-space-size=40960`后可以扩大可使用的内存大小，当然用大内存不一定是好事，优化代码、精简数据结构、流式处理和避免闭包才是合理做法\n\n### 使用烘焙/模板函数\n\n在用一些模板或规则批量处理数据的时候，可以考虑使用预构建函数或烘焙模板来优化效率，前端的编译框架对这个就很有研究了，有兴趣可以了解下\n\n### 对CSV做SQL查询\n\n有些复杂的业务需求需要对文件做数据统计汇总，原先是用[lodash](https://www.npmjs.com/package/lodash)的一套函数来处理，但未免还是有些繁复和难以阅读，后来引入了[alasql](https://www.npmjs.com/package/alasql)，支持流式地对文件进行sql查询，甚至支持连表语法，我目前也还在初步尝试阶段，有相关需求的可以了解下\n\n## 总结\n\n得益于现在基本所有前端渲染/JS预编译框架都会用Node的CLI工具来提供服务，npm上会有很多方便的模块供我们使用，在这之上使用Node来开发命令行工具还是很方便快捷的，在shell上如果有复杂的实现需求，不妨试试用Node编写代码来处理\n\n关于控制台程序的一些理解和指导，推荐阅读《UNIX编程艺术》\n","slug":"Node开发命令行工具的经验总结","published":1,"updated":"2020-06-17T10:26:40.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbg0007sou56pfffocd","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>近半年接手了一个非web开发类的工作，一直跟数据、数据库和脚本打交道，原项目是windows服bat脚本和.NET命令行程序来跑各种任务的。之前我没有太接触过shell这块，碰到这些bat脚本确实有点把我难到了，各方面相比bash来说还是有很大差距，于是我着手开始做迁移工作</p>\n<p>这里推荐一个简单的bash入门教程</p>\n<blockquote>\n<p><a href=\"https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md\">bash-handbook</a></p>\n</blockquote>\n<p>而复杂逻辑的exe部分，还是用我熟悉的node.js来重构，在此之前我还没有过命令行的开发经验，算是摸着石头过河</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html\">Node.js 命令行程序开发教程</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://juejin.im/post/5af2a2cbf265da0b9c109f59\">node.js 命令行工具(cli)</a></p>\n</blockquote>\n<h2 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h2><h3 id=\"链接为全局指令\"><a href=\"#链接为全局指令\" class=\"headerlink\" title=\"链接为全局指令\"></a>链接为全局指令</h3><p>大多数文档都会提到的一点，在<code>package.json</code>里的<code>bin</code>属性下写好指令名与代码路径后，执行<code>npm link</code>即可全局使用这个指令</p>\n<h3 id=\"注意当前目录\"><a href=\"#注意当前目录\" class=\"headerlink\" title=\"注意当前目录\"></a>注意当前目录</h3><p>记得代码可能会在任意目录上执行，因此用相对定位来读自己的代码目录内的文件是不可取的，如<code>let s = fs.readFileSync(&#39;./a.json&#39;)</code></p>\n<p>而应该改成使用<code>__dirname</code>来获取代码目录的绝对路径再去读文件，不过<code>require</code>函数不需要考虑这些，它会自己处理</p>\n<h3 id=\"获取和解析参数\"><a href=\"#获取和解析参数\" class=\"headerlink\" title=\"获取和解析参数\"></a>获取和解析参数</h3><p>我参考了npm上较为主流的几款命令行模块，看到大多是与具体函数耦合较紧的，需要用代码来配置命令行解析参数，这样的好处是能实现很多高级功能，如默认值、参数验证、自动生成帮助文档等。</p>\n<p>而我希望的是每次传不同的子命令时再去动态require代码，并且希望自定义帮助文档，因此只需要一套比较简单的解析库，拿到参数再自己处理，因此暂定使用了<a href=\"https://www.npmjs.com/package/yargs\">yargs</a></p>\n<h3 id=\"输出markdown文档到控制台\"><a href=\"#输出markdown文档到控制台\" class=\"headerlink\" title=\"输出markdown文档到控制台\"></a>输出markdown文档到控制台</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;marked&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> TerminalRenderer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;marked-terminal&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">marked.setOptions(&#123; <span class=\"attr\">renderer</span>: <span class=\"keyword\">new</span> TerminalRenderer(&#123; <span class=\"attr\">showSectionPrefix</span>: <span class=\"literal\">false</span> &#125;) &#125;);</span><br><span class=\"line\">process.stdout.write(marked(fs.readFileSync(path.join(__dirname, <span class=\"string\">&#x27;./readme.md&#x27;</span>)).toString()));</span><br></pre></td></tr></table></figure>\n<p><code>marked-terminal</code>模块将markdown文本转换为带有颜色信息的ANSI格式，然后输出到控制台，赏心悦目</p>\n<p><img src=\"/img/node_cmd_1.jpg\" alt=\"marked-terminal输出截图\"></p>\n<h3 id=\"从输入流读入数据\"><a href=\"#从输入流读入数据\" class=\"headerlink\" title=\"从输入流读入数据\"></a>从输入流读入数据</h3><p>想实现一个标准的UNIX类控制台程序，支持管道是必不可少的，得益于node的封装，我们有很简单的办法来获取输入流的数据</p>\n<ul>\n<li>从<a href=\"https://nodejs.org/dist/latest-v11.x/docs/api/process.html#process_process_stdin\">process.stdin</a>流式读取数据，这个时候我之前写的<a href=\"/Node对流的Promise包装和并发控制/\">Node对流的Promise包装和并发控制</a>模块就可以派上用场了</li>\n<li>直接用<code>fs.readFileSync(0)</code>读取全部内容，<code>0</code>就是标准输入流的文件句柄，当然前提是数据量不大或者需要完整解析的情况（如json），否则我们还是流式处理比较好</li>\n</ul>\n<h3 id=\"调试信息定向到stderr\"><a href=\"#调试信息定向到stderr\" class=\"headerlink\" title=\"调试信息定向到stderr\"></a>调试信息定向到stderr</h3><p>想保持标准输出，又想在控制台看到调试日志的输出，我们可以将调试的数据都发到<code>stderr</code>去，最终的运行结果才输出到<code>stdout</code></p>\n<p>在常用的日志模块<code>log4js</code>中，只要如此配置就好，这样所有日志输出都不会影响到标准输出流</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log4js.configure(&#123;</span><br><span class=\"line\">  appenders: &#123; <span class=\"attr\">err</span>: &#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;stderr&#x27;</span> &#125; &#125;,</span><br><span class=\"line\">  categories: &#123; <span class=\"attr\">default</span>: &#123; <span class=\"attr\">appenders</span>: [<span class=\"string\">&#x27;err&#x27;</span>], <span class=\"attr\">level</span>: <span class=\"string\">&#x27;all&#x27;</span> &#125; &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://log4js-node.github.io/log4js-node/stderr.html\">log4js文档</a></p>\n</blockquote>\n<h3 id=\"注意等待输出流写完成再关闭进程\"><a href=\"#注意等待输出流写完成再关闭进程\" class=\"headerlink\" title=\"注意等待输出流写完成再关闭进程\"></a>注意等待输出流写完成再关闭进程</h3><p>如果有输出流或者日志文件的情况，要注意不要轻易调用<code>process.exit</code>来主动结束进程，要等待流写入文件完成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//等待流写入完成</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ws.on(<span class=\"string\">&#x27;finish&#x27;</span>, resolve);</span><br><span class=\"line\">  ws.end();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//node4js的处理进程</span></span><br><span class=\"line\">log4js.shutdown(cb);</span><br></pre></td></tr></table></figure>\n<p>最好的情况是不写<code>process.exit</code>，只要记得<code>ws.end()</code>结束写入就行，当活动的流（包括标准输出流）全部完成，文件句柄释放后，进程自己会退出</p>\n<h3 id=\"使用更大的内存\"><a href=\"#使用更大的内存\" class=\"headerlink\" title=\"使用更大的内存\"></a>使用更大的内存</h3><p>node.js使用的v8引擎默认堆内存上限约1.7GB，而在环境变量中加上<code>NODE_OPTIONS</code>=<code>--max-old-space-size=40960</code>后可以扩大可使用的内存大小，当然用大内存不一定是好事，优化代码、精简数据结构、流式处理和避免闭包才是合理做法</p>\n<h3 id=\"使用烘焙-模板函数\"><a href=\"#使用烘焙-模板函数\" class=\"headerlink\" title=\"使用烘焙/模板函数\"></a>使用烘焙/模板函数</h3><p>在用一些模板或规则批量处理数据的时候，可以考虑使用预构建函数或烘焙模板来优化效率，前端的编译框架对这个就很有研究了，有兴趣可以了解下</p>\n<h3 id=\"对CSV做SQL查询\"><a href=\"#对CSV做SQL查询\" class=\"headerlink\" title=\"对CSV做SQL查询\"></a>对CSV做SQL查询</h3><p>有些复杂的业务需求需要对文件做数据统计汇总，原先是用<a href=\"https://www.npmjs.com/package/lodash\">lodash</a>的一套函数来处理，但未免还是有些繁复和难以阅读，后来引入了<a href=\"https://www.npmjs.com/package/alasql\">alasql</a>，支持流式地对文件进行sql查询，甚至支持连表语法，我目前也还在初步尝试阶段，有相关需求的可以了解下</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>得益于现在基本所有前端渲染/JS预编译框架都会用Node的CLI工具来提供服务，npm上会有很多方便的模块供我们使用，在这之上使用Node来开发命令行工具还是很方便快捷的，在shell上如果有复杂的实现需求，不妨试试用Node编写代码来处理</p>\n<p>关于控制台程序的一些理解和指导，推荐阅读《UNIX编程艺术》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>近半年接手了一个非web开发类的工作，一直跟数据、数据库和脚本打交道，原项目是windows服bat脚本和.NET命令行程序来跑各种任务的。之前我没有太接触过shell这块，碰到这些bat脚本确实有点把我难到了，各方面相比bash来说还是有很大差距，于是我着手开始做迁移工作</p>\n<p>这里推荐一个简单的bash入门教程</p>\n<blockquote>\n<p><a href=\"https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md\">bash-handbook</a></p>\n</blockquote>\n<p>而复杂逻辑的exe部分，还是用我熟悉的node.js来重构，在此之前我还没有过命令行的开发经验，算是摸着石头过河</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html\">Node.js 命令行程序开发教程</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://juejin.im/post/5af2a2cbf265da0b9c109f59\">node.js 命令行工具(cli)</a></p>\n</blockquote>\n<h2 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h2><h3 id=\"链接为全局指令\"><a href=\"#链接为全局指令\" class=\"headerlink\" title=\"链接为全局指令\"></a>链接为全局指令</h3><p>大多数文档都会提到的一点，在<code>package.json</code>里的<code>bin</code>属性下写好指令名与代码路径后，执行<code>npm link</code>即可全局使用这个指令</p>\n<h3 id=\"注意当前目录\"><a href=\"#注意当前目录\" class=\"headerlink\" title=\"注意当前目录\"></a>注意当前目录</h3><p>记得代码可能会在任意目录上执行，因此用相对定位来读自己的代码目录内的文件是不可取的，如<code>let s = fs.readFileSync(&#39;./a.json&#39;)</code></p>\n<p>而应该改成使用<code>__dirname</code>来获取代码目录的绝对路径再去读文件，不过<code>require</code>函数不需要考虑这些，它会自己处理</p>\n<h3 id=\"获取和解析参数\"><a href=\"#获取和解析参数\" class=\"headerlink\" title=\"获取和解析参数\"></a>获取和解析参数</h3><p>我参考了npm上较为主流的几款命令行模块，看到大多是与具体函数耦合较紧的，需要用代码来配置命令行解析参数，这样的好处是能实现很多高级功能，如默认值、参数验证、自动生成帮助文档等。</p>\n<p>而我希望的是每次传不同的子命令时再去动态require代码，并且希望自定义帮助文档，因此只需要一套比较简单的解析库，拿到参数再自己处理，因此暂定使用了<a href=\"https://www.npmjs.com/package/yargs\">yargs</a></p>\n<h3 id=\"输出markdown文档到控制台\"><a href=\"#输出markdown文档到控制台\" class=\"headerlink\" title=\"输出markdown文档到控制台\"></a>输出markdown文档到控制台</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;marked&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> TerminalRenderer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;marked-terminal&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">marked.setOptions(&#123; <span class=\"attr\">renderer</span>: <span class=\"keyword\">new</span> TerminalRenderer(&#123; <span class=\"attr\">showSectionPrefix</span>: <span class=\"literal\">false</span> &#125;) &#125;);</span><br><span class=\"line\">process.stdout.write(marked(fs.readFileSync(path.join(__dirname, <span class=\"string\">&#x27;./readme.md&#x27;</span>)).toString()));</span><br></pre></td></tr></table></figure>\n<p><code>marked-terminal</code>模块将markdown文本转换为带有颜色信息的ANSI格式，然后输出到控制台，赏心悦目</p>\n<p><img src=\"/img/node_cmd_1.jpg\" alt=\"marked-terminal输出截图\"></p>\n<h3 id=\"从输入流读入数据\"><a href=\"#从输入流读入数据\" class=\"headerlink\" title=\"从输入流读入数据\"></a>从输入流读入数据</h3><p>想实现一个标准的UNIX类控制台程序，支持管道是必不可少的，得益于node的封装，我们有很简单的办法来获取输入流的数据</p>\n<ul>\n<li>从<a href=\"https://nodejs.org/dist/latest-v11.x/docs/api/process.html#process_process_stdin\">process.stdin</a>流式读取数据，这个时候我之前写的<a href=\"/Node对流的Promise包装和并发控制/\">Node对流的Promise包装和并发控制</a>模块就可以派上用场了</li>\n<li>直接用<code>fs.readFileSync(0)</code>读取全部内容，<code>0</code>就是标准输入流的文件句柄，当然前提是数据量不大或者需要完整解析的情况（如json），否则我们还是流式处理比较好</li>\n</ul>\n<h3 id=\"调试信息定向到stderr\"><a href=\"#调试信息定向到stderr\" class=\"headerlink\" title=\"调试信息定向到stderr\"></a>调试信息定向到stderr</h3><p>想保持标准输出，又想在控制台看到调试日志的输出，我们可以将调试的数据都发到<code>stderr</code>去，最终的运行结果才输出到<code>stdout</code></p>\n<p>在常用的日志模块<code>log4js</code>中，只要如此配置就好，这样所有日志输出都不会影响到标准输出流</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log4js.configure(&#123;</span><br><span class=\"line\">  appenders: &#123; <span class=\"attr\">err</span>: &#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;stderr&#x27;</span> &#125; &#125;,</span><br><span class=\"line\">  categories: &#123; <span class=\"attr\">default</span>: &#123; <span class=\"attr\">appenders</span>: [<span class=\"string\">&#x27;err&#x27;</span>], <span class=\"attr\">level</span>: <span class=\"string\">&#x27;all&#x27;</span> &#125; &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://log4js-node.github.io/log4js-node/stderr.html\">log4js文档</a></p>\n</blockquote>\n<h3 id=\"注意等待输出流写完成再关闭进程\"><a href=\"#注意等待输出流写完成再关闭进程\" class=\"headerlink\" title=\"注意等待输出流写完成再关闭进程\"></a>注意等待输出流写完成再关闭进程</h3><p>如果有输出流或者日志文件的情况，要注意不要轻易调用<code>process.exit</code>来主动结束进程，要等待流写入文件完成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//等待流写入完成</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ws.on(<span class=\"string\">&#x27;finish&#x27;</span>, resolve);</span><br><span class=\"line\">  ws.end();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//node4js的处理进程</span></span><br><span class=\"line\">log4js.shutdown(cb);</span><br></pre></td></tr></table></figure>\n<p>最好的情况是不写<code>process.exit</code>，只要记得<code>ws.end()</code>结束写入就行，当活动的流（包括标准输出流）全部完成，文件句柄释放后，进程自己会退出</p>\n<h3 id=\"使用更大的内存\"><a href=\"#使用更大的内存\" class=\"headerlink\" title=\"使用更大的内存\"></a>使用更大的内存</h3><p>node.js使用的v8引擎默认堆内存上限约1.7GB，而在环境变量中加上<code>NODE_OPTIONS</code>=<code>--max-old-space-size=40960</code>后可以扩大可使用的内存大小，当然用大内存不一定是好事，优化代码、精简数据结构、流式处理和避免闭包才是合理做法</p>\n<h3 id=\"使用烘焙-模板函数\"><a href=\"#使用烘焙-模板函数\" class=\"headerlink\" title=\"使用烘焙/模板函数\"></a>使用烘焙/模板函数</h3><p>在用一些模板或规则批量处理数据的时候，可以考虑使用预构建函数或烘焙模板来优化效率，前端的编译框架对这个就很有研究了，有兴趣可以了解下</p>\n<h3 id=\"对CSV做SQL查询\"><a href=\"#对CSV做SQL查询\" class=\"headerlink\" title=\"对CSV做SQL查询\"></a>对CSV做SQL查询</h3><p>有些复杂的业务需求需要对文件做数据统计汇总，原先是用<a href=\"https://www.npmjs.com/package/lodash\">lodash</a>的一套函数来处理，但未免还是有些繁复和难以阅读，后来引入了<a href=\"https://www.npmjs.com/package/alasql\">alasql</a>，支持流式地对文件进行sql查询，甚至支持连表语法，我目前也还在初步尝试阶段，有相关需求的可以了解下</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>得益于现在基本所有前端渲染/JS预编译框架都会用Node的CLI工具来提供服务，npm上会有很多方便的模块供我们使用，在这之上使用Node来开发命令行工具还是很方便快捷的，在shell上如果有复杂的实现需求，不妨试试用Node编写代码来处理</p>\n<p>关于控制台程序的一些理解和指导，推荐阅读《UNIX编程艺术》</p>\n"},{"title":"Node监视文件以实现热更新","desc":"在有限范围内使用效果还是很好的","author":"ngtmuzi","date":"2017-05-16T03:47:16.000Z","_content":"\n在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的[《Node.js Web应用代码热更新的另类思路》](http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/)，写得很详细考虑得也很全，我的思路也类似这样，不过在替换旧模块上有些不同，总结出来权当抛砖引玉。\n\n为了方便说明，部分代码有省略细节，详细可以参见[完整代码](https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js)\n\n## 需求\n\n我的最开始需求倒不是要实现热更新这样听起来很炫酷的功能，只是想动态更新配置文件（JSON或JS）的内容到内存，避免每次改小小的配置都要重启进程\n\n## 基本思路\n* 监视文件/目录改动\n* 清空require.cache中的模块缓存并重新require\n* 用新模块覆盖旧模块\n\n## 监视文件/目录改动\n\n### 定位\n首先使用`path.resolve`来定位文件，其实使用`require.resolve`可以根据[node寻找模块的规则](https://nodejs.org/api/modules.html#modules_file_modules)更智能地定位到一个模块的入口文件（比如xxx/index.js）的，但更多情况下我们并不只是监视这个index.js而是想监视整个文件夹的改动（举个例子，index.js里require了同目录的xx.json并做了一系列计算最后把计算结果挂载`module.exports`上，这个时候单单监视index.js是没什么用的。）\n\n### 监视/防抖动\n原本是简单地使用`fs.watch`来监视文件，但其在linux下是无法监视到子目录/文件的改动的（参见[node文档](https://nodejs.org/api/fs.html#fs_caveats)），因此后来改用了被众多知名工具依赖的文件监视模块[chokidar](https://github.com/paulmillr/chokidar)，并且出于实际情况增加了防抖动\n```javascript\nchokidar.watch(filePath).on('all', lodash.debounce(update, 300));\n```\n\n## 清空require.cache中的模块缓存并重新require\n\n### 清空缓存\n考虑到监视的有可能是一个目录而非单个文件的情况，我们需要在清除时多考虑一下，把整个目录的引用都清除掉\n```javascript\nObject.keys(require.cache).forEach(function (cachePath) {\n  if (cachePath.startsWith(filePath)) {\n    delete require.cache[cachePath];\n  }\n});\n```\n\n### 重新require\n```javascript\nvar newModule = require(filePath);\n```\n这个时候可能会报一些找不到文件，代码语法错误之类的同步错误，这个属于预期范围内，我的处理逻辑如下：\n* 第一次require是同步的，这时的错误会同步抛出，一般来说就会结束进程，因为确实没找到文件\n* 监视事件触发并重新require时产生的错误会丢给回调函数，并且保持原模块的内容不做更改（避免意外修改文件产生语法错误导致模块失效或进程退出）\n\n## 用新模块覆盖旧模块\n如果我们在使用模块时能够遵守一个约定：**`module.exports`是Object，且其他模块永远从该模块所暴露的`module.exports`上取值**，那么我们就不需要去做反射，闭包之类的处理，只要简单地使用\n```javascript\nObject.assign(target,newMoudle)\n```\n就可以在保持该对象的引用不变的情况下增改属性，考虑到有删除属性的情况，我自己写了一段比较暴力的覆写的函数\n```javascript\nfunction override(target, source) {\n  Object.keys(target).forEach(function (key) {\n    if (!source.hasOwnProperty(key)) delete target[key];\n  });\n  Object.keys(source).forEach(function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\n```\n外部模块只要是遵守了上述约定，就可以完全透明地取得最新的属性内容，对于我主要的应用场景——动态读取配置文件来说，这个还是很容易遵守的\n\n## 使用方式\n只有一个模块引用的话，直接调用即可\n```javascript\nconst some = watchModule('./originModule');\n//从module.exports上取得的一定是最新值\nconsole.log(some.a);\n```\n当有多处需要引用时，建议使用一个代理的模块来挂载，这样在其他模块就可以直接用普通的require了（注意不要对一个模块多次调用watchModule，这样会产生重复事件）\n```javascript\n//originModule\nmodule.exports={a:1}; \n\n//代理模块\nmodule.exports = watchModule('./originModule');\n\n//其他模块\nconst some = require('proxyModule');\n\n//从module.exports上取得的一定是最新值\nconsole.log(some.a);\n```\n具体到上面文章提到的express动态挂载路由，`app.use`需要的是一个函数，因此我们无能为力——原函数已经被`app.use`挂载到中间件链上了，这种情况还是考虑使用一层闭包吧\n\n## 总结\n思路都是类似的，只是我多加了一个约定，只要遵守这个约定我们就可以写出一个比较通用的监视模块，当然这也并不是万能的，比如module.exports必须是Object（其他类型可以用Object多包裹一层），很多极限条件也没考虑到（比如Proxy、不可变Object、原型链、不可枚举的属性等），但对于普通的业务代码和配置文件来说这应该是没有什么问题了  \n\n另外提醒一点，允许动态更新代码是**非常危险**的，比如我提到的这种允许读js作为配置文件的情况，万一js里来句`process.exit`或者其他恶意代码就挂了，可以根据实际需要来考虑加上限制\n\n[完整代码](https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js)，欢迎讨论指正。\n\n## 补充：旧模块资源的释放\n阅读了上面的文章后才发现确实没考虑到这里，并且由于配置文件并不是频繁改动，在正式环境下也没出现过问题，但测试过后确实存在旧模块没有释放的情况（考虑还是不周啊），我们可以参考上面文章中fangshi给出的代码来清除引用\n```javascript\n    var module = require.cache[modulePath];\n    // remove reference in module.parent\n    if (module.parent) {\n        module.parent.children.splice(module.parent.children.indexOf(module), 1);\n    }\n```\n","source":"_posts/Node监视文件以实现热更新.md","raw":"---\ntitle: Node监视文件以实现热更新\ndesc: 在有限范围内使用效果还是很好的\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2017-05-16 11:47:16\ntags:\n- nodejs\n---\n\n在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的[《Node.js Web应用代码热更新的另类思路》](http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/)，写得很详细考虑得也很全，我的思路也类似这样，不过在替换旧模块上有些不同，总结出来权当抛砖引玉。\n\n为了方便说明，部分代码有省略细节，详细可以参见[完整代码](https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js)\n\n## 需求\n\n我的最开始需求倒不是要实现热更新这样听起来很炫酷的功能，只是想动态更新配置文件（JSON或JS）的内容到内存，避免每次改小小的配置都要重启进程\n\n## 基本思路\n* 监视文件/目录改动\n* 清空require.cache中的模块缓存并重新require\n* 用新模块覆盖旧模块\n\n## 监视文件/目录改动\n\n### 定位\n首先使用`path.resolve`来定位文件，其实使用`require.resolve`可以根据[node寻找模块的规则](https://nodejs.org/api/modules.html#modules_file_modules)更智能地定位到一个模块的入口文件（比如xxx/index.js）的，但更多情况下我们并不只是监视这个index.js而是想监视整个文件夹的改动（举个例子，index.js里require了同目录的xx.json并做了一系列计算最后把计算结果挂载`module.exports`上，这个时候单单监视index.js是没什么用的。）\n\n### 监视/防抖动\n原本是简单地使用`fs.watch`来监视文件，但其在linux下是无法监视到子目录/文件的改动的（参见[node文档](https://nodejs.org/api/fs.html#fs_caveats)），因此后来改用了被众多知名工具依赖的文件监视模块[chokidar](https://github.com/paulmillr/chokidar)，并且出于实际情况增加了防抖动\n```javascript\nchokidar.watch(filePath).on('all', lodash.debounce(update, 300));\n```\n\n## 清空require.cache中的模块缓存并重新require\n\n### 清空缓存\n考虑到监视的有可能是一个目录而非单个文件的情况，我们需要在清除时多考虑一下，把整个目录的引用都清除掉\n```javascript\nObject.keys(require.cache).forEach(function (cachePath) {\n  if (cachePath.startsWith(filePath)) {\n    delete require.cache[cachePath];\n  }\n});\n```\n\n### 重新require\n```javascript\nvar newModule = require(filePath);\n```\n这个时候可能会报一些找不到文件，代码语法错误之类的同步错误，这个属于预期范围内，我的处理逻辑如下：\n* 第一次require是同步的，这时的错误会同步抛出，一般来说就会结束进程，因为确实没找到文件\n* 监视事件触发并重新require时产生的错误会丢给回调函数，并且保持原模块的内容不做更改（避免意外修改文件产生语法错误导致模块失效或进程退出）\n\n## 用新模块覆盖旧模块\n如果我们在使用模块时能够遵守一个约定：**`module.exports`是Object，且其他模块永远从该模块所暴露的`module.exports`上取值**，那么我们就不需要去做反射，闭包之类的处理，只要简单地使用\n```javascript\nObject.assign(target,newMoudle)\n```\n就可以在保持该对象的引用不变的情况下增改属性，考虑到有删除属性的情况，我自己写了一段比较暴力的覆写的函数\n```javascript\nfunction override(target, source) {\n  Object.keys(target).forEach(function (key) {\n    if (!source.hasOwnProperty(key)) delete target[key];\n  });\n  Object.keys(source).forEach(function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\n```\n外部模块只要是遵守了上述约定，就可以完全透明地取得最新的属性内容，对于我主要的应用场景——动态读取配置文件来说，这个还是很容易遵守的\n\n## 使用方式\n只有一个模块引用的话，直接调用即可\n```javascript\nconst some = watchModule('./originModule');\n//从module.exports上取得的一定是最新值\nconsole.log(some.a);\n```\n当有多处需要引用时，建议使用一个代理的模块来挂载，这样在其他模块就可以直接用普通的require了（注意不要对一个模块多次调用watchModule，这样会产生重复事件）\n```javascript\n//originModule\nmodule.exports={a:1}; \n\n//代理模块\nmodule.exports = watchModule('./originModule');\n\n//其他模块\nconst some = require('proxyModule');\n\n//从module.exports上取得的一定是最新值\nconsole.log(some.a);\n```\n具体到上面文章提到的express动态挂载路由，`app.use`需要的是一个函数，因此我们无能为力——原函数已经被`app.use`挂载到中间件链上了，这种情况还是考虑使用一层闭包吧\n\n## 总结\n思路都是类似的，只是我多加了一个约定，只要遵守这个约定我们就可以写出一个比较通用的监视模块，当然这也并不是万能的，比如module.exports必须是Object（其他类型可以用Object多包裹一层），很多极限条件也没考虑到（比如Proxy、不可变Object、原型链、不可枚举的属性等），但对于普通的业务代码和配置文件来说这应该是没有什么问题了  \n\n另外提醒一点，允许动态更新代码是**非常危险**的，比如我提到的这种允许读js作为配置文件的情况，万一js里来句`process.exit`或者其他恶意代码就挂了，可以根据实际需要来考虑加上限制\n\n[完整代码](https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js)，欢迎讨论指正。\n\n## 补充：旧模块资源的释放\n阅读了上面的文章后才发现确实没考虑到这里，并且由于配置文件并不是频繁改动，在正式环境下也没出现过问题，但测试过后确实存在旧模块没有释放的情况（考虑还是不周啊），我们可以参考上面文章中fangshi给出的代码来清除引用\n```javascript\n    var module = require.cache[modulePath];\n    // remove reference in module.parent\n    if (module.parent) {\n        module.parent.children.splice(module.parent.children.indexOf(module), 1);\n    }\n```\n","slug":"Node监视文件以实现热更新","published":1,"updated":"2020-06-17T10:26:40.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbg0008sou58x149p6y","content":"<p>在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的<a href=\"http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/\">《Node.js Web应用代码热更新的另类思路》</a>，写得很详细考虑得也很全，我的思路也类似这样，不过在替换旧模块上有些不同，总结出来权当抛砖引玉。</p>\n<p>为了方便说明，部分代码有省略细节，详细可以参见<a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js\">完整代码</a></p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>我的最开始需求倒不是要实现热更新这样听起来很炫酷的功能，只是想动态更新配置文件（JSON或JS）的内容到内存，避免每次改小小的配置都要重启进程</p>\n<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><ul>\n<li>监视文件/目录改动</li>\n<li>清空require.cache中的模块缓存并重新require</li>\n<li>用新模块覆盖旧模块</li>\n</ul>\n<h2 id=\"监视文件-目录改动\"><a href=\"#监视文件-目录改动\" class=\"headerlink\" title=\"监视文件/目录改动\"></a>监视文件/目录改动</h2><h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>首先使用<code>path.resolve</code>来定位文件，其实使用<code>require.resolve</code>可以根据<a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">node寻找模块的规则</a>更智能地定位到一个模块的入口文件（比如xxx/index.js）的，但更多情况下我们并不只是监视这个index.js而是想监视整个文件夹的改动（举个例子，index.js里require了同目录的xx.json并做了一系列计算最后把计算结果挂载<code>module.exports</code>上，这个时候单单监视index.js是没什么用的。）</p>\n<h3 id=\"监视-防抖动\"><a href=\"#监视-防抖动\" class=\"headerlink\" title=\"监视/防抖动\"></a>监视/防抖动</h3><p>原本是简单地使用<code>fs.watch</code>来监视文件，但其在linux下是无法监视到子目录/文件的改动的（参见<a href=\"https://nodejs.org/api/fs.html#fs_caveats\">node文档</a>），因此后来改用了被众多知名工具依赖的文件监视模块<a href=\"https://github.com/paulmillr/chokidar\">chokidar</a>，并且出于实际情况增加了防抖动<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chokidar.watch(filePath).on(<span class=\"string\">&#x27;all&#x27;</span>, lodash.debounce(update, <span class=\"number\">300</span>));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"清空require-cache中的模块缓存并重新require\"><a href=\"#清空require-cache中的模块缓存并重新require\" class=\"headerlink\" title=\"清空require.cache中的模块缓存并重新require\"></a>清空require.cache中的模块缓存并重新require</h2><h3 id=\"清空缓存\"><a href=\"#清空缓存\" class=\"headerlink\" title=\"清空缓存\"></a>清空缓存</h3><p>考虑到监视的有可能是一个目录而非单个文件的情况，我们需要在清除时多考虑一下，把整个目录的引用都清除掉<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">require</span>.cache).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cachePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cachePath.startsWith(filePath)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">require</span>.cache[cachePath];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"重新require\"><a href=\"#重新require\" class=\"headerlink\" title=\"重新require\"></a>重新require</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newModule = <span class=\"built_in\">require</span>(filePath);</span><br></pre></td></tr></table></figure>\n<p>这个时候可能会报一些找不到文件，代码语法错误之类的同步错误，这个属于预期范围内，我的处理逻辑如下：</p>\n<ul>\n<li>第一次require是同步的，这时的错误会同步抛出，一般来说就会结束进程，因为确实没找到文件</li>\n<li>监视事件触发并重新require时产生的错误会丢给回调函数，并且保持原模块的内容不做更改（避免意外修改文件产生语法错误导致模块失效或进程退出）</li>\n</ul>\n<h2 id=\"用新模块覆盖旧模块\"><a href=\"#用新模块覆盖旧模块\" class=\"headerlink\" title=\"用新模块覆盖旧模块\"></a>用新模块覆盖旧模块</h2><p>如果我们在使用模块时能够遵守一个约定：<strong><code>module.exports</code>是Object，且其他模块永远从该模块所暴露的<code>module.exports</code>上取值</strong>，那么我们就不需要去做反射，闭包之类的处理，只要简单地使用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(target,newMoudle)</span><br></pre></td></tr></table></figure><br>就可以在保持该对象的引用不变的情况下增改属性，考虑到有删除属性的情况，我自己写了一段比较暴力的覆写的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">override</span>(<span class=\"params\">target, source</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(target).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!source.hasOwnProperty(key)) <span class=\"keyword\">delete</span> target[key];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(source).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    target[key] = source[key];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>外部模块只要是遵守了上述约定，就可以完全透明地取得最新的属性内容，对于我主要的应用场景——动态读取配置文件来说，这个还是很容易遵守的</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><p>只有一个模块引用的话，直接调用即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> some = watchModule(<span class=\"string\">&#x27;./originModule&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//从module.exports上取得的一定是最新值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(some.a);</span><br></pre></td></tr></table></figure><br>当有多处需要引用时，建议使用一个代理的模块来挂载，这样在其他模块就可以直接用普通的require了（注意不要对一个模块多次调用watchModule，这样会产生重复事件）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//originModule</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//代理模块</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = watchModule(<span class=\"string\">&#x27;./originModule&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//其他模块</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> some = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;proxyModule&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从module.exports上取得的一定是最新值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(some.a);</span><br></pre></td></tr></table></figure><br>具体到上面文章提到的express动态挂载路由，<code>app.use</code>需要的是一个函数，因此我们无能为力——原函数已经被<code>app.use</code>挂载到中间件链上了，这种情况还是考虑使用一层闭包吧</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>思路都是类似的，只是我多加了一个约定，只要遵守这个约定我们就可以写出一个比较通用的监视模块，当然这也并不是万能的，比如module.exports必须是Object（其他类型可以用Object多包裹一层），很多极限条件也没考虑到（比如Proxy、不可变Object、原型链、不可枚举的属性等），但对于普通的业务代码和配置文件来说这应该是没有什么问题了  </p>\n<p>另外提醒一点，允许动态更新代码是<strong>非常危险</strong>的，比如我提到的这种允许读js作为配置文件的情况，万一js里来句<code>process.exit</code>或者其他恶意代码就挂了，可以根据实际需要来考虑加上限制</p>\n<p><a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js\">完整代码</a>，欢迎讨论指正。</p>\n<h2 id=\"补充：旧模块资源的释放\"><a href=\"#补充：旧模块资源的释放\" class=\"headerlink\" title=\"补充：旧模块资源的释放\"></a>补充：旧模块资源的释放</h2><p>阅读了上面的文章后才发现确实没考虑到这里，并且由于配置文件并不是频繁改动，在正式环境下也没出现过问题，但测试过后确实存在旧模块没有释放的情况（考虑还是不周啊），我们可以参考上面文章中fangshi给出的代码来清除引用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = <span class=\"built_in\">require</span>.cache[modulePath];</span><br><span class=\"line\"><span class=\"comment\">// remove reference in module.parent</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.parent) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.parent.children.splice(<span class=\"built_in\">module</span>.parent.children.indexOf(<span class=\"built_in\">module</span>), <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在准备开始写的时候搜了一下相关的文章，看到了这篇fangshi的<a href=\"http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/\">《Node.js Web应用代码热更新的另类思路》</a>，写得很详细考虑得也很全，我的思路也类似这样，不过在替换旧模块上有些不同，总结出来权当抛砖引玉。</p>\n<p>为了方便说明，部分代码有省略细节，详细可以参见<a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js\">完整代码</a></p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>我的最开始需求倒不是要实现热更新这样听起来很炫酷的功能，只是想动态更新配置文件（JSON或JS）的内容到内存，避免每次改小小的配置都要重启进程</p>\n<h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2><ul>\n<li>监视文件/目录改动</li>\n<li>清空require.cache中的模块缓存并重新require</li>\n<li>用新模块覆盖旧模块</li>\n</ul>\n<h2 id=\"监视文件-目录改动\"><a href=\"#监视文件-目录改动\" class=\"headerlink\" title=\"监视文件/目录改动\"></a>监视文件/目录改动</h2><h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3><p>首先使用<code>path.resolve</code>来定位文件，其实使用<code>require.resolve</code>可以根据<a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">node寻找模块的规则</a>更智能地定位到一个模块的入口文件（比如xxx/index.js）的，但更多情况下我们并不只是监视这个index.js而是想监视整个文件夹的改动（举个例子，index.js里require了同目录的xx.json并做了一系列计算最后把计算结果挂载<code>module.exports</code>上，这个时候单单监视index.js是没什么用的。）</p>\n<h3 id=\"监视-防抖动\"><a href=\"#监视-防抖动\" class=\"headerlink\" title=\"监视/防抖动\"></a>监视/防抖动</h3><p>原本是简单地使用<code>fs.watch</code>来监视文件，但其在linux下是无法监视到子目录/文件的改动的（参见<a href=\"https://nodejs.org/api/fs.html#fs_caveats\">node文档</a>），因此后来改用了被众多知名工具依赖的文件监视模块<a href=\"https://github.com/paulmillr/chokidar\">chokidar</a>，并且出于实际情况增加了防抖动<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chokidar.watch(filePath).on(<span class=\"string\">&#x27;all&#x27;</span>, lodash.debounce(update, <span class=\"number\">300</span>));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"清空require-cache中的模块缓存并重新require\"><a href=\"#清空require-cache中的模块缓存并重新require\" class=\"headerlink\" title=\"清空require.cache中的模块缓存并重新require\"></a>清空require.cache中的模块缓存并重新require</h2><h3 id=\"清空缓存\"><a href=\"#清空缓存\" class=\"headerlink\" title=\"清空缓存\"></a>清空缓存</h3><p>考虑到监视的有可能是一个目录而非单个文件的情况，我们需要在清除时多考虑一下，把整个目录的引用都清除掉<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">require</span>.cache).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cachePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cachePath.startsWith(filePath)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"built_in\">require</span>.cache[cachePath];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"重新require\"><a href=\"#重新require\" class=\"headerlink\" title=\"重新require\"></a>重新require</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newModule = <span class=\"built_in\">require</span>(filePath);</span><br></pre></td></tr></table></figure>\n<p>这个时候可能会报一些找不到文件，代码语法错误之类的同步错误，这个属于预期范围内，我的处理逻辑如下：</p>\n<ul>\n<li>第一次require是同步的，这时的错误会同步抛出，一般来说就会结束进程，因为确实没找到文件</li>\n<li>监视事件触发并重新require时产生的错误会丢给回调函数，并且保持原模块的内容不做更改（避免意外修改文件产生语法错误导致模块失效或进程退出）</li>\n</ul>\n<h2 id=\"用新模块覆盖旧模块\"><a href=\"#用新模块覆盖旧模块\" class=\"headerlink\" title=\"用新模块覆盖旧模块\"></a>用新模块覆盖旧模块</h2><p>如果我们在使用模块时能够遵守一个约定：<strong><code>module.exports</code>是Object，且其他模块永远从该模块所暴露的<code>module.exports</code>上取值</strong>，那么我们就不需要去做反射，闭包之类的处理，只要简单地使用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(target,newMoudle)</span><br></pre></td></tr></table></figure><br>就可以在保持该对象的引用不变的情况下增改属性，考虑到有删除属性的情况，我自己写了一段比较暴力的覆写的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">override</span>(<span class=\"params\">target, source</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(target).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!source.hasOwnProperty(key)) <span class=\"keyword\">delete</span> target[key];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(source).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    target[key] = source[key];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>外部模块只要是遵守了上述约定，就可以完全透明地取得最新的属性内容，对于我主要的应用场景——动态读取配置文件来说，这个还是很容易遵守的</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><p>只有一个模块引用的话，直接调用即可<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> some = watchModule(<span class=\"string\">&#x27;./originModule&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//从module.exports上取得的一定是最新值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(some.a);</span><br></pre></td></tr></table></figure><br>当有多处需要引用时，建议使用一个代理的模块来挂载，这样在其他模块就可以直接用普通的require了（注意不要对一个模块多次调用watchModule，这样会产生重复事件）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//originModule</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//代理模块</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = watchModule(<span class=\"string\">&#x27;./originModule&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//其他模块</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> some = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;proxyModule&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从module.exports上取得的一定是最新值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(some.a);</span><br></pre></td></tr></table></figure><br>具体到上面文章提到的express动态挂载路由，<code>app.use</code>需要的是一个函数，因此我们无能为力——原函数已经被<code>app.use</code>挂载到中间件链上了，这种情况还是考虑使用一层闭包吧</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>思路都是类似的，只是我多加了一个约定，只要遵守这个约定我们就可以写出一个比较通用的监视模块，当然这也并不是万能的，比如module.exports必须是Object（其他类型可以用Object多包裹一层），很多极限条件也没考虑到（比如Proxy、不可变Object、原型链、不可枚举的属性等），但对于普通的业务代码和配置文件来说这应该是没有什么问题了  </p>\n<p>另外提醒一点，允许动态更新代码是<strong>非常危险</strong>的，比如我提到的这种允许读js作为配置文件的情况，万一js里来句<code>process.exit</code>或者其他恶意代码就挂了，可以根据实际需要来考虑加上限制</p>\n<p><a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/watchModule/index.js\">完整代码</a>，欢迎讨论指正。</p>\n<h2 id=\"补充：旧模块资源的释放\"><a href=\"#补充：旧模块资源的释放\" class=\"headerlink\" title=\"补充：旧模块资源的释放\"></a>补充：旧模块资源的释放</h2><p>阅读了上面的文章后才发现确实没考虑到这里，并且由于配置文件并不是频繁改动，在正式环境下也没出现过问题，但测试过后确实存在旧模块没有释放的情况（考虑还是不周啊），我们可以参考上面文章中fangshi给出的代码来清除引用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = <span class=\"built_in\">require</span>.cache[modulePath];</span><br><span class=\"line\"><span class=\"comment\">// remove reference in module.parent</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.parent) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.parent.children.splice(<span class=\"built_in\">module</span>.parent.children.indexOf(<span class=\"built_in\">module</span>), <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Nuxt.js试用小结","desc":"个人使用的一些体会，不全面","author":"ngtmuzi","date":"2017-09-04T01:39:13.000Z","_content":"\n以下为个人使用`Nuxt.js`的一些体会总结，并不全面，并且该项目还在频繁更新中（目前是v1.0.0-rc8），文档/中文文档并不完善，可以在小项目中先试手\n\n## 什么是`Nuxt.js`\n\n[Nuxt.js官网](https://nuxtjs.org/guide)\n\n>Nuxt.js 是一个基于 Vue.js 的通用应用框架。  \n>通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。  \n>我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。  \n>Nuxt.js 预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。\n\n可以把它认为是更完善的vue开发脚手架，但比之脚手架它提供了更多概念上的抽象定义，也实现了一些更高级的特性诸如服务端渲染\n\n## 安装\n官方推荐使用`vue-cli`来安装\n```cmd\n$ vue init nuxt/starter <project-name>\n$ cd <project-name>\n$ npm install\n```\n\n## 概念介绍\n\n主要摘录和总结自官方文档，但由于文档/中文文档更新速度没更上代码的速度，可能有部分出入\n\n### 页面(page)\n\n本质是vue组件，其文件在pages目录中的所处的路径决定了在url中访问的路径，并且`Nuxt.js`在其中新增了一些新属性，[官方文档](https://nuxtjs.org/guide/views#pages)\n\n比较需要注意的就是`asyncData`和`layout`，前者用于在显示页面前获取异步的数据，后者指定渲染的布局\n\n### asyncData方法\n\n[官方文档](https://nuxtjs.org/api)\n\n在`page`组件传入vue渲染前会调用`asyncData`方法，其接受`Promise`的返回，当然现在更好的选择是使用`async/await`特性，最终返回的结果会并入`page`组件的`data`属性中\n\n注意该方法传递的第一个参数是`Nuxt.js`提供的该页面的`context`对象，其提供了不少常用的属性和方法，如判断当前渲染环境，以及路由跳转，跳到错误页面等，但比较神奇的一点是你除了在`asyncData`里，好像没法在别的地方找到这个`context`，我们可以在外部定义一个变量去指向它，以便在其他时候去使用（更坑的一点是，当使用服务端渲染时，前端是不会调用`asyncData`的，也就无法获得`context`）\n\n### 布局(layout)\n\n在外部包裹`page`的布局主体（参考其他服务端渲染的框架如ejs），一些公共的，例如声明全局组件之类的语句可以放在这层\n\n## 一些坑\n\n以下为使用`v1.0.0-rc6`版本遇到的一些问题，不确定新版本是否有修复，或者是否是个人理解有误\n\n### 服务端渲染\n\n作为一个node后端开发，我至今无法在官方文档中找到一个简单明了的示例告诉我如何使用服务端渲染的功能，在官方的诸如`express`、`koa`示例程序中，我能看到的只有类似`app.use(nuxt.render)`的这种写法，这意味着我们并不能像传统的服务端渲染框架（以ejs为例）那样，传递一个包含着所有服务端数据的对象（`res.local`）给`render`函数\n\n据我的理解，`Nuxt.js`致力完成的是“通用”的vue框架，它想使这个框架无论是前端还是后端渲染，都使用同样的代码，也就是说它始终在`asyncData`函数中去获取数据，这使得我们原本的node后端连简单地传递一个内存变量都很难做到\n\n这是非常坑的一点，当`nuxt.config.js`中的`mode`处于`universal`时（默认是这个），前后端都有可能调用`asyncData`函数，`Nuxt.js`的示例里充斥着`axios`模块的引用，只是因为它在浏览器和node都可以运行，换句话来说，万一我们在`asyncData`使用的模块并不支持浏览器/node环境，就会出现问题\n\n因此我现在只将`Nuxt.js`视为一个前端spa应用脚手架（在`nuxt.config.js`中设置`mode='spa'`），而不会去用于服务端渲染，也只有在设置`mode='spa'`之后，我们才能使用`nuxt generate`来正确生成一个单页静态前端项目\n\n### plugins和modules\n\n官方建议我们把会反复用到的模块写在plugins里，甚至还要指明哪些是仅限服务端用的，哪些是浏览器用的，但却没有具体示例指出具体用途，至今还是很难理解这个逻辑\n\n最近的版本还出现了modules目录，看起来是用于放置服务端的模块，具体文档太少也无法理解\n\n### 前端动态路由\n\n我们应该这样理解：*所有页面的路由逻辑都交给前端*，如果后端找不到url对应的接口/文件（即匹配不到任何路由，需要返回404的时候），应该渲染首页，由前端来告诉用户该页面不存在（Nuxt.js内置了错误页面）\n\n## 使用总结\n\n个人用它结合`ElementUI`开发了一个简单的报表显示页面，不得不说预置layout+page的方式使得开发方便不少，但`asyncData`的运行环境问题还是一直在困扰我，最终还是抛弃了与印象中有很大出入的“服务端渲染”，设置`mode='spa'`来生成静态前端页面，将它视为一个高级脚手架来用还是很不错的\n\n目前该项目还在频繁更新，尚未发布正式版1.0，文档更新滞后且稍显混乱，部分细节没有介绍，因此目前不建议用于正式项目","source":"_posts/Nuxt-js试用小结.md","raw":"---\ntitle: Nuxt.js试用小结\ndesc: 个人使用的一些体会，不全面\nauthor: ngtmuzi\ncategory: 班门弄斧 \ndate: 2017-09-04 09:39:13\ntags:\n- vue\n- 前端\n- javascript\n---\n\n以下为个人使用`Nuxt.js`的一些体会总结，并不全面，并且该项目还在频繁更新中（目前是v1.0.0-rc8），文档/中文文档并不完善，可以在小项目中先试手\n\n## 什么是`Nuxt.js`\n\n[Nuxt.js官网](https://nuxtjs.org/guide)\n\n>Nuxt.js 是一个基于 Vue.js 的通用应用框架。  \n>通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。  \n>我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。  \n>Nuxt.js 预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。\n\n可以把它认为是更完善的vue开发脚手架，但比之脚手架它提供了更多概念上的抽象定义，也实现了一些更高级的特性诸如服务端渲染\n\n## 安装\n官方推荐使用`vue-cli`来安装\n```cmd\n$ vue init nuxt/starter <project-name>\n$ cd <project-name>\n$ npm install\n```\n\n## 概念介绍\n\n主要摘录和总结自官方文档，但由于文档/中文文档更新速度没更上代码的速度，可能有部分出入\n\n### 页面(page)\n\n本质是vue组件，其文件在pages目录中的所处的路径决定了在url中访问的路径，并且`Nuxt.js`在其中新增了一些新属性，[官方文档](https://nuxtjs.org/guide/views#pages)\n\n比较需要注意的就是`asyncData`和`layout`，前者用于在显示页面前获取异步的数据，后者指定渲染的布局\n\n### asyncData方法\n\n[官方文档](https://nuxtjs.org/api)\n\n在`page`组件传入vue渲染前会调用`asyncData`方法，其接受`Promise`的返回，当然现在更好的选择是使用`async/await`特性，最终返回的结果会并入`page`组件的`data`属性中\n\n注意该方法传递的第一个参数是`Nuxt.js`提供的该页面的`context`对象，其提供了不少常用的属性和方法，如判断当前渲染环境，以及路由跳转，跳到错误页面等，但比较神奇的一点是你除了在`asyncData`里，好像没法在别的地方找到这个`context`，我们可以在外部定义一个变量去指向它，以便在其他时候去使用（更坑的一点是，当使用服务端渲染时，前端是不会调用`asyncData`的，也就无法获得`context`）\n\n### 布局(layout)\n\n在外部包裹`page`的布局主体（参考其他服务端渲染的框架如ejs），一些公共的，例如声明全局组件之类的语句可以放在这层\n\n## 一些坑\n\n以下为使用`v1.0.0-rc6`版本遇到的一些问题，不确定新版本是否有修复，或者是否是个人理解有误\n\n### 服务端渲染\n\n作为一个node后端开发，我至今无法在官方文档中找到一个简单明了的示例告诉我如何使用服务端渲染的功能，在官方的诸如`express`、`koa`示例程序中，我能看到的只有类似`app.use(nuxt.render)`的这种写法，这意味着我们并不能像传统的服务端渲染框架（以ejs为例）那样，传递一个包含着所有服务端数据的对象（`res.local`）给`render`函数\n\n据我的理解，`Nuxt.js`致力完成的是“通用”的vue框架，它想使这个框架无论是前端还是后端渲染，都使用同样的代码，也就是说它始终在`asyncData`函数中去获取数据，这使得我们原本的node后端连简单地传递一个内存变量都很难做到\n\n这是非常坑的一点，当`nuxt.config.js`中的`mode`处于`universal`时（默认是这个），前后端都有可能调用`asyncData`函数，`Nuxt.js`的示例里充斥着`axios`模块的引用，只是因为它在浏览器和node都可以运行，换句话来说，万一我们在`asyncData`使用的模块并不支持浏览器/node环境，就会出现问题\n\n因此我现在只将`Nuxt.js`视为一个前端spa应用脚手架（在`nuxt.config.js`中设置`mode='spa'`），而不会去用于服务端渲染，也只有在设置`mode='spa'`之后，我们才能使用`nuxt generate`来正确生成一个单页静态前端项目\n\n### plugins和modules\n\n官方建议我们把会反复用到的模块写在plugins里，甚至还要指明哪些是仅限服务端用的，哪些是浏览器用的，但却没有具体示例指出具体用途，至今还是很难理解这个逻辑\n\n最近的版本还出现了modules目录，看起来是用于放置服务端的模块，具体文档太少也无法理解\n\n### 前端动态路由\n\n我们应该这样理解：*所有页面的路由逻辑都交给前端*，如果后端找不到url对应的接口/文件（即匹配不到任何路由，需要返回404的时候），应该渲染首页，由前端来告诉用户该页面不存在（Nuxt.js内置了错误页面）\n\n## 使用总结\n\n个人用它结合`ElementUI`开发了一个简单的报表显示页面，不得不说预置layout+page的方式使得开发方便不少，但`asyncData`的运行环境问题还是一直在困扰我，最终还是抛弃了与印象中有很大出入的“服务端渲染”，设置`mode='spa'`来生成静态前端页面，将它视为一个高级脚手架来用还是很不错的\n\n目前该项目还在频繁更新，尚未发布正式版1.0，文档更新滞后且稍显混乱，部分细节没有介绍，因此目前不建议用于正式项目","slug":"Nuxt-js试用小结","published":1,"updated":"2020-06-17T10:26:40.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbh0009sou54zym7f9m","content":"<p>以下为个人使用<code>Nuxt.js</code>的一些体会总结，并不全面，并且该项目还在频繁更新中（目前是v1.0.0-rc8），文档/中文文档并不完善，可以在小项目中先试手</p>\n<h2 id=\"什么是Nuxt-js\"><a href=\"#什么是Nuxt-js\" class=\"headerlink\" title=\"什么是Nuxt.js\"></a>什么是<code>Nuxt.js</code></h2><p><a href=\"https://nuxtjs.org/guide\">Nuxt.js官网</a></p>\n<blockquote>\n<p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。<br>通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。<br>我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。<br>Nuxt.js 预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。</p>\n</blockquote>\n<p>可以把它认为是更完善的vue开发脚手架，但比之脚手架它提供了更多概念上的抽象定义，也实现了一些更高级的特性诸如服务端渲染</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>官方推荐使用<code>vue-cli</code>来安装<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vue init nuxt/starter &lt;project-name&gt;</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> &lt;project-name&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"概念介绍\"><a href=\"#概念介绍\" class=\"headerlink\" title=\"概念介绍\"></a>概念介绍</h2><p>主要摘录和总结自官方文档，但由于文档/中文文档更新速度没更上代码的速度，可能有部分出入</p>\n<h3 id=\"页面-page\"><a href=\"#页面-page\" class=\"headerlink\" title=\"页面(page)\"></a>页面(page)</h3><p>本质是vue组件，其文件在pages目录中的所处的路径决定了在url中访问的路径，并且<code>Nuxt.js</code>在其中新增了一些新属性，<a href=\"https://nuxtjs.org/guide/views#pages\">官方文档</a></p>\n<p>比较需要注意的就是<code>asyncData</code>和<code>layout</code>，前者用于在显示页面前获取异步的数据，后者指定渲染的布局</p>\n<h3 id=\"asyncData方法\"><a href=\"#asyncData方法\" class=\"headerlink\" title=\"asyncData方法\"></a>asyncData方法</h3><p><a href=\"https://nuxtjs.org/api\">官方文档</a></p>\n<p>在<code>page</code>组件传入vue渲染前会调用<code>asyncData</code>方法，其接受<code>Promise</code>的返回，当然现在更好的选择是使用<code>async/await</code>特性，最终返回的结果会并入<code>page</code>组件的<code>data</code>属性中</p>\n<p>注意该方法传递的第一个参数是<code>Nuxt.js</code>提供的该页面的<code>context</code>对象，其提供了不少常用的属性和方法，如判断当前渲染环境，以及路由跳转，跳到错误页面等，但比较神奇的一点是你除了在<code>asyncData</code>里，好像没法在别的地方找到这个<code>context</code>，我们可以在外部定义一个变量去指向它，以便在其他时候去使用（更坑的一点是，当使用服务端渲染时，前端是不会调用<code>asyncData</code>的，也就无法获得<code>context</code>）</p>\n<h3 id=\"布局-layout\"><a href=\"#布局-layout\" class=\"headerlink\" title=\"布局(layout)\"></a>布局(layout)</h3><p>在外部包裹<code>page</code>的布局主体（参考其他服务端渲染的框架如ejs），一些公共的，例如声明全局组件之类的语句可以放在这层</p>\n<h2 id=\"一些坑\"><a href=\"#一些坑\" class=\"headerlink\" title=\"一些坑\"></a>一些坑</h2><p>以下为使用<code>v1.0.0-rc6</code>版本遇到的一些问题，不确定新版本是否有修复，或者是否是个人理解有误</p>\n<h3 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h3><p>作为一个node后端开发，我至今无法在官方文档中找到一个简单明了的示例告诉我如何使用服务端渲染的功能，在官方的诸如<code>express</code>、<code>koa</code>示例程序中，我能看到的只有类似<code>app.use(nuxt.render)</code>的这种写法，这意味着我们并不能像传统的服务端渲染框架（以ejs为例）那样，传递一个包含着所有服务端数据的对象（<code>res.local</code>）给<code>render</code>函数</p>\n<p>据我的理解，<code>Nuxt.js</code>致力完成的是“通用”的vue框架，它想使这个框架无论是前端还是后端渲染，都使用同样的代码，也就是说它始终在<code>asyncData</code>函数中去获取数据，这使得我们原本的node后端连简单地传递一个内存变量都很难做到</p>\n<p>这是非常坑的一点，当<code>nuxt.config.js</code>中的<code>mode</code>处于<code>universal</code>时（默认是这个），前后端都有可能调用<code>asyncData</code>函数，<code>Nuxt.js</code>的示例里充斥着<code>axios</code>模块的引用，只是因为它在浏览器和node都可以运行，换句话来说，万一我们在<code>asyncData</code>使用的模块并不支持浏览器/node环境，就会出现问题</p>\n<p>因此我现在只将<code>Nuxt.js</code>视为一个前端spa应用脚手架（在<code>nuxt.config.js</code>中设置<code>mode=&#39;spa&#39;</code>），而不会去用于服务端渲染，也只有在设置<code>mode=&#39;spa&#39;</code>之后，我们才能使用<code>nuxt generate</code>来正确生成一个单页静态前端项目</p>\n<h3 id=\"plugins和modules\"><a href=\"#plugins和modules\" class=\"headerlink\" title=\"plugins和modules\"></a>plugins和modules</h3><p>官方建议我们把会反复用到的模块写在plugins里，甚至还要指明哪些是仅限服务端用的，哪些是浏览器用的，但却没有具体示例指出具体用途，至今还是很难理解这个逻辑</p>\n<p>最近的版本还出现了modules目录，看起来是用于放置服务端的模块，具体文档太少也无法理解</p>\n<h3 id=\"前端动态路由\"><a href=\"#前端动态路由\" class=\"headerlink\" title=\"前端动态路由\"></a>前端动态路由</h3><p>我们应该这样理解：<em>所有页面的路由逻辑都交给前端</em>，如果后端找不到url对应的接口/文件（即匹配不到任何路由，需要返回404的时候），应该渲染首页，由前端来告诉用户该页面不存在（Nuxt.js内置了错误页面）</p>\n<h2 id=\"使用总结\"><a href=\"#使用总结\" class=\"headerlink\" title=\"使用总结\"></a>使用总结</h2><p>个人用它结合<code>ElementUI</code>开发了一个简单的报表显示页面，不得不说预置layout+page的方式使得开发方便不少，但<code>asyncData</code>的运行环境问题还是一直在困扰我，最终还是抛弃了与印象中有很大出入的“服务端渲染”，设置<code>mode=&#39;spa&#39;</code>来生成静态前端页面，将它视为一个高级脚手架来用还是很不错的</p>\n<p>目前该项目还在频繁更新，尚未发布正式版1.0，文档更新滞后且稍显混乱，部分细节没有介绍，因此目前不建议用于正式项目</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以下为个人使用<code>Nuxt.js</code>的一些体会总结，并不全面，并且该项目还在频繁更新中（目前是v1.0.0-rc8），文档/中文文档并不完善，可以在小项目中先试手</p>\n<h2 id=\"什么是Nuxt-js\"><a href=\"#什么是Nuxt-js\" class=\"headerlink\" title=\"什么是Nuxt.js\"></a>什么是<code>Nuxt.js</code></h2><p><a href=\"https://nuxtjs.org/guide\">Nuxt.js官网</a></p>\n<blockquote>\n<p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。<br>通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。<br>我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。<br>Nuxt.js 预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。</p>\n</blockquote>\n<p>可以把它认为是更完善的vue开发脚手架，但比之脚手架它提供了更多概念上的抽象定义，也实现了一些更高级的特性诸如服务端渲染</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>官方推荐使用<code>vue-cli</code>来安装<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vue init nuxt/starter &lt;project-name&gt;</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> &lt;project-name&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"概念介绍\"><a href=\"#概念介绍\" class=\"headerlink\" title=\"概念介绍\"></a>概念介绍</h2><p>主要摘录和总结自官方文档，但由于文档/中文文档更新速度没更上代码的速度，可能有部分出入</p>\n<h3 id=\"页面-page\"><a href=\"#页面-page\" class=\"headerlink\" title=\"页面(page)\"></a>页面(page)</h3><p>本质是vue组件，其文件在pages目录中的所处的路径决定了在url中访问的路径，并且<code>Nuxt.js</code>在其中新增了一些新属性，<a href=\"https://nuxtjs.org/guide/views#pages\">官方文档</a></p>\n<p>比较需要注意的就是<code>asyncData</code>和<code>layout</code>，前者用于在显示页面前获取异步的数据，后者指定渲染的布局</p>\n<h3 id=\"asyncData方法\"><a href=\"#asyncData方法\" class=\"headerlink\" title=\"asyncData方法\"></a>asyncData方法</h3><p><a href=\"https://nuxtjs.org/api\">官方文档</a></p>\n<p>在<code>page</code>组件传入vue渲染前会调用<code>asyncData</code>方法，其接受<code>Promise</code>的返回，当然现在更好的选择是使用<code>async/await</code>特性，最终返回的结果会并入<code>page</code>组件的<code>data</code>属性中</p>\n<p>注意该方法传递的第一个参数是<code>Nuxt.js</code>提供的该页面的<code>context</code>对象，其提供了不少常用的属性和方法，如判断当前渲染环境，以及路由跳转，跳到错误页面等，但比较神奇的一点是你除了在<code>asyncData</code>里，好像没法在别的地方找到这个<code>context</code>，我们可以在外部定义一个变量去指向它，以便在其他时候去使用（更坑的一点是，当使用服务端渲染时，前端是不会调用<code>asyncData</code>的，也就无法获得<code>context</code>）</p>\n<h3 id=\"布局-layout\"><a href=\"#布局-layout\" class=\"headerlink\" title=\"布局(layout)\"></a>布局(layout)</h3><p>在外部包裹<code>page</code>的布局主体（参考其他服务端渲染的框架如ejs），一些公共的，例如声明全局组件之类的语句可以放在这层</p>\n<h2 id=\"一些坑\"><a href=\"#一些坑\" class=\"headerlink\" title=\"一些坑\"></a>一些坑</h2><p>以下为使用<code>v1.0.0-rc6</code>版本遇到的一些问题，不确定新版本是否有修复，或者是否是个人理解有误</p>\n<h3 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h3><p>作为一个node后端开发，我至今无法在官方文档中找到一个简单明了的示例告诉我如何使用服务端渲染的功能，在官方的诸如<code>express</code>、<code>koa</code>示例程序中，我能看到的只有类似<code>app.use(nuxt.render)</code>的这种写法，这意味着我们并不能像传统的服务端渲染框架（以ejs为例）那样，传递一个包含着所有服务端数据的对象（<code>res.local</code>）给<code>render</code>函数</p>\n<p>据我的理解，<code>Nuxt.js</code>致力完成的是“通用”的vue框架，它想使这个框架无论是前端还是后端渲染，都使用同样的代码，也就是说它始终在<code>asyncData</code>函数中去获取数据，这使得我们原本的node后端连简单地传递一个内存变量都很难做到</p>\n<p>这是非常坑的一点，当<code>nuxt.config.js</code>中的<code>mode</code>处于<code>universal</code>时（默认是这个），前后端都有可能调用<code>asyncData</code>函数，<code>Nuxt.js</code>的示例里充斥着<code>axios</code>模块的引用，只是因为它在浏览器和node都可以运行，换句话来说，万一我们在<code>asyncData</code>使用的模块并不支持浏览器/node环境，就会出现问题</p>\n<p>因此我现在只将<code>Nuxt.js</code>视为一个前端spa应用脚手架（在<code>nuxt.config.js</code>中设置<code>mode=&#39;spa&#39;</code>），而不会去用于服务端渲染，也只有在设置<code>mode=&#39;spa&#39;</code>之后，我们才能使用<code>nuxt generate</code>来正确生成一个单页静态前端项目</p>\n<h3 id=\"plugins和modules\"><a href=\"#plugins和modules\" class=\"headerlink\" title=\"plugins和modules\"></a>plugins和modules</h3><p>官方建议我们把会反复用到的模块写在plugins里，甚至还要指明哪些是仅限服务端用的，哪些是浏览器用的，但却没有具体示例指出具体用途，至今还是很难理解这个逻辑</p>\n<p>最近的版本还出现了modules目录，看起来是用于放置服务端的模块，具体文档太少也无法理解</p>\n<h3 id=\"前端动态路由\"><a href=\"#前端动态路由\" class=\"headerlink\" title=\"前端动态路由\"></a>前端动态路由</h3><p>我们应该这样理解：<em>所有页面的路由逻辑都交给前端</em>，如果后端找不到url对应的接口/文件（即匹配不到任何路由，需要返回404的时候），应该渲染首页，由前端来告诉用户该页面不存在（Nuxt.js内置了错误页面）</p>\n<h2 id=\"使用总结\"><a href=\"#使用总结\" class=\"headerlink\" title=\"使用总结\"></a>使用总结</h2><p>个人用它结合<code>ElementUI</code>开发了一个简单的报表显示页面，不得不说预置layout+page的方式使得开发方便不少，但<code>asyncData</code>的运行环境问题还是一直在困扰我，最终还是抛弃了与印象中有很大出入的“服务端渲染”，设置<code>mode=&#39;spa&#39;</code>来生成静态前端页面，将它视为一个高级脚手架来用还是很不错的</p>\n<p>目前该项目还在频繁更新，尚未发布正式版1.0，文档更新滞后且稍显混乱，部分细节没有介绍，因此目前不建议用于正式项目</p>\n"},{"title":"PWA脚手架Lavas试用小结","desc":"来自百度的vue+pwa解决方案","author":"ngtmuzi","date":"2017-09-18T08:48:14.000Z","_content":"\n## 简介\n\n基本摘自[Lavas官网](https://lavas.baidu.com)\n\n### [什么是PWA](https://lavas.baidu.com/doc)\n\nProgressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。\n\nPWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。\n\nPWA 的主要特点包括下面三点：\n\n* 可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现\n* 体验 - 快速响应，并且有平滑的动画响应用户的操作\n* 粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面\n\n### [Lavas 是什么](https://lavas.baidu.com/guide)\n\nLavas 是一个基于 Vue 的 PWA (Progressive Web Apps) 完整解决方案。我们将 PWA 的工程实践总结成多种 Lavas 应用框架模板，帮助开发者轻松搭建 PWA 站点，且无需过多的关注 PWA 开发本身。\n\n## 安装\n```cmd\nnpm install -g lavas\nlavas init\n```\nlavas的命令行工具提供了挺多的步骤流程来配置工程，还都是中文，这点很舒服\n\n## 概念介绍\n\n我们这里谈论的是appshell模板\n\nlavas并没有引入过多的抽象概念，基本类似一个普通的vue单页应用脚手架，不过提供了一套通用的静态文件缓存/更新的方案，使我们不需要任何配置就可以实现基本的静态文件缓存功能，这点很赞\n\n### AppShell\n\n这是谷歌提出来的一个[概念](https://developers.google.cn/web/fundamentals/architecture/app-shell)，而lavas的解释如下\n\n> App Shell 架构是构建 PWA 应用的一种方式，它通常提供了一个最基本的 Web App 框架，包括应用的头部、底部、菜单栏等结构。顾名思义，我们可以把它理解成应用的一个「空壳」，这个「空壳」仅包含页面框架所需的最基本的 HTML 片段，CSS 和 javaScript，这样一来，用户重复打开应用时就能迅速地看到 Web App 的基本界面，只需要从网络中请求、加载必要的内容。我们使用 Service Worker 对 App Shell 做离线缓存，以便它可以在离线时正常展现，达到类似 Native App 的体验。\n\n在lavas工程里，它体现为页面的顶部导航、底部导航和侧边栏等组件以及配套的一系列vuex的action和mutation，还有路由中的一些前进/后退的处理逻辑，使我们可以像Native App一样不需要关心细节就可以很简单地修改它们的状态来适应自己的具体需求\n\n### ServiceWorker\n\n这也是谷歌的PWA框架中提出来的[概念](https://developers.google.cn/web/fundamentals/getting-started/primers/service-workers)，lavas的解释如下\n\n> Service Worker 是用 JavaScript 编写的 JS 文件，能够代理请求，并且能够操作浏览器缓存，通过将缓存的内容直接返回，让请求能够瞬间完成。开发者可以预存储关键文件，可以淘汰过期的文件等等，给用户提供可靠的体验。\n\n可以说pwa能做到缓存离线静态文件或其他离线内容就是靠它来控制的，然而处理不好你可能会碰上复杂的缓存不能及时更新的问题，lavas提供了通用的方案来帮助我们缓存static目录内的文件和实现更新功能，在简单情况下我们甚至不需要去在意这个概念就可以开发出pwa应用\n\n### manifest.json\n\n都是谷歌提出的[概念](https://developers.google.cn/web/fundamentals/getting-started/codelabs/your-first-pwapp/#_30)\n\n> 网络应用清单是一个简单的 JSON 文件，使您（开发者）能够控制在用户可能看到应用的区域（例如手机主屏幕）中如何向用户显示应用，指示用户可以启动哪些功能，更重要的是说明启动方法。\n>\n> 利用网络应用清单，您的网络应用可以：\n> \n> * 在用户的 Android 主屏幕进行丰富的呈现\n> * 在没有网址栏的 Android 设备上以全屏模式启动\n> * 控制屏幕方向以获得最佳查看效果\n> * 定义网站的“启动画面”启动体验和主题颜色\n> * 追踪您是从主屏幕还是从网址栏启动\n\n使用它才能实现在手机上添加主屏图标和自定义启动页的功能，lavas已提供了默认文件，在此基础上修改就行\n\n### vuetifyjs\n\nlavas使用的UI组件库是遵循MD设计的[vuetifyjs库](https://vuetifyjs.com/vuetify/quick-start)，并非国内常用的框架库，接入可能需要一点理解成本\n\n## 一些问题 \n\n### 没有集中的配置文件\n\n一部分主题配置在config目录中，路由配置在src中，标题和页面主题色等常用配置居然是写死在index.html里的，这点就像一个普通的spa脚手架，缺少一个地方来设置一些常用配置\n\n### vuetifyjs\n\n正在频繁更新，还没出1.0版，谨慎使用，不过文档还算完善\n\n## 总结\n\nlavas确实能使我们不需要在意底层的细节就可以快速开发出pwa应用，当然要深入的话还是要去了解相关知识点的，百度在这一点做得很好，官方文档不仅包括lavas的，还包括整个pwa的介绍，十分全面\n\n唯一奇怪的是github星数居然不到200，怕是没怎么宣传，不过看到有子模块还在频繁更新，我们可以期待未来的发展\n","source":"_posts/PWA脚手架Lavas试用小结.md","raw":"---\ntitle: PWA脚手架Lavas试用小结\ndesc: 来自百度的vue+pwa解决方案\nauthor: ngtmuzi\ncategory: 随笔\ndate: 2017-09-18 16:48:14\ntags:\n- 前端\n- vue\n- Tool\n---\n\n## 简介\n\n基本摘自[Lavas官网](https://lavas.baidu.com)\n\n### [什么是PWA](https://lavas.baidu.com/doc)\n\nProgressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。\n\nPWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。\n\nPWA 的主要特点包括下面三点：\n\n* 可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现\n* 体验 - 快速响应，并且有平滑的动画响应用户的操作\n* 粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面\n\n### [Lavas 是什么](https://lavas.baidu.com/guide)\n\nLavas 是一个基于 Vue 的 PWA (Progressive Web Apps) 完整解决方案。我们将 PWA 的工程实践总结成多种 Lavas 应用框架模板，帮助开发者轻松搭建 PWA 站点，且无需过多的关注 PWA 开发本身。\n\n## 安装\n```cmd\nnpm install -g lavas\nlavas init\n```\nlavas的命令行工具提供了挺多的步骤流程来配置工程，还都是中文，这点很舒服\n\n## 概念介绍\n\n我们这里谈论的是appshell模板\n\nlavas并没有引入过多的抽象概念，基本类似一个普通的vue单页应用脚手架，不过提供了一套通用的静态文件缓存/更新的方案，使我们不需要任何配置就可以实现基本的静态文件缓存功能，这点很赞\n\n### AppShell\n\n这是谷歌提出来的一个[概念](https://developers.google.cn/web/fundamentals/architecture/app-shell)，而lavas的解释如下\n\n> App Shell 架构是构建 PWA 应用的一种方式，它通常提供了一个最基本的 Web App 框架，包括应用的头部、底部、菜单栏等结构。顾名思义，我们可以把它理解成应用的一个「空壳」，这个「空壳」仅包含页面框架所需的最基本的 HTML 片段，CSS 和 javaScript，这样一来，用户重复打开应用时就能迅速地看到 Web App 的基本界面，只需要从网络中请求、加载必要的内容。我们使用 Service Worker 对 App Shell 做离线缓存，以便它可以在离线时正常展现，达到类似 Native App 的体验。\n\n在lavas工程里，它体现为页面的顶部导航、底部导航和侧边栏等组件以及配套的一系列vuex的action和mutation，还有路由中的一些前进/后退的处理逻辑，使我们可以像Native App一样不需要关心细节就可以很简单地修改它们的状态来适应自己的具体需求\n\n### ServiceWorker\n\n这也是谷歌的PWA框架中提出来的[概念](https://developers.google.cn/web/fundamentals/getting-started/primers/service-workers)，lavas的解释如下\n\n> Service Worker 是用 JavaScript 编写的 JS 文件，能够代理请求，并且能够操作浏览器缓存，通过将缓存的内容直接返回，让请求能够瞬间完成。开发者可以预存储关键文件，可以淘汰过期的文件等等，给用户提供可靠的体验。\n\n可以说pwa能做到缓存离线静态文件或其他离线内容就是靠它来控制的，然而处理不好你可能会碰上复杂的缓存不能及时更新的问题，lavas提供了通用的方案来帮助我们缓存static目录内的文件和实现更新功能，在简单情况下我们甚至不需要去在意这个概念就可以开发出pwa应用\n\n### manifest.json\n\n都是谷歌提出的[概念](https://developers.google.cn/web/fundamentals/getting-started/codelabs/your-first-pwapp/#_30)\n\n> 网络应用清单是一个简单的 JSON 文件，使您（开发者）能够控制在用户可能看到应用的区域（例如手机主屏幕）中如何向用户显示应用，指示用户可以启动哪些功能，更重要的是说明启动方法。\n>\n> 利用网络应用清单，您的网络应用可以：\n> \n> * 在用户的 Android 主屏幕进行丰富的呈现\n> * 在没有网址栏的 Android 设备上以全屏模式启动\n> * 控制屏幕方向以获得最佳查看效果\n> * 定义网站的“启动画面”启动体验和主题颜色\n> * 追踪您是从主屏幕还是从网址栏启动\n\n使用它才能实现在手机上添加主屏图标和自定义启动页的功能，lavas已提供了默认文件，在此基础上修改就行\n\n### vuetifyjs\n\nlavas使用的UI组件库是遵循MD设计的[vuetifyjs库](https://vuetifyjs.com/vuetify/quick-start)，并非国内常用的框架库，接入可能需要一点理解成本\n\n## 一些问题 \n\n### 没有集中的配置文件\n\n一部分主题配置在config目录中，路由配置在src中，标题和页面主题色等常用配置居然是写死在index.html里的，这点就像一个普通的spa脚手架，缺少一个地方来设置一些常用配置\n\n### vuetifyjs\n\n正在频繁更新，还没出1.0版，谨慎使用，不过文档还算完善\n\n## 总结\n\nlavas确实能使我们不需要在意底层的细节就可以快速开发出pwa应用，当然要深入的话还是要去了解相关知识点的，百度在这一点做得很好，官方文档不仅包括lavas的，还包括整个pwa的介绍，十分全面\n\n唯一奇怪的是github星数居然不到200，怕是没怎么宣传，不过看到有子模块还在频繁更新，我们可以期待未来的发展\n","slug":"PWA脚手架Lavas试用小结","published":1,"updated":"2020-06-17T10:26:40.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbh000asou52scw1upq","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>基本摘自<a href=\"https://lavas.baidu.com\">Lavas官网</a></p>\n<h3 id=\"什么是PWA\"><a href=\"#什么是PWA\" class=\"headerlink\" title=\"什么是PWA\"></a><a href=\"https://lavas.baidu.com/doc\">什么是PWA</a></h3><p>Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。</p>\n<p>PWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。</p>\n<p>PWA 的主要特点包括下面三点：</p>\n<ul>\n<li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现</li>\n<li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li>\n<li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面</li>\n</ul>\n<h3 id=\"Lavas-是什么\"><a href=\"#Lavas-是什么\" class=\"headerlink\" title=\"Lavas 是什么\"></a><a href=\"https://lavas.baidu.com/guide\">Lavas 是什么</a></h3><p>Lavas 是一个基于 Vue 的 PWA (Progressive Web Apps) 完整解决方案。我们将 PWA 的工程实践总结成多种 Lavas 应用框架模板，帮助开发者轻松搭建 PWA 站点，且无需过多的关注 PWA 开发本身。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g lavas</span><br><span class=\"line\">lavas init</span><br></pre></td></tr></table></figure>\n<p>lavas的命令行工具提供了挺多的步骤流程来配置工程，还都是中文，这点很舒服</p>\n<h2 id=\"概念介绍\"><a href=\"#概念介绍\" class=\"headerlink\" title=\"概念介绍\"></a>概念介绍</h2><p>我们这里谈论的是appshell模板</p>\n<p>lavas并没有引入过多的抽象概念，基本类似一个普通的vue单页应用脚手架，不过提供了一套通用的静态文件缓存/更新的方案，使我们不需要任何配置就可以实现基本的静态文件缓存功能，这点很赞</p>\n<h3 id=\"AppShell\"><a href=\"#AppShell\" class=\"headerlink\" title=\"AppShell\"></a>AppShell</h3><p>这是谷歌提出来的一个<a href=\"https://developers.google.cn/web/fundamentals/architecture/app-shell\">概念</a>，而lavas的解释如下</p>\n<blockquote>\n<p>App Shell 架构是构建 PWA 应用的一种方式，它通常提供了一个最基本的 Web App 框架，包括应用的头部、底部、菜单栏等结构。顾名思义，我们可以把它理解成应用的一个「空壳」，这个「空壳」仅包含页面框架所需的最基本的 HTML 片段，CSS 和 javaScript，这样一来，用户重复打开应用时就能迅速地看到 Web App 的基本界面，只需要从网络中请求、加载必要的内容。我们使用 Service Worker 对 App Shell 做离线缓存，以便它可以在离线时正常展现，达到类似 Native App 的体验。</p>\n</blockquote>\n<p>在lavas工程里，它体现为页面的顶部导航、底部导航和侧边栏等组件以及配套的一系列vuex的action和mutation，还有路由中的一些前进/后退的处理逻辑，使我们可以像Native App一样不需要关心细节就可以很简单地修改它们的状态来适应自己的具体需求</p>\n<h3 id=\"ServiceWorker\"><a href=\"#ServiceWorker\" class=\"headerlink\" title=\"ServiceWorker\"></a>ServiceWorker</h3><p>这也是谷歌的PWA框架中提出来的<a href=\"https://developers.google.cn/web/fundamentals/getting-started/primers/service-workers\">概念</a>，lavas的解释如下</p>\n<blockquote>\n<p>Service Worker 是用 JavaScript 编写的 JS 文件，能够代理请求，并且能够操作浏览器缓存，通过将缓存的内容直接返回，让请求能够瞬间完成。开发者可以预存储关键文件，可以淘汰过期的文件等等，给用户提供可靠的体验。</p>\n</blockquote>\n<p>可以说pwa能做到缓存离线静态文件或其他离线内容就是靠它来控制的，然而处理不好你可能会碰上复杂的缓存不能及时更新的问题，lavas提供了通用的方案来帮助我们缓存static目录内的文件和实现更新功能，在简单情况下我们甚至不需要去在意这个概念就可以开发出pwa应用</p>\n<h3 id=\"manifest-json\"><a href=\"#manifest-json\" class=\"headerlink\" title=\"manifest.json\"></a>manifest.json</h3><p>都是谷歌提出的<a href=\"https://developers.google.cn/web/fundamentals/getting-started/codelabs/your-first-pwapp/#_30\">概念</a></p>\n<blockquote>\n<p>网络应用清单是一个简单的 JSON 文件，使您（开发者）能够控制在用户可能看到应用的区域（例如手机主屏幕）中如何向用户显示应用，指示用户可以启动哪些功能，更重要的是说明启动方法。</p>\n<p>利用网络应用清单，您的网络应用可以：</p>\n<ul>\n<li>在用户的 Android 主屏幕进行丰富的呈现</li>\n<li>在没有网址栏的 Android 设备上以全屏模式启动</li>\n<li>控制屏幕方向以获得最佳查看效果</li>\n<li>定义网站的“启动画面”启动体验和主题颜色</li>\n<li>追踪您是从主屏幕还是从网址栏启动</li>\n</ul>\n</blockquote>\n<p>使用它才能实现在手机上添加主屏图标和自定义启动页的功能，lavas已提供了默认文件，在此基础上修改就行</p>\n<h3 id=\"vuetifyjs\"><a href=\"#vuetifyjs\" class=\"headerlink\" title=\"vuetifyjs\"></a>vuetifyjs</h3><p>lavas使用的UI组件库是遵循MD设计的<a href=\"https://vuetifyjs.com/vuetify/quick-start\">vuetifyjs库</a>，并非国内常用的框架库，接入可能需要一点理解成本</p>\n<h2 id=\"一些问题\"><a href=\"#一些问题\" class=\"headerlink\" title=\"一些问题\"></a>一些问题</h2><h3 id=\"没有集中的配置文件\"><a href=\"#没有集中的配置文件\" class=\"headerlink\" title=\"没有集中的配置文件\"></a>没有集中的配置文件</h3><p>一部分主题配置在config目录中，路由配置在src中，标题和页面主题色等常用配置居然是写死在index.html里的，这点就像一个普通的spa脚手架，缺少一个地方来设置一些常用配置</p>\n<h3 id=\"vuetifyjs-1\"><a href=\"#vuetifyjs-1\" class=\"headerlink\" title=\"vuetifyjs\"></a>vuetifyjs</h3><p>正在频繁更新，还没出1.0版，谨慎使用，不过文档还算完善</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>lavas确实能使我们不需要在意底层的细节就可以快速开发出pwa应用，当然要深入的话还是要去了解相关知识点的，百度在这一点做得很好，官方文档不仅包括lavas的，还包括整个pwa的介绍，十分全面</p>\n<p>唯一奇怪的是github星数居然不到200，怕是没怎么宣传，不过看到有子模块还在频繁更新，我们可以期待未来的发展</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>基本摘自<a href=\"https://lavas.baidu.com\">Lavas官网</a></p>\n<h3 id=\"什么是PWA\"><a href=\"#什么是PWA\" class=\"headerlink\" title=\"什么是PWA\"></a><a href=\"https://lavas.baidu.com/doc\">什么是PWA</a></h3><p>Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。</p>\n<p>PWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。</p>\n<p>PWA 的主要特点包括下面三点：</p>\n<ul>\n<li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现</li>\n<li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li>\n<li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面</li>\n</ul>\n<h3 id=\"Lavas-是什么\"><a href=\"#Lavas-是什么\" class=\"headerlink\" title=\"Lavas 是什么\"></a><a href=\"https://lavas.baidu.com/guide\">Lavas 是什么</a></h3><p>Lavas 是一个基于 Vue 的 PWA (Progressive Web Apps) 完整解决方案。我们将 PWA 的工程实践总结成多种 Lavas 应用框架模板，帮助开发者轻松搭建 PWA 站点，且无需过多的关注 PWA 开发本身。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g lavas</span><br><span class=\"line\">lavas init</span><br></pre></td></tr></table></figure>\n<p>lavas的命令行工具提供了挺多的步骤流程来配置工程，还都是中文，这点很舒服</p>\n<h2 id=\"概念介绍\"><a href=\"#概念介绍\" class=\"headerlink\" title=\"概念介绍\"></a>概念介绍</h2><p>我们这里谈论的是appshell模板</p>\n<p>lavas并没有引入过多的抽象概念，基本类似一个普通的vue单页应用脚手架，不过提供了一套通用的静态文件缓存/更新的方案，使我们不需要任何配置就可以实现基本的静态文件缓存功能，这点很赞</p>\n<h3 id=\"AppShell\"><a href=\"#AppShell\" class=\"headerlink\" title=\"AppShell\"></a>AppShell</h3><p>这是谷歌提出来的一个<a href=\"https://developers.google.cn/web/fundamentals/architecture/app-shell\">概念</a>，而lavas的解释如下</p>\n<blockquote>\n<p>App Shell 架构是构建 PWA 应用的一种方式，它通常提供了一个最基本的 Web App 框架，包括应用的头部、底部、菜单栏等结构。顾名思义，我们可以把它理解成应用的一个「空壳」，这个「空壳」仅包含页面框架所需的最基本的 HTML 片段，CSS 和 javaScript，这样一来，用户重复打开应用时就能迅速地看到 Web App 的基本界面，只需要从网络中请求、加载必要的内容。我们使用 Service Worker 对 App Shell 做离线缓存，以便它可以在离线时正常展现，达到类似 Native App 的体验。</p>\n</blockquote>\n<p>在lavas工程里，它体现为页面的顶部导航、底部导航和侧边栏等组件以及配套的一系列vuex的action和mutation，还有路由中的一些前进/后退的处理逻辑，使我们可以像Native App一样不需要关心细节就可以很简单地修改它们的状态来适应自己的具体需求</p>\n<h3 id=\"ServiceWorker\"><a href=\"#ServiceWorker\" class=\"headerlink\" title=\"ServiceWorker\"></a>ServiceWorker</h3><p>这也是谷歌的PWA框架中提出来的<a href=\"https://developers.google.cn/web/fundamentals/getting-started/primers/service-workers\">概念</a>，lavas的解释如下</p>\n<blockquote>\n<p>Service Worker 是用 JavaScript 编写的 JS 文件，能够代理请求，并且能够操作浏览器缓存，通过将缓存的内容直接返回，让请求能够瞬间完成。开发者可以预存储关键文件，可以淘汰过期的文件等等，给用户提供可靠的体验。</p>\n</blockquote>\n<p>可以说pwa能做到缓存离线静态文件或其他离线内容就是靠它来控制的，然而处理不好你可能会碰上复杂的缓存不能及时更新的问题，lavas提供了通用的方案来帮助我们缓存static目录内的文件和实现更新功能，在简单情况下我们甚至不需要去在意这个概念就可以开发出pwa应用</p>\n<h3 id=\"manifest-json\"><a href=\"#manifest-json\" class=\"headerlink\" title=\"manifest.json\"></a>manifest.json</h3><p>都是谷歌提出的<a href=\"https://developers.google.cn/web/fundamentals/getting-started/codelabs/your-first-pwapp/#_30\">概念</a></p>\n<blockquote>\n<p>网络应用清单是一个简单的 JSON 文件，使您（开发者）能够控制在用户可能看到应用的区域（例如手机主屏幕）中如何向用户显示应用，指示用户可以启动哪些功能，更重要的是说明启动方法。</p>\n<p>利用网络应用清单，您的网络应用可以：</p>\n<ul>\n<li>在用户的 Android 主屏幕进行丰富的呈现</li>\n<li>在没有网址栏的 Android 设备上以全屏模式启动</li>\n<li>控制屏幕方向以获得最佳查看效果</li>\n<li>定义网站的“启动画面”启动体验和主题颜色</li>\n<li>追踪您是从主屏幕还是从网址栏启动</li>\n</ul>\n</blockquote>\n<p>使用它才能实现在手机上添加主屏图标和自定义启动页的功能，lavas已提供了默认文件，在此基础上修改就行</p>\n<h3 id=\"vuetifyjs\"><a href=\"#vuetifyjs\" class=\"headerlink\" title=\"vuetifyjs\"></a>vuetifyjs</h3><p>lavas使用的UI组件库是遵循MD设计的<a href=\"https://vuetifyjs.com/vuetify/quick-start\">vuetifyjs库</a>，并非国内常用的框架库，接入可能需要一点理解成本</p>\n<h2 id=\"一些问题\"><a href=\"#一些问题\" class=\"headerlink\" title=\"一些问题\"></a>一些问题</h2><h3 id=\"没有集中的配置文件\"><a href=\"#没有集中的配置文件\" class=\"headerlink\" title=\"没有集中的配置文件\"></a>没有集中的配置文件</h3><p>一部分主题配置在config目录中，路由配置在src中，标题和页面主题色等常用配置居然是写死在index.html里的，这点就像一个普通的spa脚手架，缺少一个地方来设置一些常用配置</p>\n<h3 id=\"vuetifyjs-1\"><a href=\"#vuetifyjs-1\" class=\"headerlink\" title=\"vuetifyjs\"></a>vuetifyjs</h3><p>正在频繁更新，还没出1.0版，谨慎使用，不过文档还算完善</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>lavas确实能使我们不需要在意底层的细节就可以快速开发出pwa应用，当然要深入的话还是要去了解相关知识点的，百度在这一点做得很好，官方文档不仅包括lavas的，还包括整个pwa的介绍，十分全面</p>\n<p>唯一奇怪的是github星数居然不到200，怕是没怎么宣传，不过看到有子模块还在频繁更新，我们可以期待未来的发展</p>\n"},{"title":"Proxy实现Promise同步调用逻辑","desc":"Proxy + Promise = 逻辑同步","date":"2016-08-08T15:30:08.830Z","author":"ngtmuzi","_content":"\n我们在很多使用Promise的时候都会有如下的用法\n```javascript\nMongoClient.connect()\n  .then(function (db) {\n    var col = db.collection('something');\n    col.find().toArray()\n      .then(console.log, console.error);\n  });\n```\n\n真正的连接对象在`connect()`之后才返回，只能在`then`回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子\n```javascript\nvar db;\nMongoClient.connect()\n  .then(function (_db) {\n    db = _db;\n  });\n//别的地方\ndb.collection('otherthing')....\n```\n\n这样的缺点是在连接未建立时访问`db`会引发异常，当然最正确的做法应该是\n```javascript\nvar db = MongoClient.connect();\n//别的地方\ndb.then(function (_db) {\n  _db.collection('otherthing')....\n});\n```\n\n可以保持对一个连接的复用，但这样还是嵌了一层回调。\n\n\n在之前用`Proxy`写了几个玩具之后，有个念头渐渐浮上心头，`Proxy`也许可以改变这个模式，我们可以用`Proxy`预先收集好调用链，然后再将其内部转为`Promise`的调用链，简单来说思路如下：\n\n1. 先将原始数据用`Promise.resolve`包裹，使其成为一个`Promise`对象，并返回该对象的代理`Proxy`\n\n2. 对该`Proxy`的`get`和`apply`操作实际上就是在后面多加一个`.then`回调，并会继续返回`Proxy`，以实现链式调用\n\n3. 当将`Proxy`作为函数运行时对参数预先做`Promise.resolve`处理，使得它可以接受`Promise`参数\n\n4. 在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能\n\n5. 最终的值从`.then中`获取，`Promise`的特性保证了最终值的可达性\n\n\n\n多说无用，以下是一些示例：\n\n```javascript\nvar request = require('request-promise');\nvar _       = require('promixy');\n\nvar parse   = _(JSON.parse);            //proxy a function\nvar docJson = request('https://nodejs.org/api/documentation.json');  //a promise \nvar obj     = parse(docJson);           //wait the promise result\n\nobj.miscs[0].textRaw.then(console.log, console.error);\n```\n\n首先代理了`JSON.parse`使其可以接受`Promise`类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过`console.log`打印出来\n\n\n当试图从`undefined`中读取属性时，会返回类似这样的错误\n```\nTypeError: can't read property 'textRaw' in {Promixy}(1 args).miscs.10, it got a undefined\n```\n\n虽然有些不直观但好歹调用链是能看出来了\n```javascript\n_(Promise.resolve(_(_(_(111))))).then(_(console.log), _(console.error));\n//111\n```\n\n即使嵌了很多层，这个`Proxy`依然是`Promise`的代理，所以最后还是可以得到正确的结果的\n\n\n而刚才的mongo连接也可以简化为\n\n```javascript\nvar db = _(MongoClient.connect());\n//别的地方\ndb.collection('something')...\n```\n\n实质上是`Proxy`在内部代替用户嵌了一层`.then`，代码上更加简单直观，且从它上面取的所有属性依然有`Proxy`包裹，所以你甚至可以实现这样变态的调用方式\n\n```javascript\ndb.collection('something').find().toArray()[0].somekey\n  .then(console.log,console.error);\n```\n\n直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法\n\n\n综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，[npm地址](https://www.npmjs.com/package/promixy)，如果你有任何建议或发现了bug，欢迎到[github](https://github.com/ngtmuzi/promixy)反馈\n\n## 2017-07-04补充\n\nNode7.6之后的版本原生支持`async/await`，建议直接使用这个特性","source":"_posts/Proxy实现Promise同步调用逻辑.md","raw":"---\ntitle: Proxy实现Promise同步调用逻辑  \ndesc: Proxy + Promise = 逻辑同步  \ndate: 2016-8-8 23:30:08.830\ntags: \n- javascript\n- Proxy\n- Promise\n- ES6\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n我们在很多使用Promise的时候都会有如下的用法\n```javascript\nMongoClient.connect()\n  .then(function (db) {\n    var col = db.collection('something');\n    col.find().toArray()\n      .then(console.log, console.error);\n  });\n```\n\n真正的连接对象在`connect()`之后才返回，只能在`then`回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子\n```javascript\nvar db;\nMongoClient.connect()\n  .then(function (_db) {\n    db = _db;\n  });\n//别的地方\ndb.collection('otherthing')....\n```\n\n这样的缺点是在连接未建立时访问`db`会引发异常，当然最正确的做法应该是\n```javascript\nvar db = MongoClient.connect();\n//别的地方\ndb.then(function (_db) {\n  _db.collection('otherthing')....\n});\n```\n\n可以保持对一个连接的复用，但这样还是嵌了一层回调。\n\n\n在之前用`Proxy`写了几个玩具之后，有个念头渐渐浮上心头，`Proxy`也许可以改变这个模式，我们可以用`Proxy`预先收集好调用链，然后再将其内部转为`Promise`的调用链，简单来说思路如下：\n\n1. 先将原始数据用`Promise.resolve`包裹，使其成为一个`Promise`对象，并返回该对象的代理`Proxy`\n\n2. 对该`Proxy`的`get`和`apply`操作实际上就是在后面多加一个`.then`回调，并会继续返回`Proxy`，以实现链式调用\n\n3. 当将`Proxy`作为函数运行时对参数预先做`Promise.resolve`处理，使得它可以接受`Promise`参数\n\n4. 在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能\n\n5. 最终的值从`.then中`获取，`Promise`的特性保证了最终值的可达性\n\n\n\n多说无用，以下是一些示例：\n\n```javascript\nvar request = require('request-promise');\nvar _       = require('promixy');\n\nvar parse   = _(JSON.parse);            //proxy a function\nvar docJson = request('https://nodejs.org/api/documentation.json');  //a promise \nvar obj     = parse(docJson);           //wait the promise result\n\nobj.miscs[0].textRaw.then(console.log, console.error);\n```\n\n首先代理了`JSON.parse`使其可以接受`Promise`类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过`console.log`打印出来\n\n\n当试图从`undefined`中读取属性时，会返回类似这样的错误\n```\nTypeError: can't read property 'textRaw' in {Promixy}(1 args).miscs.10, it got a undefined\n```\n\n虽然有些不直观但好歹调用链是能看出来了\n```javascript\n_(Promise.resolve(_(_(_(111))))).then(_(console.log), _(console.error));\n//111\n```\n\n即使嵌了很多层，这个`Proxy`依然是`Promise`的代理，所以最后还是可以得到正确的结果的\n\n\n而刚才的mongo连接也可以简化为\n\n```javascript\nvar db = _(MongoClient.connect());\n//别的地方\ndb.collection('something')...\n```\n\n实质上是`Proxy`在内部代替用户嵌了一层`.then`，代码上更加简单直观，且从它上面取的所有属性依然有`Proxy`包裹，所以你甚至可以实现这样变态的调用方式\n\n```javascript\ndb.collection('something').find().toArray()[0].somekey\n  .then(console.log,console.error);\n```\n\n直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法\n\n\n综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，[npm地址](https://www.npmjs.com/package/promixy)，如果你有任何建议或发现了bug，欢迎到[github](https://github.com/ngtmuzi/promixy)反馈\n\n## 2017-07-04补充\n\nNode7.6之后的版本原生支持`async/await`，建议直接使用这个特性","slug":"Proxy实现Promise同步调用逻辑","published":1,"updated":"2020-06-17T10:26:40.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbi000bsou55x6fa76j","content":"<p>我们在很多使用Promise的时候都会有如下的用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoClient.connect()</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> col = db.collection(<span class=\"string\">&#x27;something&#x27;</span>);</span><br><span class=\"line\">    col.find().toArray()</span><br><span class=\"line\">      .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>真正的连接对象在<code>connect()</code>之后才返回，只能在<code>then</code>回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db;</span><br><span class=\"line\">MongoClient.connect()</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</span><br><span class=\"line\">    db = _db;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"comment\">//别的地方</span></span><br><span class=\"line\">db.collection(<span class=\"string\">&#x27;otherthing&#x27;</span>)....</span><br></pre></td></tr></table></figure></p>\n<p>这样的缺点是在连接未建立时访问<code>db</code>会引发异常，当然最正确的做法应该是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = MongoClient.connect();</span><br><span class=\"line\"><span class=\"comment\">//别的地方</span></span><br><span class=\"line\">db.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</span><br><span class=\"line\">  _db.collection(<span class=\"string\">&#x27;otherthing&#x27;</span>)....</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>可以保持对一个连接的复用，但这样还是嵌了一层回调。</p>\n<p>在之前用<code>Proxy</code>写了几个玩具之后，有个念头渐渐浮上心头，<code>Proxy</code>也许可以改变这个模式，我们可以用<code>Proxy</code>预先收集好调用链，然后再将其内部转为<code>Promise</code>的调用链，简单来说思路如下：</p>\n<ol>\n<li><p>先将原始数据用<code>Promise.resolve</code>包裹，使其成为一个<code>Promise</code>对象，并返回该对象的代理<code>Proxy</code></p>\n</li>\n<li><p>对该<code>Proxy</code>的<code>get</code>和<code>apply</code>操作实际上就是在后面多加一个<code>.then</code>回调，并会继续返回<code>Proxy</code>，以实现链式调用</p>\n</li>\n<li><p>当将<code>Proxy</code>作为函数运行时对参数预先做<code>Promise.resolve</code>处理，使得它可以接受<code>Promise</code>参数</p>\n</li>\n<li><p>在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能</p>\n</li>\n<li><p>最终的值从<code>.then中</code>获取，<code>Promise</code>的特性保证了最终值的可达性</p>\n</li>\n</ol>\n<p>多说无用，以下是一些示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;request-promise&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _       = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;promixy&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parse   = _(<span class=\"built_in\">JSON</span>.parse);            <span class=\"comment\">//proxy a function</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> docJson = request(<span class=\"string\">&#x27;https://nodejs.org/api/documentation.json&#x27;</span>);  <span class=\"comment\">//a promise </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj     = parse(docJson);           <span class=\"comment\">//wait the promise result</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.miscs[<span class=\"number\">0</span>].textRaw.then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>首先代理了<code>JSON.parse</code>使其可以接受<code>Promise</code>类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过<code>console.log</code>打印出来</p>\n<p>当试图从<code>undefined</code>中读取属性时，会返回类似这样的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TypeError: can&#39;t read property &#39;textRaw&#39; in &#123;Promixy&#125;(1 args).miscs.10, it got a undefined</span><br></pre></td></tr></table></figure></p>\n<p>虽然有些不直观但好歹调用链是能看出来了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_(<span class=\"built_in\">Promise</span>.resolve(_(_(_(<span class=\"number\">111</span>))))).then(_(<span class=\"built_in\">console</span>.log), _(<span class=\"built_in\">console</span>.error));</span><br><span class=\"line\"><span class=\"comment\">//111</span></span><br></pre></td></tr></table></figure></p>\n<p>即使嵌了很多层，这个<code>Proxy</code>依然是<code>Promise</code>的代理，所以最后还是可以得到正确的结果的</p>\n<p>而刚才的mongo连接也可以简化为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = _(MongoClient.connect());</span><br><span class=\"line\"><span class=\"comment\">//别的地方</span></span><br><span class=\"line\">db.collection(<span class=\"string\">&#x27;something&#x27;</span>)...</span><br></pre></td></tr></table></figure>\n<p>实质上是<code>Proxy</code>在内部代替用户嵌了一层<code>.then</code>，代码上更加简单直观，且从它上面取的所有属性依然有<code>Proxy</code>包裹，所以你甚至可以实现这样变态的调用方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection(<span class=\"string\">&#x27;something&#x27;</span>).find().toArray()[<span class=\"number\">0</span>].somekey</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log,<span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法</p>\n<p>综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，<a href=\"https://www.npmjs.com/package/promixy\">npm地址</a>，如果你有任何建议或发现了bug，欢迎到<a href=\"https://github.com/ngtmuzi/promixy\">github</a>反馈</p>\n<h2 id=\"2017-07-04补充\"><a href=\"#2017-07-04补充\" class=\"headerlink\" title=\"2017-07-04补充\"></a>2017-07-04补充</h2><p>Node7.6之后的版本原生支持<code>async/await</code>，建议直接使用这个特性</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们在很多使用Promise的时候都会有如下的用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoClient.connect()</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> col = db.collection(<span class=\"string\">&#x27;something&#x27;</span>);</span><br><span class=\"line\">    col.find().toArray()</span><br><span class=\"line\">      .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>真正的连接对象在<code>connect()</code>之后才返回，只能在<code>then</code>回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db;</span><br><span class=\"line\">MongoClient.connect()</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</span><br><span class=\"line\">    db = _db;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"comment\">//别的地方</span></span><br><span class=\"line\">db.collection(<span class=\"string\">&#x27;otherthing&#x27;</span>)....</span><br></pre></td></tr></table></figure></p>\n<p>这样的缺点是在连接未建立时访问<code>db</code>会引发异常，当然最正确的做法应该是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = MongoClient.connect();</span><br><span class=\"line\"><span class=\"comment\">//别的地方</span></span><br><span class=\"line\">db.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</span><br><span class=\"line\">  _db.collection(<span class=\"string\">&#x27;otherthing&#x27;</span>)....</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>可以保持对一个连接的复用，但这样还是嵌了一层回调。</p>\n<p>在之前用<code>Proxy</code>写了几个玩具之后，有个念头渐渐浮上心头，<code>Proxy</code>也许可以改变这个模式，我们可以用<code>Proxy</code>预先收集好调用链，然后再将其内部转为<code>Promise</code>的调用链，简单来说思路如下：</p>\n<ol>\n<li><p>先将原始数据用<code>Promise.resolve</code>包裹，使其成为一个<code>Promise</code>对象，并返回该对象的代理<code>Proxy</code></p>\n</li>\n<li><p>对该<code>Proxy</code>的<code>get</code>和<code>apply</code>操作实际上就是在后面多加一个<code>.then</code>回调，并会继续返回<code>Proxy</code>，以实现链式调用</p>\n</li>\n<li><p>当将<code>Proxy</code>作为函数运行时对参数预先做<code>Promise.resolve</code>处理，使得它可以接受<code>Promise</code>参数</p>\n</li>\n<li><p>在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能</p>\n</li>\n<li><p>最终的值从<code>.then中</code>获取，<code>Promise</code>的特性保证了最终值的可达性</p>\n</li>\n</ol>\n<p>多说无用，以下是一些示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;request-promise&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _       = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;promixy&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parse   = _(<span class=\"built_in\">JSON</span>.parse);            <span class=\"comment\">//proxy a function</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> docJson = request(<span class=\"string\">&#x27;https://nodejs.org/api/documentation.json&#x27;</span>);  <span class=\"comment\">//a promise </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj     = parse(docJson);           <span class=\"comment\">//wait the promise result</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.miscs[<span class=\"number\">0</span>].textRaw.then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>首先代理了<code>JSON.parse</code>使其可以接受<code>Promise</code>类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过<code>console.log</code>打印出来</p>\n<p>当试图从<code>undefined</code>中读取属性时，会返回类似这样的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TypeError: can&#39;t read property &#39;textRaw&#39; in &#123;Promixy&#125;(1 args).miscs.10, it got a undefined</span><br></pre></td></tr></table></figure></p>\n<p>虽然有些不直观但好歹调用链是能看出来了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_(<span class=\"built_in\">Promise</span>.resolve(_(_(_(<span class=\"number\">111</span>))))).then(_(<span class=\"built_in\">console</span>.log), _(<span class=\"built_in\">console</span>.error));</span><br><span class=\"line\"><span class=\"comment\">//111</span></span><br></pre></td></tr></table></figure></p>\n<p>即使嵌了很多层，这个<code>Proxy</code>依然是<code>Promise</code>的代理，所以最后还是可以得到正确的结果的</p>\n<p>而刚才的mongo连接也可以简化为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = _(MongoClient.connect());</span><br><span class=\"line\"><span class=\"comment\">//别的地方</span></span><br><span class=\"line\">db.collection(<span class=\"string\">&#x27;something&#x27;</span>)...</span><br></pre></td></tr></table></figure>\n<p>实质上是<code>Proxy</code>在内部代替用户嵌了一层<code>.then</code>，代码上更加简单直观，且从它上面取的所有属性依然有<code>Proxy</code>包裹，所以你甚至可以实现这样变态的调用方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection(<span class=\"string\">&#x27;something&#x27;</span>).find().toArray()[<span class=\"number\">0</span>].somekey</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log,<span class=\"built_in\">console</span>.error);</span><br></pre></td></tr></table></figure>\n<p>直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法</p>\n<p>综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，<a href=\"https://www.npmjs.com/package/promixy\">npm地址</a>，如果你有任何建议或发现了bug，欢迎到<a href=\"https://github.com/ngtmuzi/promixy\">github</a>反馈</p>\n<h2 id=\"2017-07-04补充\"><a href=\"#2017-07-04补充\" class=\"headerlink\" title=\"2017-07-04补充\"></a>2017-07-04补充</h2><p>Node7.6之后的版本原生支持<code>async/await</code>，建议直接使用这个特性</p>\n"},{"title":"Proxy对象仿Scala的通配符函数调用","desc":"Proxy对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本javascript无法完成的特性","date":"2016-04-23T08:47:40.471Z","author":"ngtmuzi","_content":"\n`Proxy`对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本`javascript`无法完成的特性，在不长的`scala语言`学习过程中，发现这门语言有一个很神奇的通配符`_`，在函数链式调用中，`_`就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：\n```javascript\n[1, 2, 3, 4].map(_.toString());\n```\n\n就是对每个传来的对象，调用他们自身的`toString()`方法，使用ES6中的`Proxy`对象，可以很容易地模拟该特性\n（nodejs v6.0已支持`Proxy`，代码亦可在最新版chrome中运行）\n```javascript\nvar _ = new Proxy({}, {\n  get: function (target, key) {\n    return function (obj) {\n      if (obj && obj[key] && typeof obj[key] !== 'function') return obj[key];\n      var args = arguments;\n      return function (obj) {\n        if (obj && obj[key] && typeof obj[key] === 'function')\n          return obj[key].call(obj, ...args);\n      };\n    };\n  }\n});\n```\n\n除了调用对象自带的方法外，还有取出属性的功能，运行结果如下\n\n```javascript\n[1, 32, 128, 1024].map(_.toString('2'));\n//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]\n\n[{v:123},{v:456}].map(_.v);\n//return [123, 456]\n\nPromise.resolve(new Date())\n  .then(_.getTime())\n  .then(_.toString())\n  .then(_.length)\n  .then(console.log, console.error);\n//return 13\n```\n---\n# 2016-6-8续\n\n之前研究`Proxy`的时候写出来的那个`_`实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个`_`的作用层数，不能继续往里面走，解决的方法当然是继续返回一个`Proxy`，思路如下：\n\n* `_`本身返回一个Proxy，取属性操作返回的也是一个`Proxy`，这些`Proxy`指向一个函数，并在被调用时按顺序取出第一个参数里的属性\n\n* `_`可以预接收参数，接收的参数将在`Proxy`被调用时传给取出来的函数\n\n\n难点是如何知道`Proxy`是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了`Proxy`的相关资料后，我意识到上述的两种情况，对应的`this`应该是不同的，后来又发现过长的调用链每次都要经过多个`Proxy`可能会影响效率，我又改成另外一种形式实现：`Proxy`负责收集参数和属性名，并在最终调用的时候新建一个`Function`，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 `s=>s.xx.yy.zz()` 给简化成 `_.xx.yy.zz()` 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：\n\n```javascript\n/**\n * Created by ngtmuzi on 2016/5/29.\n */\n'use strict';\nconst receiveFn = (...args) => args;\n\n/**\n * chain proxy maker\n * @params {Any} defaultValue\n * @type {Function}\n */\nconst chainProxy = module.exports = function (defaultValue) {\n  var hasDefault   = arguments.length > 0;\n\n  var handle = {\n    get: function (target, property, receiver) {\n      //set prototype to base Proxy Object _\n      if (property === 'prototype') return _;\n      if (property === 'apply') return target.apply;\n      if (property === 'call') return target.call;\n      if (property === 'bind') return target.bind;\n\n      //is number\n      if (!isNaN(+property)) return new Proxy(target.bind(null, `[${property}]`), handle);\n      //return a new Proxy, go on\n      else return new Proxy(target.bind(null, '.' + property), handle);\n    },\n\n    apply: function (target, thisArg, argumentsList) {\n      //if method calling on Proxy Object\n      if (thisArg && thisArg.prototype === _) {\n        //save arguments to chain, and go on\n        return new Proxy(target.bind(null, argumentsList), handle);\n\n      } else {  //calling on outside\n\n        //get the calling chain\n        var chains = target();\n        //pick arguments\n        var args   = [].concat(...chains.filter(Array.isArray));\n\n        //make function body\n        var argNum     = 0;\n        var expression = chains.reduce(function (a, b) {\n          if (typeof b === 'string') return a + b;\n          else if (Array.isArray(b)) return a + `(${b.map(()=> `args[${argNum++}]`)})`;\n        }, 'return _');\n\n        var fnStr = `\n        try{\n          ${expression};\n        }catch(err){\n          ${hasDefault ? 'return defaultValue;' : ''}\n          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '${expression}';\n          throw err;\n        }`;\n\n        var finalFn = new Function(['args', '_', 'defaultValue'], fnStr);\n        return finalFn(args, argumentsList[0], defaultValue);\n      }\n    }\n  };\n\n  var _ = new Proxy(receiveFn, handle);\n  return _;\n};\n```\n\n测试代码如下：\n```javascript\nvar _1 = require('../index')(undefined);\nvar _2 = require('../index')();\nvar _3 = require('../index')({foo: 'bar'});\n\nPromise.resolve({a: 12333})\n  .then(_1.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 1:'), console.error.bind(null, 'catch error1:'))\n\n  .then(()=>({a: 12333}))\n  .then(_2.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'))\n\n  .then(()=>({a: 12333}))\n  .then(_3.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'));\n```\n\n本段代码已经做为模块提交到[npm](https://www.npmjs.com/package/chainproxy)上","source":"_posts/Proxy对象仿Scala的通配符函数调用.md","raw":"---\ntitle: Proxy对象仿Scala的通配符函数调用  \ndesc: Proxy对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本javascript无法完成的特性  \ndate: 2016-4-23 16:47:40.471\ntags: \n- javascript\n- es6\n- Proxy\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n`Proxy`对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本`javascript`无法完成的特性，在不长的`scala语言`学习过程中，发现这门语言有一个很神奇的通配符`_`，在函数链式调用中，`_`就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：\n```javascript\n[1, 2, 3, 4].map(_.toString());\n```\n\n就是对每个传来的对象，调用他们自身的`toString()`方法，使用ES6中的`Proxy`对象，可以很容易地模拟该特性\n（nodejs v6.0已支持`Proxy`，代码亦可在最新版chrome中运行）\n```javascript\nvar _ = new Proxy({}, {\n  get: function (target, key) {\n    return function (obj) {\n      if (obj && obj[key] && typeof obj[key] !== 'function') return obj[key];\n      var args = arguments;\n      return function (obj) {\n        if (obj && obj[key] && typeof obj[key] === 'function')\n          return obj[key].call(obj, ...args);\n      };\n    };\n  }\n});\n```\n\n除了调用对象自带的方法外，还有取出属性的功能，运行结果如下\n\n```javascript\n[1, 32, 128, 1024].map(_.toString('2'));\n//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]\n\n[{v:123},{v:456}].map(_.v);\n//return [123, 456]\n\nPromise.resolve(new Date())\n  .then(_.getTime())\n  .then(_.toString())\n  .then(_.length)\n  .then(console.log, console.error);\n//return 13\n```\n---\n# 2016-6-8续\n\n之前研究`Proxy`的时候写出来的那个`_`实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个`_`的作用层数，不能继续往里面走，解决的方法当然是继续返回一个`Proxy`，思路如下：\n\n* `_`本身返回一个Proxy，取属性操作返回的也是一个`Proxy`，这些`Proxy`指向一个函数，并在被调用时按顺序取出第一个参数里的属性\n\n* `_`可以预接收参数，接收的参数将在`Proxy`被调用时传给取出来的函数\n\n\n难点是如何知道`Proxy`是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了`Proxy`的相关资料后，我意识到上述的两种情况，对应的`this`应该是不同的，后来又发现过长的调用链每次都要经过多个`Proxy`可能会影响效率，我又改成另外一种形式实现：`Proxy`负责收集参数和属性名，并在最终调用的时候新建一个`Function`，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 `s=>s.xx.yy.zz()` 给简化成 `_.xx.yy.zz()` 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：\n\n```javascript\n/**\n * Created by ngtmuzi on 2016/5/29.\n */\n'use strict';\nconst receiveFn = (...args) => args;\n\n/**\n * chain proxy maker\n * @params {Any} defaultValue\n * @type {Function}\n */\nconst chainProxy = module.exports = function (defaultValue) {\n  var hasDefault   = arguments.length > 0;\n\n  var handle = {\n    get: function (target, property, receiver) {\n      //set prototype to base Proxy Object _\n      if (property === 'prototype') return _;\n      if (property === 'apply') return target.apply;\n      if (property === 'call') return target.call;\n      if (property === 'bind') return target.bind;\n\n      //is number\n      if (!isNaN(+property)) return new Proxy(target.bind(null, `[${property}]`), handle);\n      //return a new Proxy, go on\n      else return new Proxy(target.bind(null, '.' + property), handle);\n    },\n\n    apply: function (target, thisArg, argumentsList) {\n      //if method calling on Proxy Object\n      if (thisArg && thisArg.prototype === _) {\n        //save arguments to chain, and go on\n        return new Proxy(target.bind(null, argumentsList), handle);\n\n      } else {  //calling on outside\n\n        //get the calling chain\n        var chains = target();\n        //pick arguments\n        var args   = [].concat(...chains.filter(Array.isArray));\n\n        //make function body\n        var argNum     = 0;\n        var expression = chains.reduce(function (a, b) {\n          if (typeof b === 'string') return a + b;\n          else if (Array.isArray(b)) return a + `(${b.map(()=> `args[${argNum++}]`)})`;\n        }, 'return _');\n\n        var fnStr = `\n        try{\n          ${expression};\n        }catch(err){\n          ${hasDefault ? 'return defaultValue;' : ''}\n          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '${expression}';\n          throw err;\n        }`;\n\n        var finalFn = new Function(['args', '_', 'defaultValue'], fnStr);\n        return finalFn(args, argumentsList[0], defaultValue);\n      }\n    }\n  };\n\n  var _ = new Proxy(receiveFn, handle);\n  return _;\n};\n```\n\n测试代码如下：\n```javascript\nvar _1 = require('../index')(undefined);\nvar _2 = require('../index')();\nvar _3 = require('../index')({foo: 'bar'});\n\nPromise.resolve({a: 12333})\n  .then(_1.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 1:'), console.error.bind(null, 'catch error1:'))\n\n  .then(()=>({a: 12333}))\n  .then(_2.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'))\n\n  .then(()=>({a: 12333}))\n  .then(_3.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'));\n```\n\n本段代码已经做为模块提交到[npm](https://www.npmjs.com/package/chainproxy)上","slug":"Proxy对象仿Scala的通配符函数调用","published":1,"updated":"2020-06-17T10:26:40.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbi000csou5e53j43tk","content":"<p><code>Proxy</code>对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本<code>javascript</code>无法完成的特性，在不长的<code>scala语言</code>学习过程中，发现这门语言有一个很神奇的通配符<code>_</code>，在函数链式调用中，<code>_</code>就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(_.toString());</span><br></pre></td></tr></table></figure></p>\n<p>就是对每个传来的对象，调用他们自身的<code>toString()</code>方法，使用ES6中的<code>Proxy</code>对象，可以很容易地模拟该特性<br>（nodejs v6.0已支持<code>Proxy</code>，代码亦可在最新版chrome中运行）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] !== <span class=\"string\">&#x27;function&#x27;</span>) <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">      <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">&#x27;function&#x27;</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> obj[key].call(obj, ...args);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>除了调用对象自带的方法外，还有取出属性的功能，运行结果如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">32</span>, <span class=\"number\">128</span>, <span class=\"number\">1024</span>].map(_.toString(<span class=\"string\">&#x27;2&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">//return [&quot;1&quot;, &quot;100000&quot;, &quot;10000000&quot;, &quot;10000000000&quot;]</span></span><br><span class=\"line\"></span><br><span class=\"line\">[&#123;<span class=\"attr\">v</span>:<span class=\"number\">123</span>&#125;,&#123;<span class=\"attr\">v</span>:<span class=\"number\">456</span>&#125;].map(_.v);</span><br><span class=\"line\"><span class=\"comment\">//return [123, 456]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</span><br><span class=\"line\">  .then(_.getTime())</span><br><span class=\"line\">  .then(_.toString())</span><br><span class=\"line\">  .then(_.length)</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br><span class=\"line\"><span class=\"comment\">//return 13</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"2016-6-8续\"><a href=\"#2016-6-8续\" class=\"headerlink\" title=\"2016-6-8续\"></a>2016-6-8续</h1><p>之前研究<code>Proxy</code>的时候写出来的那个<code>_</code>实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个<code>_</code>的作用层数，不能继续往里面走，解决的方法当然是继续返回一个<code>Proxy</code>，思路如下：</p>\n<ul>\n<li><p><code>_</code>本身返回一个Proxy，取属性操作返回的也是一个<code>Proxy</code>，这些<code>Proxy</code>指向一个函数，并在被调用时按顺序取出第一个参数里的属性</p>\n</li>\n<li><p><code>_</code>可以预接收参数，接收的参数将在<code>Proxy</code>被调用时传给取出来的函数</p>\n</li>\n</ul>\n<p>难点是如何知道<code>Proxy</code>是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了<code>Proxy</code>的相关资料后，我意识到上述的两种情况，对应的<code>this</code>应该是不同的，后来又发现过长的调用链每次都要经过多个<code>Proxy</code>可能会影响效率，我又改成另外一种形式实现：<code>Proxy</code>负责收集参数和属性名，并在最终调用的时候新建一个<code>Function</code>，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 <code>s=&gt;s.xx.yy.zz()</code> 给简化成 <code>_.xx.yy.zz()</code> 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by ngtmuzi on 2016/5/29.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> receiveFn = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> args;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * chain proxy maker</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@params <span class=\"type\">&#123;Any&#125;</span> <span class=\"variable\">defaultValue</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;Function&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chainProxy = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">defaultValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hasDefault   = <span class=\"built_in\">arguments</span>.length &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> handle = &#123;</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, property, receiver</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//set prototype to base Proxy Object _</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">&#x27;prototype&#x27;</span>) <span class=\"keyword\">return</span> _;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">&#x27;apply&#x27;</span>) <span class=\"keyword\">return</span> target.apply;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">&#x27;call&#x27;</span>) <span class=\"keyword\">return</span> target.call;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">&#x27;bind&#x27;</span>) <span class=\"keyword\">return</span> target.bind;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//is number</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">isNaN</span>(+property)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">`[<span class=\"subst\">$&#123;property&#125;</span>]`</span>), handle);</span><br><span class=\"line\">      <span class=\"comment\">//return a new Proxy, go on</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;.&#x27;</span> + property), handle);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    apply: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, thisArg, argumentsList</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//if method calling on Proxy Object</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (thisArg &amp;&amp; thisArg.prototype === _) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//save arguments to chain, and go on</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, argumentsList), handle);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//calling on outside</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//get the calling chain</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> chains = target();</span><br><span class=\"line\">        <span class=\"comment\">//pick arguments</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> args   = [].concat(...chains.filter(<span class=\"built_in\">Array</span>.isArray));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//make function body</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> argNum     = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> expression = chains.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> b === <span class=\"string\">&#x27;string&#x27;</span>) <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(b)) <span class=\"keyword\">return</span> a + <span class=\"string\">`(<span class=\"subst\">$&#123;b.map(()=&gt; <span class=\"string\">`args[<span class=\"subst\">$&#123;argNum++&#125;</span>]`</span>)&#125;</span>)`</span>;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&#x27;return _&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> fnStr = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        try&#123;</span></span><br><span class=\"line\"><span class=\"string\">          <span class=\"subst\">$&#123;expression&#125;</span>;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;catch(err)&#123;</span></span><br><span class=\"line\"><span class=\"string\">          <span class=\"subst\">$&#123;hasDefault ? <span class=\"string\">&#x27;return defaultValue;&#x27;</span> : <span class=\"string\">&#x27;&#x27;</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">          err.stack = err.name + &#x27;: &#x27; + err.message + &#x27;\\\\n\\\\tat: &#x27; + &#x27;<span class=\"subst\">$&#123;expression&#125;</span>&#x27;;</span></span><br><span class=\"line\"><span class=\"string\">          throw err;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> finalFn = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>([<span class=\"string\">&#x27;args&#x27;</span>, <span class=\"string\">&#x27;_&#x27;</span>, <span class=\"string\">&#x27;defaultValue&#x27;</span>], fnStr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> finalFn(args, argumentsList[<span class=\"number\">0</span>], defaultValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(receiveFn, handle);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _1 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../index&#x27;</span>)(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _2 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../index&#x27;</span>)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> _3 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../index&#x27;</span>)(&#123;<span class=\"attr\">foo</span>: <span class=\"string\">&#x27;bar&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;)</span><br><span class=\"line\">  .then(_1.ab.toString().split(<span class=\"string\">&#x27;&#x27;</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;replaceStr&#x27;</span>).length)</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;result 1:&#x27;</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;catch error1:&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  .then(<span class=\"function\">()=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</span><br><span class=\"line\">  .then(_2.ab.toString().split(<span class=\"string\">&#x27;&#x27;</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;replaceStr&#x27;</span>).length)</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;result 2:&#x27;</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;catch error2:&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  .then(<span class=\"function\">()=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</span><br><span class=\"line\">  .then(_3.ab.toString().split(<span class=\"string\">&#x27;&#x27;</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;replaceStr&#x27;</span>).length)</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;result 2:&#x27;</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;catch error2:&#x27;</span>));</span><br></pre></td></tr></table></figure></p>\n<p>本段代码已经做为模块提交到<a href=\"https://www.npmjs.com/package/chainproxy\">npm</a>上</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>Proxy</code>对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本<code>javascript</code>无法完成的特性，在不长的<code>scala语言</code>学习过程中，发现这门语言有一个很神奇的通配符<code>_</code>，在函数链式调用中，<code>_</code>就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(_.toString());</span><br></pre></td></tr></table></figure></p>\n<p>就是对每个传来的对象，调用他们自身的<code>toString()</code>方法，使用ES6中的<code>Proxy</code>对象，可以很容易地模拟该特性<br>（nodejs v6.0已支持<code>Proxy</code>，代码亦可在最新版chrome中运行）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] !== <span class=\"string\">&#x27;function&#x27;</span>) <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">      <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">&#x27;function&#x27;</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> obj[key].call(obj, ...args);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>除了调用对象自带的方法外，还有取出属性的功能，运行结果如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">32</span>, <span class=\"number\">128</span>, <span class=\"number\">1024</span>].map(_.toString(<span class=\"string\">&#x27;2&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">//return [&quot;1&quot;, &quot;100000&quot;, &quot;10000000&quot;, &quot;10000000000&quot;]</span></span><br><span class=\"line\"></span><br><span class=\"line\">[&#123;<span class=\"attr\">v</span>:<span class=\"number\">123</span>&#125;,&#123;<span class=\"attr\">v</span>:<span class=\"number\">456</span>&#125;].map(_.v);</span><br><span class=\"line\"><span class=\"comment\">//return [123, 456]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</span><br><span class=\"line\">  .then(_.getTime())</span><br><span class=\"line\">  .then(_.toString())</span><br><span class=\"line\">  .then(_.length)</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</span><br><span class=\"line\"><span class=\"comment\">//return 13</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"2016-6-8续\"><a href=\"#2016-6-8续\" class=\"headerlink\" title=\"2016-6-8续\"></a>2016-6-8续</h1><p>之前研究<code>Proxy</code>的时候写出来的那个<code>_</code>实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个<code>_</code>的作用层数，不能继续往里面走，解决的方法当然是继续返回一个<code>Proxy</code>，思路如下：</p>\n<ul>\n<li><p><code>_</code>本身返回一个Proxy，取属性操作返回的也是一个<code>Proxy</code>，这些<code>Proxy</code>指向一个函数，并在被调用时按顺序取出第一个参数里的属性</p>\n</li>\n<li><p><code>_</code>可以预接收参数，接收的参数将在<code>Proxy</code>被调用时传给取出来的函数</p>\n</li>\n</ul>\n<p>难点是如何知道<code>Proxy</code>是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了<code>Proxy</code>的相关资料后，我意识到上述的两种情况，对应的<code>this</code>应该是不同的，后来又发现过长的调用链每次都要经过多个<code>Proxy</code>可能会影响效率，我又改成另外一种形式实现：<code>Proxy</code>负责收集参数和属性名，并在最终调用的时候新建一个<code>Function</code>，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 <code>s=&gt;s.xx.yy.zz()</code> 给简化成 <code>_.xx.yy.zz()</code> 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by ngtmuzi on 2016/5/29.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> receiveFn = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> args;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * chain proxy maker</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@params <span class=\"type\">&#123;Any&#125;</span> <span class=\"variable\">defaultValue</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;Function&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chainProxy = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">defaultValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hasDefault   = <span class=\"built_in\">arguments</span>.length &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> handle = &#123;</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, property, receiver</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//set prototype to base Proxy Object _</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">&#x27;prototype&#x27;</span>) <span class=\"keyword\">return</span> _;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">&#x27;apply&#x27;</span>) <span class=\"keyword\">return</span> target.apply;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">&#x27;call&#x27;</span>) <span class=\"keyword\">return</span> target.call;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">&#x27;bind&#x27;</span>) <span class=\"keyword\">return</span> target.bind;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//is number</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">isNaN</span>(+property)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">`[<span class=\"subst\">$&#123;property&#125;</span>]`</span>), handle);</span><br><span class=\"line\">      <span class=\"comment\">//return a new Proxy, go on</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;.&#x27;</span> + property), handle);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    apply: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, thisArg, argumentsList</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//if method calling on Proxy Object</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (thisArg &amp;&amp; thisArg.prototype === _) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//save arguments to chain, and go on</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, argumentsList), handle);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//calling on outside</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//get the calling chain</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> chains = target();</span><br><span class=\"line\">        <span class=\"comment\">//pick arguments</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> args   = [].concat(...chains.filter(<span class=\"built_in\">Array</span>.isArray));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//make function body</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> argNum     = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> expression = chains.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> b === <span class=\"string\">&#x27;string&#x27;</span>) <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(b)) <span class=\"keyword\">return</span> a + <span class=\"string\">`(<span class=\"subst\">$&#123;b.map(()=&gt; <span class=\"string\">`args[<span class=\"subst\">$&#123;argNum++&#125;</span>]`</span>)&#125;</span>)`</span>;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&#x27;return _&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> fnStr = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        try&#123;</span></span><br><span class=\"line\"><span class=\"string\">          <span class=\"subst\">$&#123;expression&#125;</span>;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;catch(err)&#123;</span></span><br><span class=\"line\"><span class=\"string\">          <span class=\"subst\">$&#123;hasDefault ? <span class=\"string\">&#x27;return defaultValue;&#x27;</span> : <span class=\"string\">&#x27;&#x27;</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">          err.stack = err.name + &#x27;: &#x27; + err.message + &#x27;\\\\n\\\\tat: &#x27; + &#x27;<span class=\"subst\">$&#123;expression&#125;</span>&#x27;;</span></span><br><span class=\"line\"><span class=\"string\">          throw err;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> finalFn = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>([<span class=\"string\">&#x27;args&#x27;</span>, <span class=\"string\">&#x27;_&#x27;</span>, <span class=\"string\">&#x27;defaultValue&#x27;</span>], fnStr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> finalFn(args, argumentsList[<span class=\"number\">0</span>], defaultValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(receiveFn, handle);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>测试代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _1 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../index&#x27;</span>)(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _2 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../index&#x27;</span>)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> _3 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../index&#x27;</span>)(&#123;<span class=\"attr\">foo</span>: <span class=\"string\">&#x27;bar&#x27;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;)</span><br><span class=\"line\">  .then(_1.ab.toString().split(<span class=\"string\">&#x27;&#x27;</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;replaceStr&#x27;</span>).length)</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;result 1:&#x27;</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;catch error1:&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  .then(<span class=\"function\">()=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</span><br><span class=\"line\">  .then(_2.ab.toString().split(<span class=\"string\">&#x27;&#x27;</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;replaceStr&#x27;</span>).length)</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;result 2:&#x27;</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;catch error2:&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  .then(<span class=\"function\">()=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</span><br><span class=\"line\">  .then(_3.ab.toString().split(<span class=\"string\">&#x27;&#x27;</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;replaceStr&#x27;</span>).length)</span><br><span class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;result 2:&#x27;</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;catch error2:&#x27;</span>));</span><br></pre></td></tr></table></figure></p>\n<p>本段代码已经做为模块提交到<a href=\"https://www.npmjs.com/package/chainproxy\">npm</a>上</p>\n"},{"title":"javaScript实现一个分数计算的类","desc":"难得写点有趣的东西","author":"ngtmuzi","date":"2018-05-25T07:48:17.000Z","_content":"\n一开始实现的时候钻到了牛角尖里，还想着要保留复杂分式的所有结构，那就要构建成树还要做递归遍历，各种计算也复杂得要死，后来想了一下每次计算都直接化成最简式不就好了\n\n```javascript\n\n/**\n * @property {Number} numerator  分子\n * @property {Number} denominator  分母\n */\nclass Fraction {\n  /**\n   * 可以接受数值和分式\n   * @param {Number|Fraction} numerator\n   * @param {Number|Fraction} denominator\n   * @return {Fraction}\n   */\n  constructor(numerator, denominator = 1) {\n    if (Number.isInteger(numerator) && Number.isInteger(denominator)) {\n      this.numerator   = numerator;\n      this.denominator = denominator;\n    } else if (numerator instanceof Fraction || denominator instanceof Fraction) {\n      numerator   = numerator instanceof Fraction ? numerator : new Fraction(numerator, 1);\n      denominator = denominator instanceof Fraction ? denominator : new Fraction(denominator, 1);\n\n      return numerator.clone().divide(denominator);\n    } else {\n      throw new TypeError('prams must be Number or Fraction');\n    }\n    this.simplify();\n  }\n\n  /**\n   * 辗转相除法求最大公约数\n   * @param num1\n   * @param num2\n   * @return {number}\n   */\n  static greatestCommonDivisor(num1, num2) {\n    let lesser  = Math.abs(num1);\n    let greater = Math.abs(num2);\n\n    while (lesser !== 0) {\n      let t   = lesser;\n      lesser  = greater % lesser;\n      greater = t;\n    }\n    return greater;\n  }\n\n  clone() {\n    return new Fraction(this.numerator, this.denominator);\n  }\n\n  /**\n   * 化简分式\n   * @return {Fraction}\n   */\n  simplify() {\n    const gcd        = Fraction.greatestCommonDivisor(this.numerator, this.denominator);\n    this.numerator   = this.numerator / gcd;\n    this.denominator = this.denominator / gcd;\n    return this;\n  }\n\n  /**\n   * 导出格式  a/b\n   * @return {string}\n   */\n  toString() {\n    return `${this.numerator}/${this.denominator}`;\n  }\n\n  /**\n   * 从字符串解析出分式，支持 1/3 和  3 的格式\n   * @param str\n   * @return {Fraction}\n   */\n  static fromString(str = '') {\n    let arr = str.split('/').map(Number).filter(Number.isInteger);\n    if (arr.length === 1) arr.push(1);\n    if (arr.length !== 2) throw TypeError('params must be 2 Integer spread by \"/\"');\n    return new Fraction(arr[0], arr[1]);\n  }\n\n  get value() {\n    return this.numerator / this.denominator;\n  }\n\n  static add(frac1, frac2) {\n    frac1 = frac1 instanceof Fraction ? frac1.clone() : new Fraction(frac1);\n    frac2 = frac2 instanceof Fraction ? frac2.clone() : new Fraction(frac2);\n\n    //  a/b + c/d = (a*d+b*c) / b*d\n    frac1.numerator   = frac1.numerator * frac2.denominator + frac1.denominator * frac2.numerator;\n    frac1.denominator = frac1.denominator * frac2.denominator;\n    return frac1.simplify();\n  }\n\n  add(frac) {\n    return Fraction.add(this, frac);\n  }\n\n  static subtract(frac1, frac2) {\n    frac1 = frac1 instanceof Fraction ? frac1.clone() : new Fraction(frac1);\n    frac2 = frac2 instanceof Fraction ? frac2.clone() : new Fraction(frac2);\n\n    //  a/b + c/d = (a*d-b*c) / b*d\n    frac1.numerator   = frac1.numerator * frac2.denominator - frac1.denominator * frac2.numerator;\n    frac1.denominator = frac1.denominator * frac2.denominator;\n    return frac1.simplify();\n  }\n\n  subtract(frac) {\n    return Fraction.subtract(this, frac);\n  }\n\n  static multiply(frac1, frac2) {\n    frac1 = frac1 instanceof Fraction ? frac1.clone() : new Fraction(frac1);\n    frac2 = frac2 instanceof Fraction ? frac2.clone() : new Fraction(frac2);\n\n    // (a/b)*(c/d) = (a*b)/(c*d)\n    frac1.numerator   = frac1.numerator * frac2.numerator;\n    frac1.denominator = frac1.denominator * frac2.denominator;\n    return frac1.simplify();\n  }\n\n  multiply(frac) {\n    return Fraction.multiply(this, frac);\n  }\n\n  static divide(frac1, frac2) {\n    frac1 = frac1 instanceof Fraction ? frac1.clone() : new Fraction(frac1);\n    frac2 = frac2 instanceof Fraction ? frac2.clone() : new Fraction(frac2);\n\n    //  (a/b) / (c/d) = (a*d) / (b*c)\n    frac1.numerator   = frac1.numerator * frac2.denominator;\n    frac1.denominator = frac1.denominator * frac2.numerator;\n    return frac1.simplify();\n  }\n\n  divide(frac) {\n    return Fraction.divide(this, frac);\n  }\n\n}\n```\n业务代码写得多了居然连这种简单的功能代码都生疏了，老了老了，原来计划的每月一篇博客肯定是鸽了","source":"_posts/javaScript实现一个分数计算的类.md","raw":"---\ntitle: javaScript实现一个分数计算的类\ndesc: 难得写点有趣的东西\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2018-05-25 15:48:17\ntags: \n- javascript\n- Class\n---\n\n一开始实现的时候钻到了牛角尖里，还想着要保留复杂分式的所有结构，那就要构建成树还要做递归遍历，各种计算也复杂得要死，后来想了一下每次计算都直接化成最简式不就好了\n\n```javascript\n\n/**\n * @property {Number} numerator  分子\n * @property {Number} denominator  分母\n */\nclass Fraction {\n  /**\n   * 可以接受数值和分式\n   * @param {Number|Fraction} numerator\n   * @param {Number|Fraction} denominator\n   * @return {Fraction}\n   */\n  constructor(numerator, denominator = 1) {\n    if (Number.isInteger(numerator) && Number.isInteger(denominator)) {\n      this.numerator   = numerator;\n      this.denominator = denominator;\n    } else if (numerator instanceof Fraction || denominator instanceof Fraction) {\n      numerator   = numerator instanceof Fraction ? numerator : new Fraction(numerator, 1);\n      denominator = denominator instanceof Fraction ? denominator : new Fraction(denominator, 1);\n\n      return numerator.clone().divide(denominator);\n    } else {\n      throw new TypeError('prams must be Number or Fraction');\n    }\n    this.simplify();\n  }\n\n  /**\n   * 辗转相除法求最大公约数\n   * @param num1\n   * @param num2\n   * @return {number}\n   */\n  static greatestCommonDivisor(num1, num2) {\n    let lesser  = Math.abs(num1);\n    let greater = Math.abs(num2);\n\n    while (lesser !== 0) {\n      let t   = lesser;\n      lesser  = greater % lesser;\n      greater = t;\n    }\n    return greater;\n  }\n\n  clone() {\n    return new Fraction(this.numerator, this.denominator);\n  }\n\n  /**\n   * 化简分式\n   * @return {Fraction}\n   */\n  simplify() {\n    const gcd        = Fraction.greatestCommonDivisor(this.numerator, this.denominator);\n    this.numerator   = this.numerator / gcd;\n    this.denominator = this.denominator / gcd;\n    return this;\n  }\n\n  /**\n   * 导出格式  a/b\n   * @return {string}\n   */\n  toString() {\n    return `${this.numerator}/${this.denominator}`;\n  }\n\n  /**\n   * 从字符串解析出分式，支持 1/3 和  3 的格式\n   * @param str\n   * @return {Fraction}\n   */\n  static fromString(str = '') {\n    let arr = str.split('/').map(Number).filter(Number.isInteger);\n    if (arr.length === 1) arr.push(1);\n    if (arr.length !== 2) throw TypeError('params must be 2 Integer spread by \"/\"');\n    return new Fraction(arr[0], arr[1]);\n  }\n\n  get value() {\n    return this.numerator / this.denominator;\n  }\n\n  static add(frac1, frac2) {\n    frac1 = frac1 instanceof Fraction ? frac1.clone() : new Fraction(frac1);\n    frac2 = frac2 instanceof Fraction ? frac2.clone() : new Fraction(frac2);\n\n    //  a/b + c/d = (a*d+b*c) / b*d\n    frac1.numerator   = frac1.numerator * frac2.denominator + frac1.denominator * frac2.numerator;\n    frac1.denominator = frac1.denominator * frac2.denominator;\n    return frac1.simplify();\n  }\n\n  add(frac) {\n    return Fraction.add(this, frac);\n  }\n\n  static subtract(frac1, frac2) {\n    frac1 = frac1 instanceof Fraction ? frac1.clone() : new Fraction(frac1);\n    frac2 = frac2 instanceof Fraction ? frac2.clone() : new Fraction(frac2);\n\n    //  a/b + c/d = (a*d-b*c) / b*d\n    frac1.numerator   = frac1.numerator * frac2.denominator - frac1.denominator * frac2.numerator;\n    frac1.denominator = frac1.denominator * frac2.denominator;\n    return frac1.simplify();\n  }\n\n  subtract(frac) {\n    return Fraction.subtract(this, frac);\n  }\n\n  static multiply(frac1, frac2) {\n    frac1 = frac1 instanceof Fraction ? frac1.clone() : new Fraction(frac1);\n    frac2 = frac2 instanceof Fraction ? frac2.clone() : new Fraction(frac2);\n\n    // (a/b)*(c/d) = (a*b)/(c*d)\n    frac1.numerator   = frac1.numerator * frac2.numerator;\n    frac1.denominator = frac1.denominator * frac2.denominator;\n    return frac1.simplify();\n  }\n\n  multiply(frac) {\n    return Fraction.multiply(this, frac);\n  }\n\n  static divide(frac1, frac2) {\n    frac1 = frac1 instanceof Fraction ? frac1.clone() : new Fraction(frac1);\n    frac2 = frac2 instanceof Fraction ? frac2.clone() : new Fraction(frac2);\n\n    //  (a/b) / (c/d) = (a*d) / (b*c)\n    frac1.numerator   = frac1.numerator * frac2.denominator;\n    frac1.denominator = frac1.denominator * frac2.numerator;\n    return frac1.simplify();\n  }\n\n  divide(frac) {\n    return Fraction.divide(this, frac);\n  }\n\n}\n```\n业务代码写得多了居然连这种简单的功能代码都生疏了，老了老了，原来计划的每月一篇博客肯定是鸽了","slug":"javaScript实现一个分数计算的类","published":1,"updated":"2020-06-17T10:26:40.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbj000dsou5cybr6cxb","content":"<p>一开始实现的时候钻到了牛角尖里，还想着要保留复杂分式的所有结构，那就要构建成树还要做递归遍历，各种计算也复杂得要死，后来想了一下每次计算都直接化成最简式不就好了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;Number&#125;</span> </span>numerator  分子</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;Number&#125;</span> </span>denominator  分母</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fraction</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 可以接受数值和分式</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Number|Fraction&#125;</span> <span class=\"variable\">numerator</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Number|Fraction&#125;</span> <span class=\"variable\">denominator</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;Fraction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">numerator, denominator = <span class=\"number\">1</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Number</span>.isInteger(numerator) &amp;&amp; <span class=\"built_in\">Number</span>.isInteger(denominator)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.numerator   = numerator;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.denominator = denominator;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numerator <span class=\"keyword\">instanceof</span> Fraction || denominator <span class=\"keyword\">instanceof</span> Fraction) &#123;</span><br><span class=\"line\">      numerator   = numerator <span class=\"keyword\">instanceof</span> Fraction ? numerator : <span class=\"keyword\">new</span> Fraction(numerator, <span class=\"number\">1</span>);</span><br><span class=\"line\">      denominator = denominator <span class=\"keyword\">instanceof</span> Fraction ? denominator : <span class=\"keyword\">new</span> Fraction(denominator, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> numerator.clone().divide(denominator);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;prams must be Number or Fraction&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 辗转相除法求最大公约数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"variable\">num1</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"variable\">num2</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">greatestCommonDivisor</span>(<span class=\"params\">num1, num2</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lesser  = <span class=\"built_in\">Math</span>.abs(num1);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> greater = <span class=\"built_in\">Math</span>.abs(num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (lesser !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> t   = lesser;</span><br><span class=\"line\">      lesser  = greater % lesser;</span><br><span class=\"line\">      greater = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> greater;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clone</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Fraction(<span class=\"built_in\">this</span>.numerator, <span class=\"built_in\">this</span>.denominator);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 化简分式</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;Fraction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">simplify</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> gcd        = Fraction.greatestCommonDivisor(<span class=\"built_in\">this</span>.numerator, <span class=\"built_in\">this</span>.denominator);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.numerator   = <span class=\"built_in\">this</span>.numerator / gcd;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.denominator = <span class=\"built_in\">this</span>.denominator / gcd;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 导出格式  a/b</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;string&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.numerator&#125;</span>/<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.denominator&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 从字符串解析出分式，支持 1/3 和  3 的格式</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"variable\">str</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;Fraction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">fromString</span>(<span class=\"params\">str = <span class=\"string\">&#x27;&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = str.split(<span class=\"string\">&#x27;/&#x27;</span>).map(<span class=\"built_in\">Number</span>).filter(<span class=\"built_in\">Number</span>.isInteger);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">1</span>) arr.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length !== <span class=\"number\">2</span>) <span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;params must be 2 Integer spread by &quot;/&quot;&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Fraction(arr[<span class=\"number\">0</span>], arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">value</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.numerator / <span class=\"built_in\">this</span>.denominator;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">frac1, frac2</span>)</span> &#123;</span><br><span class=\"line\">    frac1 = frac1 <span class=\"keyword\">instanceof</span> Fraction ? frac1.clone() : <span class=\"keyword\">new</span> Fraction(frac1);</span><br><span class=\"line\">    frac2 = frac2 <span class=\"keyword\">instanceof</span> Fraction ? frac2.clone() : <span class=\"keyword\">new</span> Fraction(frac2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  a/b + c/d = (a*d+b*c) / b*d</span></span><br><span class=\"line\">    frac1.numerator   = frac1.numerator * frac2.denominator + frac1.denominator * frac2.numerator;</span><br><span class=\"line\">    frac1.denominator = frac1.denominator * frac2.denominator;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frac1.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">frac</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fraction.add(<span class=\"built_in\">this</span>, frac);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">subtract</span>(<span class=\"params\">frac1, frac2</span>)</span> &#123;</span><br><span class=\"line\">    frac1 = frac1 <span class=\"keyword\">instanceof</span> Fraction ? frac1.clone() : <span class=\"keyword\">new</span> Fraction(frac1);</span><br><span class=\"line\">    frac2 = frac2 <span class=\"keyword\">instanceof</span> Fraction ? frac2.clone() : <span class=\"keyword\">new</span> Fraction(frac2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  a/b + c/d = (a*d-b*c) / b*d</span></span><br><span class=\"line\">    frac1.numerator   = frac1.numerator * frac2.denominator - frac1.denominator * frac2.numerator;</span><br><span class=\"line\">    frac1.denominator = frac1.denominator * frac2.denominator;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frac1.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">subtract</span>(<span class=\"params\">frac</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fraction.subtract(<span class=\"built_in\">this</span>, frac);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">multiply</span>(<span class=\"params\">frac1, frac2</span>)</span> &#123;</span><br><span class=\"line\">    frac1 = frac1 <span class=\"keyword\">instanceof</span> Fraction ? frac1.clone() : <span class=\"keyword\">new</span> Fraction(frac1);</span><br><span class=\"line\">    frac2 = frac2 <span class=\"keyword\">instanceof</span> Fraction ? frac2.clone() : <span class=\"keyword\">new</span> Fraction(frac2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// (a/b)*(c/d) = (a*b)/(c*d)</span></span><br><span class=\"line\">    frac1.numerator   = frac1.numerator * frac2.numerator;</span><br><span class=\"line\">    frac1.denominator = frac1.denominator * frac2.denominator;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frac1.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">multiply</span>(<span class=\"params\">frac</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fraction.multiply(<span class=\"built_in\">this</span>, frac);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">divide</span>(<span class=\"params\">frac1, frac2</span>)</span> &#123;</span><br><span class=\"line\">    frac1 = frac1 <span class=\"keyword\">instanceof</span> Fraction ? frac1.clone() : <span class=\"keyword\">new</span> Fraction(frac1);</span><br><span class=\"line\">    frac2 = frac2 <span class=\"keyword\">instanceof</span> Fraction ? frac2.clone() : <span class=\"keyword\">new</span> Fraction(frac2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  (a/b) / (c/d) = (a*d) / (b*c)</span></span><br><span class=\"line\">    frac1.numerator   = frac1.numerator * frac2.denominator;</span><br><span class=\"line\">    frac1.denominator = frac1.denominator * frac2.numerator;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frac1.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">divide</span>(<span class=\"params\">frac</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fraction.divide(<span class=\"built_in\">this</span>, frac);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>业务代码写得多了居然连这种简单的功能代码都生疏了，老了老了，原来计划的每月一篇博客肯定是鸽了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一开始实现的时候钻到了牛角尖里，还想着要保留复杂分式的所有结构，那就要构建成树还要做递归遍历，各种计算也复杂得要死，后来想了一下每次计算都直接化成最简式不就好了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;Number&#125;</span> </span>numerator  分子</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;Number&#125;</span> </span>denominator  分母</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fraction</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 可以接受数值和分式</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Number|Fraction&#125;</span> <span class=\"variable\">numerator</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Number|Fraction&#125;</span> <span class=\"variable\">denominator</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;Fraction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">numerator, denominator = <span class=\"number\">1</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Number</span>.isInteger(numerator) &amp;&amp; <span class=\"built_in\">Number</span>.isInteger(denominator)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.numerator   = numerator;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.denominator = denominator;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numerator <span class=\"keyword\">instanceof</span> Fraction || denominator <span class=\"keyword\">instanceof</span> Fraction) &#123;</span><br><span class=\"line\">      numerator   = numerator <span class=\"keyword\">instanceof</span> Fraction ? numerator : <span class=\"keyword\">new</span> Fraction(numerator, <span class=\"number\">1</span>);</span><br><span class=\"line\">      denominator = denominator <span class=\"keyword\">instanceof</span> Fraction ? denominator : <span class=\"keyword\">new</span> Fraction(denominator, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> numerator.clone().divide(denominator);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;prams must be Number or Fraction&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 辗转相除法求最大公约数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"variable\">num1</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"variable\">num2</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">greatestCommonDivisor</span>(<span class=\"params\">num1, num2</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lesser  = <span class=\"built_in\">Math</span>.abs(num1);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> greater = <span class=\"built_in\">Math</span>.abs(num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (lesser !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> t   = lesser;</span><br><span class=\"line\">      lesser  = greater % lesser;</span><br><span class=\"line\">      greater = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> greater;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clone</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Fraction(<span class=\"built_in\">this</span>.numerator, <span class=\"built_in\">this</span>.denominator);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 化简分式</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;Fraction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">simplify</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> gcd        = Fraction.greatestCommonDivisor(<span class=\"built_in\">this</span>.numerator, <span class=\"built_in\">this</span>.denominator);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.numerator   = <span class=\"built_in\">this</span>.numerator / gcd;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.denominator = <span class=\"built_in\">this</span>.denominator / gcd;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 导出格式  a/b</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;string&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.numerator&#125;</span>/<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.denominator&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 从字符串解析出分式，支持 1/3 和  3 的格式</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"variable\">str</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return <span class=\"type\">&#123;Fraction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">fromString</span>(<span class=\"params\">str = <span class=\"string\">&#x27;&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = str.split(<span class=\"string\">&#x27;/&#x27;</span>).map(<span class=\"built_in\">Number</span>).filter(<span class=\"built_in\">Number</span>.isInteger);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">1</span>) arr.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length !== <span class=\"number\">2</span>) <span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;params must be 2 Integer spread by &quot;/&quot;&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Fraction(arr[<span class=\"number\">0</span>], arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">value</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.numerator / <span class=\"built_in\">this</span>.denominator;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">frac1, frac2</span>)</span> &#123;</span><br><span class=\"line\">    frac1 = frac1 <span class=\"keyword\">instanceof</span> Fraction ? frac1.clone() : <span class=\"keyword\">new</span> Fraction(frac1);</span><br><span class=\"line\">    frac2 = frac2 <span class=\"keyword\">instanceof</span> Fraction ? frac2.clone() : <span class=\"keyword\">new</span> Fraction(frac2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  a/b + c/d = (a*d+b*c) / b*d</span></span><br><span class=\"line\">    frac1.numerator   = frac1.numerator * frac2.denominator + frac1.denominator * frac2.numerator;</span><br><span class=\"line\">    frac1.denominator = frac1.denominator * frac2.denominator;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frac1.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">frac</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fraction.add(<span class=\"built_in\">this</span>, frac);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">subtract</span>(<span class=\"params\">frac1, frac2</span>)</span> &#123;</span><br><span class=\"line\">    frac1 = frac1 <span class=\"keyword\">instanceof</span> Fraction ? frac1.clone() : <span class=\"keyword\">new</span> Fraction(frac1);</span><br><span class=\"line\">    frac2 = frac2 <span class=\"keyword\">instanceof</span> Fraction ? frac2.clone() : <span class=\"keyword\">new</span> Fraction(frac2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  a/b + c/d = (a*d-b*c) / b*d</span></span><br><span class=\"line\">    frac1.numerator   = frac1.numerator * frac2.denominator - frac1.denominator * frac2.numerator;</span><br><span class=\"line\">    frac1.denominator = frac1.denominator * frac2.denominator;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frac1.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">subtract</span>(<span class=\"params\">frac</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fraction.subtract(<span class=\"built_in\">this</span>, frac);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">multiply</span>(<span class=\"params\">frac1, frac2</span>)</span> &#123;</span><br><span class=\"line\">    frac1 = frac1 <span class=\"keyword\">instanceof</span> Fraction ? frac1.clone() : <span class=\"keyword\">new</span> Fraction(frac1);</span><br><span class=\"line\">    frac2 = frac2 <span class=\"keyword\">instanceof</span> Fraction ? frac2.clone() : <span class=\"keyword\">new</span> Fraction(frac2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// (a/b)*(c/d) = (a*b)/(c*d)</span></span><br><span class=\"line\">    frac1.numerator   = frac1.numerator * frac2.numerator;</span><br><span class=\"line\">    frac1.denominator = frac1.denominator * frac2.denominator;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frac1.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">multiply</span>(<span class=\"params\">frac</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fraction.multiply(<span class=\"built_in\">this</span>, frac);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">divide</span>(<span class=\"params\">frac1, frac2</span>)</span> &#123;</span><br><span class=\"line\">    frac1 = frac1 <span class=\"keyword\">instanceof</span> Fraction ? frac1.clone() : <span class=\"keyword\">new</span> Fraction(frac1);</span><br><span class=\"line\">    frac2 = frac2 <span class=\"keyword\">instanceof</span> Fraction ? frac2.clone() : <span class=\"keyword\">new</span> Fraction(frac2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  (a/b) / (c/d) = (a*d) / (b*c)</span></span><br><span class=\"line\">    frac1.numerator   = frac1.numerator * frac2.denominator;</span><br><span class=\"line\">    frac1.denominator = frac1.denominator * frac2.numerator;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frac1.simplify();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">divide</span>(<span class=\"params\">frac</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fraction.divide(<span class=\"built_in\">this</span>, frac);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>业务代码写得多了居然连这种简单的功能代码都生疏了，老了老了，原来计划的每月一篇博客肯定是鸽了</p>\n"},{"title":"javaScript的函数柯里化","desc":"柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数","date":"2016-01-07T02:11:18.000Z","author":"ngtmuzi","_content":"> 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n\n\n简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：\n```javascript\nfunction curry(fn, context) {\n    function c() {\n        var args = this.concat(Array.prototype.slice.call(arguments));\n        if (args.length >= fn.length) return fn.apply(context, args);\n        return c.bind(args);\n    }\n\n    return c.bind([]);\n}\n```\n\n返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：\n\n```javascript\nvar _a = function (a, b) {\n    return a + b;\n};\nvar a = curry(_a);\n\nconsole.log(a(1, 2), a(2)(3), a()()(3)(4), a()()(4, 5))\n//运行结果： 3 5 7 9\n```","source":"_posts/javaScript的函数柯里化.md","raw":"---\ntitle: javaScript的函数柯里化  \ndesc: 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数  \ndate: 2016-1-7 10:11:18  \ntags: javascript  \nauthor: ngtmuzi  \ncategory: 班门弄斧  \n---\n> 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n\n\n简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：\n```javascript\nfunction curry(fn, context) {\n    function c() {\n        var args = this.concat(Array.prototype.slice.call(arguments));\n        if (args.length >= fn.length) return fn.apply(context, args);\n        return c.bind(args);\n    }\n\n    return c.bind([]);\n}\n```\n\n返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：\n\n```javascript\nvar _a = function (a, b) {\n    return a + b;\n};\nvar a = curry(_a);\n\nconsole.log(a(1, 2), a(2)(3), a()()(3)(4), a()()(4, 5))\n//运行结果： 3 5 7 9\n```","slug":"javaScript的函数柯里化","published":1,"updated":"2020-06-17T10:26:40.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbk000esou59uo1ag9v","content":"<blockquote>\n<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>\n</blockquote>\n<p>简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">this</span>.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length &gt;= fn.length) <span class=\"keyword\">return</span> fn.apply(context, args);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c.bind(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c.bind([]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _a = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = curry(_a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a(<span class=\"number\">1</span>, <span class=\"number\">2</span>), a(<span class=\"number\">2</span>)(<span class=\"number\">3</span>), a()()(<span class=\"number\">3</span>)(<span class=\"number\">4</span>), a()()(<span class=\"number\">4</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"comment\">//运行结果： 3 5 7 9</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>\n</blockquote>\n<p>简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">this</span>.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length &gt;= fn.length) <span class=\"keyword\">return</span> fn.apply(context, args);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c.bind(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c.bind([]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _a = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = curry(_a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a(<span class=\"number\">1</span>, <span class=\"number\">2</span>), a(<span class=\"number\">2</span>)(<span class=\"number\">3</span>), a()()(<span class=\"number\">3</span>)(<span class=\"number\">4</span>), a()()(<span class=\"number\">4</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"comment\">//运行结果： 3 5 7 9</span></span><br></pre></td></tr></table></figure>"},{"title":"javascript模板渲染研究笔记（一）","subtitle":null,"desc":"下面没有了","date":"2015-12-31T01:49:32.000Z","author":"ngtmuzi","_content":"\n只是一名本分的后端`nodejs`程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（`angular`、`reactjs`、`vue`、`meteor`以及各种其他）之后，我最终还是决定使用`express`自带的`ejs`\n \n\n即使是各大主流框架，在很大程度上还是离不开`jquery`，我当然也是如此，使用`ejs`仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。\n\n\n然而`ejs`使用中也是各种不爽，在`html`中加上各种`<%%>`真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（`reactjs`的`jsx语法`在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的`jquery`，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了\n\n\n因此我开始研究在`ejs`中加入jq的功能，`cheerio`模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——\n\n\n去翻了一下`ejs`的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言\n```ejs\n<h1>{{ 1+1 }}</h1>\n```\n\n所对应的中间函数：\n```javascript\nfunction () {\n  var out = '';\n  out += '<h1>';\n  out += escape(1 + 1);\n  out += '</h1>';\n  return new String(out);\n}\n```\n\n中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。\n\n\n可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成\n\n```'\n<h1>' + escape(1 + 1) + '</h1>'\n```\n\n这种格式呢？因为需要支持各种看起来高大上的模板语法，如`if`、`each`之类的。\n\n---\n\n\n好像有点跑题，刚才的问题是，我如何将`cheerio`模块加入到`ejs`中呢？\n\n\n\n\n我们都知道，`ejs`中如果要将某些变量的值带到模板中渲染，需要在render时传递`locals`对象，在这个对象里存储所有渲染需要的变量。\n\n\n但实际上在使用模板引擎时，我们并不会使用名叫`locals`或者其他类似`data`之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）\n```javascript\nfunction(locals){\n  with(locals){\n  ......\n  }\n}\n```\n\n模板引擎将传入的`locals`对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传`locals`对象的时候丢进去：\n```javascript\nvar cheerio = require('cheerio');\nres.render('index',{ $:cheerio } );\n```\n\n\n这样子就能实现在`ejs`里实现类似这样的jq语法了\n```javascript\n<% for(var i = 0; i < 10; i++) {%>\n    <%- $('<a>').text(i.toString()).attr('href','#') %>\n<% } %>\n```","source":"_posts/javascript模板渲染研究笔记（一）.md","raw":"---\ntitle: javascript模板渲染研究笔记（一）  \nsubtitle: \ndesc: 下面没有了\ndate: 2015-12-31 9:49:32\ntags: javascript\nauthor: ngtmuzi  \ncategory: 班门弄斧  \n---\n\n只是一名本分的后端`nodejs`程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（`angular`、`reactjs`、`vue`、`meteor`以及各种其他）之后，我最终还是决定使用`express`自带的`ejs`\n \n\n即使是各大主流框架，在很大程度上还是离不开`jquery`，我当然也是如此，使用`ejs`仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。\n\n\n然而`ejs`使用中也是各种不爽，在`html`中加上各种`<%%>`真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（`reactjs`的`jsx语法`在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的`jquery`，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了\n\n\n因此我开始研究在`ejs`中加入jq的功能，`cheerio`模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——\n\n\n去翻了一下`ejs`的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言\n```ejs\n<h1>{{ 1+1 }}</h1>\n```\n\n所对应的中间函数：\n```javascript\nfunction () {\n  var out = '';\n  out += '<h1>';\n  out += escape(1 + 1);\n  out += '</h1>';\n  return new String(out);\n}\n```\n\n中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。\n\n\n可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成\n\n```'\n<h1>' + escape(1 + 1) + '</h1>'\n```\n\n这种格式呢？因为需要支持各种看起来高大上的模板语法，如`if`、`each`之类的。\n\n---\n\n\n好像有点跑题，刚才的问题是，我如何将`cheerio`模块加入到`ejs`中呢？\n\n\n\n\n我们都知道，`ejs`中如果要将某些变量的值带到模板中渲染，需要在render时传递`locals`对象，在这个对象里存储所有渲染需要的变量。\n\n\n但实际上在使用模板引擎时，我们并不会使用名叫`locals`或者其他类似`data`之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）\n```javascript\nfunction(locals){\n  with(locals){\n  ......\n  }\n}\n```\n\n模板引擎将传入的`locals`对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传`locals`对象的时候丢进去：\n```javascript\nvar cheerio = require('cheerio');\nres.render('index',{ $:cheerio } );\n```\n\n\n这样子就能实现在`ejs`里实现类似这样的jq语法了\n```javascript\n<% for(var i = 0; i < 10; i++) {%>\n    <%- $('<a>').text(i.toString()).attr('href','#') %>\n<% } %>\n```","slug":"javascript模板渲染研究笔记（一）","published":1,"updated":"2020-06-17T10:26:40.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbl000fsou5bgt05vc5","content":"<p>只是一名本分的后端<code>nodejs</code>程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（<code>angular</code>、<code>reactjs</code>、<code>vue</code>、<code>meteor</code>以及各种其他）之后，我最终还是决定使用<code>express</code>自带的<code>ejs</code></p>\n<p>即使是各大主流框架，在很大程度上还是离不开<code>jquery</code>，我当然也是如此，使用<code>ejs</code>仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。</p>\n<p>然而<code>ejs</code>使用中也是各种不爽，在<code>html</code>中加上各种<code>&lt;%%&gt;</code>真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（<code>reactjs</code>的<code>jsx语法</code>在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的<code>jquery</code>，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了</p>\n<p>因此我开始研究在<code>ejs</code>中加入jq的功能，<code>cheerio</code>模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——</p>\n<p>去翻了一下<code>ejs</code>的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;&#123;&#123; 1+1 &#125;&#125;&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></p>\n<p>所对应的中间函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> out = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  out += <span class=\"string\">&#x27;&lt;h1&gt;&#x27;</span>;</span><br><span class=\"line\">  out += <span class=\"built_in\">escape</span>(<span class=\"number\">1</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">  out += <span class=\"string\">&#x27;&lt;/h1&gt;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(out);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。</p>\n<p>可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;&#39; + escape(1 + 1) + &#39;&lt;&#x2F;h1&gt;&#39;</span><br></pre></td></tr></table></figure>\n<p>这种格式呢？因为需要支持各种看起来高大上的模板语法，如<code>if</code>、<code>each</code>之类的。</p>\n<hr>\n<p>好像有点跑题，刚才的问题是，我如何将<code>cheerio</code>模块加入到<code>ejs</code>中呢？</p>\n<p>我们都知道，<code>ejs</code>中如果要将某些变量的值带到模板中渲染，需要在render时传递<code>locals</code>对象，在这个对象里存储所有渲染需要的变量。</p>\n<p>但实际上在使用模板引擎时，我们并不会使用名叫<code>locals</code>或者其他类似<code>data</code>之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">locals</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">with</span>(<span class=\"params\">locals</span>)</span>&#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>模板引擎将传入的<code>locals</code>对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传<code>locals</code>对象的时候丢进去：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cheerio&#x27;</span>);</span><br><span class=\"line\">res.render(<span class=\"string\">&#x27;index&#x27;</span>,&#123; <span class=\"attr\">$</span>:cheerio &#125; );</span><br></pre></td></tr></table></figure></p>\n<p>这样子就能实现在<code>ejs</code>里实现类似这样的jq语法了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"function\"><span class=\"title\">for</span>(<span class=\"params\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++</span>)</span> &#123;%&gt;</span><br><span class=\"line\">    &lt;%- $(<span class=\"string\">&#x27;&lt;a&gt;&#x27;</span>).text(i.toString()).attr(<span class=\"string\">&#x27;href&#x27;</span>,<span class=\"string\">&#x27;#&#x27;</span>) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>只是一名本分的后端<code>nodejs</code>程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（<code>angular</code>、<code>reactjs</code>、<code>vue</code>、<code>meteor</code>以及各种其他）之后，我最终还是决定使用<code>express</code>自带的<code>ejs</code></p>\n<p>即使是各大主流框架，在很大程度上还是离不开<code>jquery</code>，我当然也是如此，使用<code>ejs</code>仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。</p>\n<p>然而<code>ejs</code>使用中也是各种不爽，在<code>html</code>中加上各种<code>&lt;%%&gt;</code>真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（<code>reactjs</code>的<code>jsx语法</code>在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的<code>jquery</code>，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了</p>\n<p>因此我开始研究在<code>ejs</code>中加入jq的功能，<code>cheerio</code>模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——</p>\n<p>去翻了一下<code>ejs</code>的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;&#123;&#123; 1+1 &#125;&#125;&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></p>\n<p>所对应的中间函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> out = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  out += <span class=\"string\">&#x27;&lt;h1&gt;&#x27;</span>;</span><br><span class=\"line\">  out += <span class=\"built_in\">escape</span>(<span class=\"number\">1</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">  out += <span class=\"string\">&#x27;&lt;/h1&gt;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(out);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。</p>\n<p>可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;&#39; + escape(1 + 1) + &#39;&lt;&#x2F;h1&gt;&#39;</span><br></pre></td></tr></table></figure>\n<p>这种格式呢？因为需要支持各种看起来高大上的模板语法，如<code>if</code>、<code>each</code>之类的。</p>\n<hr>\n<p>好像有点跑题，刚才的问题是，我如何将<code>cheerio</code>模块加入到<code>ejs</code>中呢？</p>\n<p>我们都知道，<code>ejs</code>中如果要将某些变量的值带到模板中渲染，需要在render时传递<code>locals</code>对象，在这个对象里存储所有渲染需要的变量。</p>\n<p>但实际上在使用模板引擎时，我们并不会使用名叫<code>locals</code>或者其他类似<code>data</code>之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">locals</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">with</span>(<span class=\"params\">locals</span>)</span>&#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>模板引擎将传入的<code>locals</code>对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传<code>locals</code>对象的时候丢进去：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cheerio&#x27;</span>);</span><br><span class=\"line\">res.render(<span class=\"string\">&#x27;index&#x27;</span>,&#123; <span class=\"attr\">$</span>:cheerio &#125; );</span><br></pre></td></tr></table></figure></p>\n<p>这样子就能实现在<code>ejs</code>里实现类似这样的jq语法了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"function\"><span class=\"title\">for</span>(<span class=\"params\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++</span>)</span> &#123;%&gt;</span><br><span class=\"line\">    &lt;%- $(<span class=\"string\">&#x27;&lt;a&gt;&#x27;</span>).text(i.toString()).attr(<span class=\"string\">&#x27;href&#x27;</span>,<span class=\"string\">&#x27;#&#x27;</span>) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"mingw32缺少posix_memalign函数","desc":"瞎玩","date":"2015-11-30T02:40:47.000Z","author":"ngtmuzi","_content":"\n想在`windows`上研究`word2vec`，于是查了一下如何`make`之类的东西，装好`mingw32`之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数`_aligned_malloc`，但是参数格式不一样，那还是自己动手吧：\n```c\nfunction posix_memalign( void ** memptr, size_t alignment, size_t size){\n  (* memptr) = _aligned_malloc(size, alignment);\n}\n```\n\n这样就可以编译通过了","source":"_posts/mingw32缺少posix_memalign函数.md","raw":"---\ntitle: mingw32缺少posix_memalign函数    \ndesc: 瞎玩 \ndate: 2015-11-30 10:40:47.000\ntags: C++\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n想在`windows`上研究`word2vec`，于是查了一下如何`make`之类的东西，装好`mingw32`之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数`_aligned_malloc`，但是参数格式不一样，那还是自己动手吧：\n```c\nfunction posix_memalign( void ** memptr, size_t alignment, size_t size){\n  (* memptr) = _aligned_malloc(size, alignment);\n}\n```\n\n这样就可以编译通过了","slug":"mingw32缺少posix_memalign函数","published":1,"updated":"2020-06-17T10:26:40.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbl000gsou5hu9e09x4","content":"<p>想在<code>windows</code>上研究<code>word2vec</code>，于是查了一下如何<code>make</code>之类的东西，装好<code>mingw32</code>之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数<code>_aligned_malloc</code>，但是参数格式不一样，那还是自己动手吧：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">posix_memalign</span><span class=\"params\">( <span class=\"keyword\">void</span> ** memptr, <span class=\"keyword\">size_t</span> alignment, <span class=\"keyword\">size_t</span> size)</span></span>&#123;</span><br><span class=\"line\">  (* memptr) = _aligned_malloc(size, alignment);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以编译通过了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>想在<code>windows</code>上研究<code>word2vec</code>，于是查了一下如何<code>make</code>之类的东西，装好<code>mingw32</code>之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数<code>_aligned_malloc</code>，但是参数格式不一样，那还是自己动手吧：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">posix_memalign</span><span class=\"params\">( <span class=\"keyword\">void</span> ** memptr, <span class=\"keyword\">size_t</span> alignment, <span class=\"keyword\">size_t</span> size)</span></span>&#123;</span><br><span class=\"line\">  (* memptr) = _aligned_malloc(size, alignment);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以编译通过了</p>\n"},{"title":"mysql插入uuid主键时引起的死锁问题","desc":"mysql是真的很严格","date":"2018-11-06T12:45:00.000Z","author":"ngtmuzi","_content":"很早之前稍微研究的结果\n\n## 问题描述\n\n当表为空的时候，并发多个事务，先使用`for update`来检查uuid是否存在，再insert记录，此时会引起多次死锁问题\n\n## 问题分析\n用 `SHOW ENGINE INNODB STATUS;` 语句查看了最后一次死锁的记录后，找到这样一个解释：     \n[Solution for Insert Intention Locks in MySQL - stackoverflow\n](https://stackoverflow.com/questions/44949940/solution-for-insert-intention-locks-in-mysql)  \n结合之前在各个国产博客上看到的知识点，大概总结起来就是：\n* 加锁时是在索引上加锁，这里搜索条件是主键uuid，使用的是主键索引\n* 当锁定的值大于当前表内已存在的最大值时，实际上锁定的是这个最大值到无穷大的“间隙”\n* 当同时有多个事务锁定这个间隙并尝试写入时，就会产生死锁\n* 该问题容易出现在空表，毕竟表的数据越多，间隙也就越多，就越难同时锁定到同一间隙\n\n## 解决方式\n\n在处理事务的时候死锁还挺常见的，所以代码是必须要做兼容使其稍后重试的，也可以提高事务的隔离级别来解决，不过因为MongoDB4.0开始支持事务的原因，我转去用Mongo了~","source":"_posts/mysql插入uuid主键时引起的死锁问题.md","raw":"---\ntitle: mysql插入uuid主键时引起的死锁问题  \ndesc: mysql是真的很严格\ndate: 2018-11-06 20:45:00\ntags: \n- mysql\nauthor: ngtmuzi  \ncategory: 亡羊补牢\n---\n很早之前稍微研究的结果\n\n## 问题描述\n\n当表为空的时候，并发多个事务，先使用`for update`来检查uuid是否存在，再insert记录，此时会引起多次死锁问题\n\n## 问题分析\n用 `SHOW ENGINE INNODB STATUS;` 语句查看了最后一次死锁的记录后，找到这样一个解释：     \n[Solution for Insert Intention Locks in MySQL - stackoverflow\n](https://stackoverflow.com/questions/44949940/solution-for-insert-intention-locks-in-mysql)  \n结合之前在各个国产博客上看到的知识点，大概总结起来就是：\n* 加锁时是在索引上加锁，这里搜索条件是主键uuid，使用的是主键索引\n* 当锁定的值大于当前表内已存在的最大值时，实际上锁定的是这个最大值到无穷大的“间隙”\n* 当同时有多个事务锁定这个间隙并尝试写入时，就会产生死锁\n* 该问题容易出现在空表，毕竟表的数据越多，间隙也就越多，就越难同时锁定到同一间隙\n\n## 解决方式\n\n在处理事务的时候死锁还挺常见的，所以代码是必须要做兼容使其稍后重试的，也可以提高事务的隔离级别来解决，不过因为MongoDB4.0开始支持事务的原因，我转去用Mongo了~","slug":"mysql插入uuid主键时引起的死锁问题","published":1,"updated":"2020-06-17T10:26:40.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbm000hsou5g24n4ldx","content":"<p>很早之前稍微研究的结果</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>当表为空的时候，并发多个事务，先使用<code>for update</code>来检查uuid是否存在，再insert记录，此时会引起多次死锁问题</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>用 <code>SHOW ENGINE INNODB STATUS;</code> 语句查看了最后一次死锁的记录后，找到这样一个解释：<br><a href=\"https://stackoverflow.com/questions/44949940/solution-for-insert-intention-locks-in-mysql\">Solution for Insert Intention Locks in MySQL - stackoverflow\n</a><br>结合之前在各个国产博客上看到的知识点，大概总结起来就是：</p>\n<ul>\n<li>加锁时是在索引上加锁，这里搜索条件是主键uuid，使用的是主键索引</li>\n<li>当锁定的值大于当前表内已存在的最大值时，实际上锁定的是这个最大值到无穷大的“间隙”</li>\n<li>当同时有多个事务锁定这个间隙并尝试写入时，就会产生死锁</li>\n<li>该问题容易出现在空表，毕竟表的数据越多，间隙也就越多，就越难同时锁定到同一间隙</li>\n</ul>\n<h2 id=\"解决方式\"><a href=\"#解决方式\" class=\"headerlink\" title=\"解决方式\"></a>解决方式</h2><p>在处理事务的时候死锁还挺常见的，所以代码是必须要做兼容使其稍后重试的，也可以提高事务的隔离级别来解决，不过因为MongoDB4.0开始支持事务的原因，我转去用Mongo了~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很早之前稍微研究的结果</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>当表为空的时候，并发多个事务，先使用<code>for update</code>来检查uuid是否存在，再insert记录，此时会引起多次死锁问题</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>用 <code>SHOW ENGINE INNODB STATUS;</code> 语句查看了最后一次死锁的记录后，找到这样一个解释：<br><a href=\"https://stackoverflow.com/questions/44949940/solution-for-insert-intention-locks-in-mysql\">Solution for Insert Intention Locks in MySQL - stackoverflow\n</a><br>结合之前在各个国产博客上看到的知识点，大概总结起来就是：</p>\n<ul>\n<li>加锁时是在索引上加锁，这里搜索条件是主键uuid，使用的是主键索引</li>\n<li>当锁定的值大于当前表内已存在的最大值时，实际上锁定的是这个最大值到无穷大的“间隙”</li>\n<li>当同时有多个事务锁定这个间隙并尝试写入时，就会产生死锁</li>\n<li>该问题容易出现在空表，毕竟表的数据越多，间隙也就越多，就越难同时锁定到同一间隙</li>\n</ul>\n<h2 id=\"解决方式\"><a href=\"#解决方式\" class=\"headerlink\" title=\"解决方式\"></a>解决方式</h2><p>在处理事务的时候死锁还挺常见的，所以代码是必须要做兼容使其稍后重试的，也可以提高事务的隔离级别来解决，不过因为MongoDB4.0开始支持事务的原因，我转去用Mongo了~</p>\n"},{"title":"promise的日常应用","desc":"promise在异步处理上真是比原始的回调好了太多，promise大法好~","date":"2015-12-30T12:46:04.470Z","author":"ngtmuzi","_content":"\n`promise`在异步处理上真是比原始的回调好了太多，`promise`大法好~\n\n\n下面是一些日常工作中总结的各种神秘技巧：（使用`bluebird`模块）\n\n* 一般来说都是在`request`请求或数据库操作之后开始使用`promise`，当然要直接`Promise.resolve()`也是可以的\n\n* `mongodb`模块原生返回`promise`对象，真是方便不少，不过它用的是`Q`模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换`promise`库：\n```javascript\nMongoClient.connect(mongoUrl, {promiseLibrary: Promise})\n```\n* `mysql`方面好像除了`sequelize`外没什么比较好的`promise`的模块……因为目前的工作内容都是在`mongodb`上，对这方面也没做太多了解\n\n* `redis`模块中`ioredis`据说不错，不过也没太多接触\n\n* 至于网络请求，自然是`request`的`promise`版：`request`-`promise`\n\n---\n\n\n当以上模块返回了promise对象，就可以用then一路走到黑啦\n\n\n一般来说我的express路由处理函数都会以这样结尾：\n```javascript\nfunction getArticle(req, res, next) {\n  mongo.article.find(req.query).sort({postTime:-1}).toArray()\n    .then(res.ok, next);\n}\n```\n\n`res.ok`是自己为了方便而挂上的一个函数，一般类似于  \n\n```javascript\n  res.ok  = res.json.bind(res);\n```\n\n\n`next`函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。\n\n\n后来想想，用`next`函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：\n\n```javascript\nres.ok = function (data) {\n  res.send(200,data);\n};\nres.err = _.curry(function (code, err, ext) {\n  res.status(code || 500);\n  res.json({msg: err && err.message || err, ext: ext && ext.message || ext});\n});\n```\n\n使用了`lodash`模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术\n\n```javascript\nsms.csGetStatusReportExEx()\n  .then(res.ok, res.err(502, '状态报告获取失败'));\n```\n\n真正的错误信息会被带在`ext`里字段返回，另外`res.ok`也改成调用适用性更好的`res.send`函数\n（注意这里有个坑，`res.send`一个数字的话它会以为你只返回一个http状态码，因此虽然`res.send(200,data)`这种格式已被弃用，但是在目前还是必须这么处理才行）","source":"_posts/promise的日常应用.md","raw":"---\ntitle: promise的日常应用    \ndesc: promise在异步处理上真是比原始的回调好了太多，promise大法好~  \ndate: 2015-12-30 20:46:04.470\ntags: \n- nodejs\n- javascript\n- promise\n- express  \nauthor: ngtmuzi  \ncategory: 班门弄斧  \n---\n\n`promise`在异步处理上真是比原始的回调好了太多，`promise`大法好~\n\n\n下面是一些日常工作中总结的各种神秘技巧：（使用`bluebird`模块）\n\n* 一般来说都是在`request`请求或数据库操作之后开始使用`promise`，当然要直接`Promise.resolve()`也是可以的\n\n* `mongodb`模块原生返回`promise`对象，真是方便不少，不过它用的是`Q`模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换`promise`库：\n```javascript\nMongoClient.connect(mongoUrl, {promiseLibrary: Promise})\n```\n* `mysql`方面好像除了`sequelize`外没什么比较好的`promise`的模块……因为目前的工作内容都是在`mongodb`上，对这方面也没做太多了解\n\n* `redis`模块中`ioredis`据说不错，不过也没太多接触\n\n* 至于网络请求，自然是`request`的`promise`版：`request`-`promise`\n\n---\n\n\n当以上模块返回了promise对象，就可以用then一路走到黑啦\n\n\n一般来说我的express路由处理函数都会以这样结尾：\n```javascript\nfunction getArticle(req, res, next) {\n  mongo.article.find(req.query).sort({postTime:-1}).toArray()\n    .then(res.ok, next);\n}\n```\n\n`res.ok`是自己为了方便而挂上的一个函数，一般类似于  \n\n```javascript\n  res.ok  = res.json.bind(res);\n```\n\n\n`next`函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。\n\n\n后来想想，用`next`函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：\n\n```javascript\nres.ok = function (data) {\n  res.send(200,data);\n};\nres.err = _.curry(function (code, err, ext) {\n  res.status(code || 500);\n  res.json({msg: err && err.message || err, ext: ext && ext.message || ext});\n});\n```\n\n使用了`lodash`模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术\n\n```javascript\nsms.csGetStatusReportExEx()\n  .then(res.ok, res.err(502, '状态报告获取失败'));\n```\n\n真正的错误信息会被带在`ext`里字段返回，另外`res.ok`也改成调用适用性更好的`res.send`函数\n（注意这里有个坑，`res.send`一个数字的话它会以为你只返回一个http状态码，因此虽然`res.send(200,data)`这种格式已被弃用，但是在目前还是必须这么处理才行）","slug":"promise的日常应用","published":1,"updated":"2020-06-17T10:26:40.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbm000isou5fawvcns6","content":"<p><code>promise</code>在异步处理上真是比原始的回调好了太多，<code>promise</code>大法好~</p>\n<p>下面是一些日常工作中总结的各种神秘技巧：（使用<code>bluebird</code>模块）</p>\n<ul>\n<li><p>一般来说都是在<code>request</code>请求或数据库操作之后开始使用<code>promise</code>，当然要直接<code>Promise.resolve()</code>也是可以的</p>\n</li>\n<li><p><code>mongodb</code>模块原生返回<code>promise</code>对象，真是方便不少，不过它用的是<code>Q</code>模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换<code>promise</code>库：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoClient.connect(mongoUrl, &#123;<span class=\"attr\">promiseLibrary</span>: <span class=\"built_in\">Promise</span>&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>mysql</code>方面好像除了<code>sequelize</code>外没什么比较好的<code>promise</code>的模块……因为目前的工作内容都是在<code>mongodb</code>上，对这方面也没做太多了解</p>\n</li>\n<li><p><code>redis</code>模块中<code>ioredis</code>据说不错，不过也没太多接触</p>\n</li>\n<li><p>至于网络请求，自然是<code>request</code>的<code>promise</code>版：<code>request</code>-<code>promise</code></p>\n</li>\n</ul>\n<hr>\n<p>当以上模块返回了promise对象，就可以用then一路走到黑啦</p>\n<p>一般来说我的express路由处理函数都会以这样结尾：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArticle</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  mongo.article.find(req.query).sort(&#123;<span class=\"attr\">postTime</span>:-<span class=\"number\">1</span>&#125;).toArray()</span><br><span class=\"line\">    .then(res.ok, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>res.ok</code>是自己为了方便而挂上的一个函数，一般类似于  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.ok  = res.json.bind(res);</span><br></pre></td></tr></table></figure>\n<p><code>next</code>函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。</p>\n<p>后来想想，用<code>next</code>函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.ok = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"number\">200</span>,data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">res.err = _.curry(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, err, ext</span>) </span>&#123;</span><br><span class=\"line\">  res.status(code || <span class=\"number\">500</span>);</span><br><span class=\"line\">  res.json(&#123;<span class=\"attr\">msg</span>: err &amp;&amp; err.message || err, <span class=\"attr\">ext</span>: ext &amp;&amp; ext.message || ext&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用了<code>lodash</code>模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sms.csGetStatusReportExEx()</span><br><span class=\"line\">  .then(res.ok, res.err(<span class=\"number\">502</span>, <span class=\"string\">&#x27;状态报告获取失败&#x27;</span>));</span><br></pre></td></tr></table></figure>\n<p>真正的错误信息会被带在<code>ext</code>里字段返回，另外<code>res.ok</code>也改成调用适用性更好的<code>res.send</code>函数<br>（注意这里有个坑，<code>res.send</code>一个数字的话它会以为你只返回一个http状态码，因此虽然<code>res.send(200,data)</code>这种格式已被弃用，但是在目前还是必须这么处理才行）</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>promise</code>在异步处理上真是比原始的回调好了太多，<code>promise</code>大法好~</p>\n<p>下面是一些日常工作中总结的各种神秘技巧：（使用<code>bluebird</code>模块）</p>\n<ul>\n<li><p>一般来说都是在<code>request</code>请求或数据库操作之后开始使用<code>promise</code>，当然要直接<code>Promise.resolve()</code>也是可以的</p>\n</li>\n<li><p><code>mongodb</code>模块原生返回<code>promise</code>对象，真是方便不少，不过它用的是<code>Q</code>模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换<code>promise</code>库：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoClient.connect(mongoUrl, &#123;<span class=\"attr\">promiseLibrary</span>: <span class=\"built_in\">Promise</span>&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>mysql</code>方面好像除了<code>sequelize</code>外没什么比较好的<code>promise</code>的模块……因为目前的工作内容都是在<code>mongodb</code>上，对这方面也没做太多了解</p>\n</li>\n<li><p><code>redis</code>模块中<code>ioredis</code>据说不错，不过也没太多接触</p>\n</li>\n<li><p>至于网络请求，自然是<code>request</code>的<code>promise</code>版：<code>request</code>-<code>promise</code></p>\n</li>\n</ul>\n<hr>\n<p>当以上模块返回了promise对象，就可以用then一路走到黑啦</p>\n<p>一般来说我的express路由处理函数都会以这样结尾：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArticle</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  mongo.article.find(req.query).sort(&#123;<span class=\"attr\">postTime</span>:-<span class=\"number\">1</span>&#125;).toArray()</span><br><span class=\"line\">    .then(res.ok, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>res.ok</code>是自己为了方便而挂上的一个函数，一般类似于  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.ok  = res.json.bind(res);</span><br></pre></td></tr></table></figure>\n<p><code>next</code>函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。</p>\n<p>后来想想，用<code>next</code>函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.ok = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"number\">200</span>,data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">res.err = _.curry(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, err, ext</span>) </span>&#123;</span><br><span class=\"line\">  res.status(code || <span class=\"number\">500</span>);</span><br><span class=\"line\">  res.json(&#123;<span class=\"attr\">msg</span>: err &amp;&amp; err.message || err, <span class=\"attr\">ext</span>: ext &amp;&amp; ext.message || ext&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用了<code>lodash</code>模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sms.csGetStatusReportExEx()</span><br><span class=\"line\">  .then(res.ok, res.err(<span class=\"number\">502</span>, <span class=\"string\">&#x27;状态报告获取失败&#x27;</span>));</span><br></pre></td></tr></table></figure>\n<p>真正的错误信息会被带在<code>ext</code>里字段返回，另外<code>res.ok</code>也改成调用适用性更好的<code>res.send</code>函数<br>（注意这里有个坑，<code>res.send</code>一个数字的话它会以为你只返回一个http状态码，因此虽然<code>res.send(200,data)</code>这种格式已被弃用，但是在目前还是必须这么处理才行）</p>\n"},{"title":"《凤凰项目》读书笔记","desc":"好久没有读完过一本书了","author":"ngtmuzi","date":"2019-09-10T12:00:00.000Z","_content":"\n部门老大推荐的一本书，全名《凤凰项目：一个IT运维的传奇故事》，一开始没注意看到副标题，光看主标题还以为是简单介绍如何做好项目管理和人员开发的书，类似《人月神话》。然而看了之后才发现是小说形式的，讲述一个新上任的IT运维部主管如何整理自己部门的烂摊子，并与开发、QA、内审、财务、运营...各个部门间有效合作最终挽救了一个失败项目的故事。\n\n## 背景\n\n故事并非发生在一个互联网公司，而是美国的一个传统的汽车制造业公司——“无极限公司”。开发和IT运维并非是该公司的核心部门，甚至由于他们历史上的效率低下和问题频出，公司已经开始考虑寻求外包解决方案，主角们面临被解雇的危机；而公司本身也处于风雨飘摇之中，友商新上线的产品推荐和个性化系统吸引了大量的客户，使得股市和董事会对公司多有微言，迫于压力无极限公司也开始研发类似的系统期望挽回客户，该项目称为“凤凰”。\n\n## 主要内容\n\n这本书并非只是单纯说如何完成“凤凰”这个项目的，主角是IT运维部门的主管，视角与我们一般的开发者不相同，全书并没有着眼与介绍一个软件项目是如何策划、开发、完成测试并上线的，而是从整个“传统制造业公司”的层面去审视运维工作流程、任务管理、各部门间的合作，并提出作者的一些观点。\n\n### 人和工作的管理\n\n主角一上任就碰到了多次的系统故障，公司的工资发放、信用卡支付等重要功能受到影响，经过一系列流程梳理后，最终问题的焦点都在一个名为布伦特的人身上。他就是这个IT运维部的最核心员工，对业务流程的深入程度使得其他人甚至都帮不上忙，但也正因如此，很多变更操作他都没有经过审批而是自己直接操作，也因此产生了很多不可预估的系统故障。最后的结果是所有的重要流程都要由他操作，出现的各种故障也要找他来排查解决，他变成了整个部门最忙又最不可取代的一环。\n\n主角团们发现了问题后，对其工作做出了分解，所有的服务器变更都必须拦下来，确认影响范围和优先级，并统一审核和安排时间实施，可以交由他人处理的工作就交由他人，他人尚不清楚的工作则由布伦特整理出工作流程。\n\n*这个情况在我们实际的工作中也是经常遇到的，总有一个人掌握了很多你不知道的黑科技，各种操作都需要他来帮忙，但他出问题时所有人只能看着他着急。这不是一个正常的工作情况，在严格的项目管控中，没有人具有不可替代性，需要把脑中的经验梳理并文档化，才能让他人参与进来；其次就是变更工作的管控，所有的变更能明确影响范围和审核必要性，对于稳定的线上环境是很重要的。*\n\n#### IT的四类工作\n\n1. 业务项目，如故事中的“凤凰”项目\n2. IT内部项目，如各类发布、部署自动化系统\n3. 服务器变更，如常规的服务器迁移、数据库迁移等\n4. 计划外工作或救火工作\n\n短暂的“走捷径”或者绕过正规流程的操作会导致技术债务，技术债务的积累终将导致产生大量的计划外工作，最终使得处理人员再没有时间处理前3类计划内工作。因此我们需要及时地对流程进行规范和限制。\n\n### 用工厂流水线的眼光来看待软件开发\n\n书中的“贵人”埃瑞克一直在强调一点，就是IT开发运维流程的本质与工厂的流水线相同，开发、QA测试、运维发布等都是其中的数个环节，需要明确是哪个结点产生了工作的积压。但本书并不会告诉你如何“加大节点生产力”，毕竟人不是机器，堆量不一定能提高效率，这点在《人月神话》中会说得更清楚，本书提出的是如何在生产力有限的情况下，合理地安排工作流：\n\n#### 三步工作法\n\n1. 第一工作法是关于从开发到IT运维再到客户的整个自左向右的工作流。为了使流量最大化，我们需要小的批量规模和工作间隔\n2. 第二工作法是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保问题再次发生，或者更快地发现和修复问题，从源头上保证质量\n3. 第三工作法是关于创造公司文化：鼓励探索、在失败中吸取教训；让员工理解重复的演练是重要的经验积累\n\n### 敏捷开发和可持续交付\n\n书中有这样一段\n> 在竞争的时代，游戏规则就是“快速上市，快速淘汰”。我们不能为推出一个产品而制定为期几年的工作计划，一直等到最后才弄清手上拿的牌是赢家还是输家。我们需要短而快的周期，不断整合来自市场的反馈。\n> 产品开发周期越长，公司资本锁定的时间也就越长，资金锁定期间是没有回报的。一旦研发资本以半成品的形式锁定超过一年而未向公司返还现金，它就几乎不可能再为公司产生回报了。\n\n书中很明确地提到的了一个开发周期为3年的项目对于公司来说相当于沉没成本，它持续耗费成本却不能产生任何价值，即使最后上线也有可能远远落后于竞品，这对于一家运营状况不好的公司来说是足以致命的，而敏捷开发不断给出可落地的成果，给予公司和市场信心，效果是会更好的。\n\n### IT部门的定位\n\n由于书中的公司并非一个互联网公司，软件开发、QA、运维等部门并非是营利的核心，很多时候运营、财务部门会认为IT部门是累赘，效率低且不能完成运营需求，但他们没考虑过IT部门的产出本身就是一个业务指标，IT部门运转情况也与公司的命脉息息相关。由IT引起的运营风险不只是IT风险，同样也是业务风险，需要将这些风险管控纳入业绩指标。\n\n## 总结\n\n在读这本书前我也未曾考虑过高层次的问题，这本书能提供一定的眼界，纵观全局才能明晰问题所在，对于工作流程的一些观点也值得学习。\n","source":"_posts/《凤凰项目》读书笔记.md","raw":"---\ntitle: 《凤凰项目》读书笔记\ndesc: 好久没有读完过一本书了\nauthor: ngtmuzi\ncategory: 随笔\ndate: 2019-09-10 20:00:00\ntags: 总结\n---\n\n部门老大推荐的一本书，全名《凤凰项目：一个IT运维的传奇故事》，一开始没注意看到副标题，光看主标题还以为是简单介绍如何做好项目管理和人员开发的书，类似《人月神话》。然而看了之后才发现是小说形式的，讲述一个新上任的IT运维部主管如何整理自己部门的烂摊子，并与开发、QA、内审、财务、运营...各个部门间有效合作最终挽救了一个失败项目的故事。\n\n## 背景\n\n故事并非发生在一个互联网公司，而是美国的一个传统的汽车制造业公司——“无极限公司”。开发和IT运维并非是该公司的核心部门，甚至由于他们历史上的效率低下和问题频出，公司已经开始考虑寻求外包解决方案，主角们面临被解雇的危机；而公司本身也处于风雨飘摇之中，友商新上线的产品推荐和个性化系统吸引了大量的客户，使得股市和董事会对公司多有微言，迫于压力无极限公司也开始研发类似的系统期望挽回客户，该项目称为“凤凰”。\n\n## 主要内容\n\n这本书并非只是单纯说如何完成“凤凰”这个项目的，主角是IT运维部门的主管，视角与我们一般的开发者不相同，全书并没有着眼与介绍一个软件项目是如何策划、开发、完成测试并上线的，而是从整个“传统制造业公司”的层面去审视运维工作流程、任务管理、各部门间的合作，并提出作者的一些观点。\n\n### 人和工作的管理\n\n主角一上任就碰到了多次的系统故障，公司的工资发放、信用卡支付等重要功能受到影响，经过一系列流程梳理后，最终问题的焦点都在一个名为布伦特的人身上。他就是这个IT运维部的最核心员工，对业务流程的深入程度使得其他人甚至都帮不上忙，但也正因如此，很多变更操作他都没有经过审批而是自己直接操作，也因此产生了很多不可预估的系统故障。最后的结果是所有的重要流程都要由他操作，出现的各种故障也要找他来排查解决，他变成了整个部门最忙又最不可取代的一环。\n\n主角团们发现了问题后，对其工作做出了分解，所有的服务器变更都必须拦下来，确认影响范围和优先级，并统一审核和安排时间实施，可以交由他人处理的工作就交由他人，他人尚不清楚的工作则由布伦特整理出工作流程。\n\n*这个情况在我们实际的工作中也是经常遇到的，总有一个人掌握了很多你不知道的黑科技，各种操作都需要他来帮忙，但他出问题时所有人只能看着他着急。这不是一个正常的工作情况，在严格的项目管控中，没有人具有不可替代性，需要把脑中的经验梳理并文档化，才能让他人参与进来；其次就是变更工作的管控，所有的变更能明确影响范围和审核必要性，对于稳定的线上环境是很重要的。*\n\n#### IT的四类工作\n\n1. 业务项目，如故事中的“凤凰”项目\n2. IT内部项目，如各类发布、部署自动化系统\n3. 服务器变更，如常规的服务器迁移、数据库迁移等\n4. 计划外工作或救火工作\n\n短暂的“走捷径”或者绕过正规流程的操作会导致技术债务，技术债务的积累终将导致产生大量的计划外工作，最终使得处理人员再没有时间处理前3类计划内工作。因此我们需要及时地对流程进行规范和限制。\n\n### 用工厂流水线的眼光来看待软件开发\n\n书中的“贵人”埃瑞克一直在强调一点，就是IT开发运维流程的本质与工厂的流水线相同，开发、QA测试、运维发布等都是其中的数个环节，需要明确是哪个结点产生了工作的积压。但本书并不会告诉你如何“加大节点生产力”，毕竟人不是机器，堆量不一定能提高效率，这点在《人月神话》中会说得更清楚，本书提出的是如何在生产力有限的情况下，合理地安排工作流：\n\n#### 三步工作法\n\n1. 第一工作法是关于从开发到IT运维再到客户的整个自左向右的工作流。为了使流量最大化，我们需要小的批量规模和工作间隔\n2. 第二工作法是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保问题再次发生，或者更快地发现和修复问题，从源头上保证质量\n3. 第三工作法是关于创造公司文化：鼓励探索、在失败中吸取教训；让员工理解重复的演练是重要的经验积累\n\n### 敏捷开发和可持续交付\n\n书中有这样一段\n> 在竞争的时代，游戏规则就是“快速上市，快速淘汰”。我们不能为推出一个产品而制定为期几年的工作计划，一直等到最后才弄清手上拿的牌是赢家还是输家。我们需要短而快的周期，不断整合来自市场的反馈。\n> 产品开发周期越长，公司资本锁定的时间也就越长，资金锁定期间是没有回报的。一旦研发资本以半成品的形式锁定超过一年而未向公司返还现金，它就几乎不可能再为公司产生回报了。\n\n书中很明确地提到的了一个开发周期为3年的项目对于公司来说相当于沉没成本，它持续耗费成本却不能产生任何价值，即使最后上线也有可能远远落后于竞品，这对于一家运营状况不好的公司来说是足以致命的，而敏捷开发不断给出可落地的成果，给予公司和市场信心，效果是会更好的。\n\n### IT部门的定位\n\n由于书中的公司并非一个互联网公司，软件开发、QA、运维等部门并非是营利的核心，很多时候运营、财务部门会认为IT部门是累赘，效率低且不能完成运营需求，但他们没考虑过IT部门的产出本身就是一个业务指标，IT部门运转情况也与公司的命脉息息相关。由IT引起的运营风险不只是IT风险，同样也是业务风险，需要将这些风险管控纳入业绩指标。\n\n## 总结\n\n在读这本书前我也未曾考虑过高层次的问题，这本书能提供一定的眼界，纵观全局才能明晰问题所在，对于工作流程的一些观点也值得学习。\n","slug":"《凤凰项目》读书笔记","published":1,"updated":"2020-08-07T06:18:46.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbn000jsou552gbajxe","content":"<p>部门老大推荐的一本书，全名《凤凰项目：一个IT运维的传奇故事》，一开始没注意看到副标题，光看主标题还以为是简单介绍如何做好项目管理和人员开发的书，类似《人月神话》。然而看了之后才发现是小说形式的，讲述一个新上任的IT运维部主管如何整理自己部门的烂摊子，并与开发、QA、内审、财务、运营…各个部门间有效合作最终挽救了一个失败项目的故事。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>故事并非发生在一个互联网公司，而是美国的一个传统的汽车制造业公司——“无极限公司”。开发和IT运维并非是该公司的核心部门，甚至由于他们历史上的效率低下和问题频出，公司已经开始考虑寻求外包解决方案，主角们面临被解雇的危机；而公司本身也处于风雨飘摇之中，友商新上线的产品推荐和个性化系统吸引了大量的客户，使得股市和董事会对公司多有微言，迫于压力无极限公司也开始研发类似的系统期望挽回客户，该项目称为“凤凰”。</p>\n<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><p>这本书并非只是单纯说如何完成“凤凰”这个项目的，主角是IT运维部门的主管，视角与我们一般的开发者不相同，全书并没有着眼与介绍一个软件项目是如何策划、开发、完成测试并上线的，而是从整个“传统制造业公司”的层面去审视运维工作流程、任务管理、各部门间的合作，并提出作者的一些观点。</p>\n<h3 id=\"人和工作的管理\"><a href=\"#人和工作的管理\" class=\"headerlink\" title=\"人和工作的管理\"></a>人和工作的管理</h3><p>主角一上任就碰到了多次的系统故障，公司的工资发放、信用卡支付等重要功能受到影响，经过一系列流程梳理后，最终问题的焦点都在一个名为布伦特的人身上。他就是这个IT运维部的最核心员工，对业务流程的深入程度使得其他人甚至都帮不上忙，但也正因如此，很多变更操作他都没有经过审批而是自己直接操作，也因此产生了很多不可预估的系统故障。最后的结果是所有的重要流程都要由他操作，出现的各种故障也要找他来排查解决，他变成了整个部门最忙又最不可取代的一环。</p>\n<p>主角团们发现了问题后，对其工作做出了分解，所有的服务器变更都必须拦下来，确认影响范围和优先级，并统一审核和安排时间实施，可以交由他人处理的工作就交由他人，他人尚不清楚的工作则由布伦特整理出工作流程。</p>\n<p><em>这个情况在我们实际的工作中也是经常遇到的，总有一个人掌握了很多你不知道的黑科技，各种操作都需要他来帮忙，但他出问题时所有人只能看着他着急。这不是一个正常的工作情况，在严格的项目管控中，没有人具有不可替代性，需要把脑中的经验梳理并文档化，才能让他人参与进来；其次就是变更工作的管控，所有的变更能明确影响范围和审核必要性，对于稳定的线上环境是很重要的。</em></p>\n<h4 id=\"IT的四类工作\"><a href=\"#IT的四类工作\" class=\"headerlink\" title=\"IT的四类工作\"></a>IT的四类工作</h4><ol>\n<li>业务项目，如故事中的“凤凰”项目</li>\n<li>IT内部项目，如各类发布、部署自动化系统</li>\n<li>服务器变更，如常规的服务器迁移、数据库迁移等</li>\n<li>计划外工作或救火工作</li>\n</ol>\n<p>短暂的“走捷径”或者绕过正规流程的操作会导致技术债务，技术债务的积累终将导致产生大量的计划外工作，最终使得处理人员再没有时间处理前3类计划内工作。因此我们需要及时地对流程进行规范和限制。</p>\n<h3 id=\"用工厂流水线的眼光来看待软件开发\"><a href=\"#用工厂流水线的眼光来看待软件开发\" class=\"headerlink\" title=\"用工厂流水线的眼光来看待软件开发\"></a>用工厂流水线的眼光来看待软件开发</h3><p>书中的“贵人”埃瑞克一直在强调一点，就是IT开发运维流程的本质与工厂的流水线相同，开发、QA测试、运维发布等都是其中的数个环节，需要明确是哪个结点产生了工作的积压。但本书并不会告诉你如何“加大节点生产力”，毕竟人不是机器，堆量不一定能提高效率，这点在《人月神话》中会说得更清楚，本书提出的是如何在生产力有限的情况下，合理地安排工作流：</p>\n<h4 id=\"三步工作法\"><a href=\"#三步工作法\" class=\"headerlink\" title=\"三步工作法\"></a>三步工作法</h4><ol>\n<li>第一工作法是关于从开发到IT运维再到客户的整个自左向右的工作流。为了使流量最大化，我们需要小的批量规模和工作间隔</li>\n<li>第二工作法是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保问题再次发生，或者更快地发现和修复问题，从源头上保证质量</li>\n<li>第三工作法是关于创造公司文化：鼓励探索、在失败中吸取教训；让员工理解重复的演练是重要的经验积累</li>\n</ol>\n<h3 id=\"敏捷开发和可持续交付\"><a href=\"#敏捷开发和可持续交付\" class=\"headerlink\" title=\"敏捷开发和可持续交付\"></a>敏捷开发和可持续交付</h3><p>书中有这样一段</p>\n<blockquote>\n<p>在竞争的时代，游戏规则就是“快速上市，快速淘汰”。我们不能为推出一个产品而制定为期几年的工作计划，一直等到最后才弄清手上拿的牌是赢家还是输家。我们需要短而快的周期，不断整合来自市场的反馈。<br>产品开发周期越长，公司资本锁定的时间也就越长，资金锁定期间是没有回报的。一旦研发资本以半成品的形式锁定超过一年而未向公司返还现金，它就几乎不可能再为公司产生回报了。</p>\n</blockquote>\n<p>书中很明确地提到的了一个开发周期为3年的项目对于公司来说相当于沉没成本，它持续耗费成本却不能产生任何价值，即使最后上线也有可能远远落后于竞品，这对于一家运营状况不好的公司来说是足以致命的，而敏捷开发不断给出可落地的成果，给予公司和市场信心，效果是会更好的。</p>\n<h3 id=\"IT部门的定位\"><a href=\"#IT部门的定位\" class=\"headerlink\" title=\"IT部门的定位\"></a>IT部门的定位</h3><p>由于书中的公司并非一个互联网公司，软件开发、QA、运维等部门并非是营利的核心，很多时候运营、财务部门会认为IT部门是累赘，效率低且不能完成运营需求，但他们没考虑过IT部门的产出本身就是一个业务指标，IT部门运转情况也与公司的命脉息息相关。由IT引起的运营风险不只是IT风险，同样也是业务风险，需要将这些风险管控纳入业绩指标。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在读这本书前我也未曾考虑过高层次的问题，这本书能提供一定的眼界，纵观全局才能明晰问题所在，对于工作流程的一些观点也值得学习。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>部门老大推荐的一本书，全名《凤凰项目：一个IT运维的传奇故事》，一开始没注意看到副标题，光看主标题还以为是简单介绍如何做好项目管理和人员开发的书，类似《人月神话》。然而看了之后才发现是小说形式的，讲述一个新上任的IT运维部主管如何整理自己部门的烂摊子，并与开发、QA、内审、财务、运营…各个部门间有效合作最终挽救了一个失败项目的故事。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>故事并非发生在一个互联网公司，而是美国的一个传统的汽车制造业公司——“无极限公司”。开发和IT运维并非是该公司的核心部门，甚至由于他们历史上的效率低下和问题频出，公司已经开始考虑寻求外包解决方案，主角们面临被解雇的危机；而公司本身也处于风雨飘摇之中，友商新上线的产品推荐和个性化系统吸引了大量的客户，使得股市和董事会对公司多有微言，迫于压力无极限公司也开始研发类似的系统期望挽回客户，该项目称为“凤凰”。</p>\n<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><p>这本书并非只是单纯说如何完成“凤凰”这个项目的，主角是IT运维部门的主管，视角与我们一般的开发者不相同，全书并没有着眼与介绍一个软件项目是如何策划、开发、完成测试并上线的，而是从整个“传统制造业公司”的层面去审视运维工作流程、任务管理、各部门间的合作，并提出作者的一些观点。</p>\n<h3 id=\"人和工作的管理\"><a href=\"#人和工作的管理\" class=\"headerlink\" title=\"人和工作的管理\"></a>人和工作的管理</h3><p>主角一上任就碰到了多次的系统故障，公司的工资发放、信用卡支付等重要功能受到影响，经过一系列流程梳理后，最终问题的焦点都在一个名为布伦特的人身上。他就是这个IT运维部的最核心员工，对业务流程的深入程度使得其他人甚至都帮不上忙，但也正因如此，很多变更操作他都没有经过审批而是自己直接操作，也因此产生了很多不可预估的系统故障。最后的结果是所有的重要流程都要由他操作，出现的各种故障也要找他来排查解决，他变成了整个部门最忙又最不可取代的一环。</p>\n<p>主角团们发现了问题后，对其工作做出了分解，所有的服务器变更都必须拦下来，确认影响范围和优先级，并统一审核和安排时间实施，可以交由他人处理的工作就交由他人，他人尚不清楚的工作则由布伦特整理出工作流程。</p>\n<p><em>这个情况在我们实际的工作中也是经常遇到的，总有一个人掌握了很多你不知道的黑科技，各种操作都需要他来帮忙，但他出问题时所有人只能看着他着急。这不是一个正常的工作情况，在严格的项目管控中，没有人具有不可替代性，需要把脑中的经验梳理并文档化，才能让他人参与进来；其次就是变更工作的管控，所有的变更能明确影响范围和审核必要性，对于稳定的线上环境是很重要的。</em></p>\n<h4 id=\"IT的四类工作\"><a href=\"#IT的四类工作\" class=\"headerlink\" title=\"IT的四类工作\"></a>IT的四类工作</h4><ol>\n<li>业务项目，如故事中的“凤凰”项目</li>\n<li>IT内部项目，如各类发布、部署自动化系统</li>\n<li>服务器变更，如常规的服务器迁移、数据库迁移等</li>\n<li>计划外工作或救火工作</li>\n</ol>\n<p>短暂的“走捷径”或者绕过正规流程的操作会导致技术债务，技术债务的积累终将导致产生大量的计划外工作，最终使得处理人员再没有时间处理前3类计划内工作。因此我们需要及时地对流程进行规范和限制。</p>\n<h3 id=\"用工厂流水线的眼光来看待软件开发\"><a href=\"#用工厂流水线的眼光来看待软件开发\" class=\"headerlink\" title=\"用工厂流水线的眼光来看待软件开发\"></a>用工厂流水线的眼光来看待软件开发</h3><p>书中的“贵人”埃瑞克一直在强调一点，就是IT开发运维流程的本质与工厂的流水线相同，开发、QA测试、运维发布等都是其中的数个环节，需要明确是哪个结点产生了工作的积压。但本书并不会告诉你如何“加大节点生产力”，毕竟人不是机器，堆量不一定能提高效率，这点在《人月神话》中会说得更清楚，本书提出的是如何在生产力有限的情况下，合理地安排工作流：</p>\n<h4 id=\"三步工作法\"><a href=\"#三步工作法\" class=\"headerlink\" title=\"三步工作法\"></a>三步工作法</h4><ol>\n<li>第一工作法是关于从开发到IT运维再到客户的整个自左向右的工作流。为了使流量最大化，我们需要小的批量规模和工作间隔</li>\n<li>第二工作法是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保问题再次发生，或者更快地发现和修复问题，从源头上保证质量</li>\n<li>第三工作法是关于创造公司文化：鼓励探索、在失败中吸取教训；让员工理解重复的演练是重要的经验积累</li>\n</ol>\n<h3 id=\"敏捷开发和可持续交付\"><a href=\"#敏捷开发和可持续交付\" class=\"headerlink\" title=\"敏捷开发和可持续交付\"></a>敏捷开发和可持续交付</h3><p>书中有这样一段</p>\n<blockquote>\n<p>在竞争的时代，游戏规则就是“快速上市，快速淘汰”。我们不能为推出一个产品而制定为期几年的工作计划，一直等到最后才弄清手上拿的牌是赢家还是输家。我们需要短而快的周期，不断整合来自市场的反馈。<br>产品开发周期越长，公司资本锁定的时间也就越长，资金锁定期间是没有回报的。一旦研发资本以半成品的形式锁定超过一年而未向公司返还现金，它就几乎不可能再为公司产生回报了。</p>\n</blockquote>\n<p>书中很明确地提到的了一个开发周期为3年的项目对于公司来说相当于沉没成本，它持续耗费成本却不能产生任何价值，即使最后上线也有可能远远落后于竞品，这对于一家运营状况不好的公司来说是足以致命的，而敏捷开发不断给出可落地的成果，给予公司和市场信心，效果是会更好的。</p>\n<h3 id=\"IT部门的定位\"><a href=\"#IT部门的定位\" class=\"headerlink\" title=\"IT部门的定位\"></a>IT部门的定位</h3><p>由于书中的公司并非一个互联网公司，软件开发、QA、运维等部门并非是营利的核心，很多时候运营、财务部门会认为IT部门是累赘，效率低且不能完成运营需求，但他们没考虑过IT部门的产出本身就是一个业务指标，IT部门运转情况也与公司的命脉息息相关。由IT引起的运营风险不只是IT风险，同样也是业务风险，需要将这些风险管控纳入业绩指标。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在读这本书前我也未曾考虑过高层次的问题，这本书能提供一定的眼界，纵观全局才能明晰问题所在，对于工作流程的一些观点也值得学习。</p>\n"},{"title":"一次Node代码bug的追踪过程","desc":"这大概是遇见过的最难找的代码bug了","date":"2017-02-23T04:00:14.000Z","author":"ngtmuzi","_content":"## 背景  \n\n业务接入了elk日志系统，考虑到能自定义日志格式和Mapping，没有使用logstash来抓取日志，而选择用本地RabbitMQ队列+Node的Elasticsearch模块来自己写日志，写日志的具体逻辑如下  \n![日志写入流程](http://i1.piimg.com/4851/2d8505e03dc3e630.png)\n\n\n问题就出在这张图上。\n## bug描述\n\n在正式环境下这个日志写入进程会经常“挂”掉，因为有另一个进程定时检查RabbitMQ队列的消息量，所以会及时发现队列的消息堆积并发出报警，这个时候到RabbitMQ的管理界面上会看到日志进程断连了（日志队列的订阅者数量为0），RabbitMQ的日志也显示客户端心跳超时断连。正常来说连接断开会触发`amqplib`模块connection的close或者error之类的事件，而后进程会打印错误然后退出（PM2会自动重启），但从PM2上观察，日志进程却还在运行，也没有输出错误，然后在几十分钟后结束进程。\n  \n\n找不到问题就加日志检查咯，由于是实时性要求不高的日志写入进程，所以随意重启调试也没关系。我在定期写入Elastic的函数（每秒执行1次）里加了调试打印，发现神奇的一幕：每逢整10分钟或20分钟，日志打印就会停止，从raabitmq管理界面上就看到进程断开了。从这里能推出两点：\n1. 一定跟定时任务有关\n2. 定时任务不再执行，最大的可能性是有严重耗时的同步操作阻塞了javascript主线程，这个也能解释为什么没有触发断开连接的事件，实际上是触发了，但事件还在Node的事件队列里等待异步处理\n \n \n\n但之后就没头绪了，因为我的代码里根本没有每10分钟触发一次的定时任务，也没有复杂到能够卡住几十分钟的同步cpu运算，我开始怀疑是系统其他定时任务的原因影响，但并没有找到线索。\n## 进一步检查\n\n说来惭愧，以前碰到bug基本上都是靠加log来追踪调试的，基本都能解决，但碰到这个连log都不打印的情况，加log都没用了，这个时候就要搬出[Node的性能分析工具](https://nodejs.org/en/docs/guides/simple-profiling/)，先运行\n```cmd\nnode --prof index.js\n```\n\n收集性能日志，一直运行到进程卡住挂起再停止，Node会在运行文件夹生成一个“isolate-0xnnnnnnnnnnnn-v8.log”文件，然后用它来生成简化的性能报告\n```cmd\nnode --prof-process isolate-0xnnnnnnnnnnnn-v8.log > processed.txt\n```\n\n报告显示了代码中各个部分占用CPU时间的情况，检查“processed.txt”之后问题一目了然：\n```\n [JavaScript]:\n   ticks  total  nonlib   name\n  687497   75.5%   75.9%  LazyCompile: *findMiddleSnake /xxx/node_modules/.1.0.1@mdiff/lib/index.js:43:36\n  59471    6.5%    6.6%  Stub: StringCompareStub\n   3137    0.3%    0.3%  Stub: CEntryStub {1}\n   1545    0.2%    0.2%  Stub: CEntryStub\n   1080    0.1%    0.1%  Stub: LoadICStub\n```\n\n看到[`mdiff`](https://github.com/tapirdata/mdiff)这个模块还真是出乎意料，它用于流程图上“IM报警Appender”[（代码）](https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L108)的聚合日志功能，简单来说就是计算两条输出日志的相似度，比较接近的日志可以统计条数再输出，避免被同样内容的日志刷屏。\n\n\n原理比较暴力，就是计算出最大相同子串（就是LCS算法，使用`mdiff`模块提供的函数来处理），计算子串长度占原串长度的百分比（相似度）再进行聚合。那么这个计算LCS的操作会占用很长的CPU时间吗？\n  \n\n`mdiff`的文档上给出了使用算法的[论文地址](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927)，出于种种原因我们就不细究到具体算法了\\_(:3 」∠ )\\_，简单看了一下算法时间复杂度：O(ND)，在最坏条件下D=2N，也就是O(2N<sup>2</sup>)。而外层的统计聚合[（代码）](https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L208)，在最坏的情况下会调用`mdiff`的LCS算法M<sup>2</sup>（M：日志条数）次，也就是说最差的算法复杂度是O(2N<sup>2</sup>M<sup>2</sup>)，这可是十分可怕的……\n  \n\n再结合实际情况：一次批量写入最多512条日志，每秒写1次，日志进程向ElasticSearch写入日志经常会返回类似这样的错误：\n```\nversion conflict, current version [13] is different than the one provided [12]\n```\n\n而返回的错误我都会完整地打印log出来，以供IM报警（参见流程图），于是产生了大量非常非常长的错误log。这些log每隔5分钟会做一次统计聚合，于是产生了严重耗时的同步操作，导致所有异步回调都被阻塞，包括各个定时器和event订阅。\n\n## 解决方案\n1. 减少计算量  \n限制参与计算的日志长度和日志量，因为是用来聚合做IM报警的，本身就不需要完整显示出来，过长的日志可以直接截断。\n2. 减少错误出现次数  \nElastic会返回“version conflict”这个错误主要是因为存在多个进程同时写入一个文档的情况，官方也提供了[`retry_on_conflict`](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html#_parameters_2)这个参数来解决问题，在`bulk`操作中它的名字是`_retry_on_conflict`，用于指定返回错误前的重试次数，理论上来说调大它就会减少出现版本错误的概率\n\n做了上述处理之后，问题被修复\n## 总结\n1. 对不熟悉的事物保持敬畏，多翻文档多尝试\n2. 对自己的代码保持猜疑，注意考虑边界条件和兜底\n3. 善用工具能节省无谓的时间","source":"_posts/一次Node代码bug的追踪过程.md","raw":"---\ntitle: 一次Node代码bug的追踪过程\ndesc: 这大概是遇见过的最难找的代码bug了  \ndate: 2017-2-23 12:00:14  \ntags: \n- nodejs  \nauthor: ngtmuzi  \ncategory: 亡羊补牢\n---\n## 背景  \n\n业务接入了elk日志系统，考虑到能自定义日志格式和Mapping，没有使用logstash来抓取日志，而选择用本地RabbitMQ队列+Node的Elasticsearch模块来自己写日志，写日志的具体逻辑如下  \n![日志写入流程](http://i1.piimg.com/4851/2d8505e03dc3e630.png)\n\n\n问题就出在这张图上。\n## bug描述\n\n在正式环境下这个日志写入进程会经常“挂”掉，因为有另一个进程定时检查RabbitMQ队列的消息量，所以会及时发现队列的消息堆积并发出报警，这个时候到RabbitMQ的管理界面上会看到日志进程断连了（日志队列的订阅者数量为0），RabbitMQ的日志也显示客户端心跳超时断连。正常来说连接断开会触发`amqplib`模块connection的close或者error之类的事件，而后进程会打印错误然后退出（PM2会自动重启），但从PM2上观察，日志进程却还在运行，也没有输出错误，然后在几十分钟后结束进程。\n  \n\n找不到问题就加日志检查咯，由于是实时性要求不高的日志写入进程，所以随意重启调试也没关系。我在定期写入Elastic的函数（每秒执行1次）里加了调试打印，发现神奇的一幕：每逢整10分钟或20分钟，日志打印就会停止，从raabitmq管理界面上就看到进程断开了。从这里能推出两点：\n1. 一定跟定时任务有关\n2. 定时任务不再执行，最大的可能性是有严重耗时的同步操作阻塞了javascript主线程，这个也能解释为什么没有触发断开连接的事件，实际上是触发了，但事件还在Node的事件队列里等待异步处理\n \n \n\n但之后就没头绪了，因为我的代码里根本没有每10分钟触发一次的定时任务，也没有复杂到能够卡住几十分钟的同步cpu运算，我开始怀疑是系统其他定时任务的原因影响，但并没有找到线索。\n## 进一步检查\n\n说来惭愧，以前碰到bug基本上都是靠加log来追踪调试的，基本都能解决，但碰到这个连log都不打印的情况，加log都没用了，这个时候就要搬出[Node的性能分析工具](https://nodejs.org/en/docs/guides/simple-profiling/)，先运行\n```cmd\nnode --prof index.js\n```\n\n收集性能日志，一直运行到进程卡住挂起再停止，Node会在运行文件夹生成一个“isolate-0xnnnnnnnnnnnn-v8.log”文件，然后用它来生成简化的性能报告\n```cmd\nnode --prof-process isolate-0xnnnnnnnnnnnn-v8.log > processed.txt\n```\n\n报告显示了代码中各个部分占用CPU时间的情况，检查“processed.txt”之后问题一目了然：\n```\n [JavaScript]:\n   ticks  total  nonlib   name\n  687497   75.5%   75.9%  LazyCompile: *findMiddleSnake /xxx/node_modules/.1.0.1@mdiff/lib/index.js:43:36\n  59471    6.5%    6.6%  Stub: StringCompareStub\n   3137    0.3%    0.3%  Stub: CEntryStub {1}\n   1545    0.2%    0.2%  Stub: CEntryStub\n   1080    0.1%    0.1%  Stub: LoadICStub\n```\n\n看到[`mdiff`](https://github.com/tapirdata/mdiff)这个模块还真是出乎意料，它用于流程图上“IM报警Appender”[（代码）](https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L108)的聚合日志功能，简单来说就是计算两条输出日志的相似度，比较接近的日志可以统计条数再输出，避免被同样内容的日志刷屏。\n\n\n原理比较暴力，就是计算出最大相同子串（就是LCS算法，使用`mdiff`模块提供的函数来处理），计算子串长度占原串长度的百分比（相似度）再进行聚合。那么这个计算LCS的操作会占用很长的CPU时间吗？\n  \n\n`mdiff`的文档上给出了使用算法的[论文地址](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927)，出于种种原因我们就不细究到具体算法了\\_(:3 」∠ )\\_，简单看了一下算法时间复杂度：O(ND)，在最坏条件下D=2N，也就是O(2N<sup>2</sup>)。而外层的统计聚合[（代码）](https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L208)，在最坏的情况下会调用`mdiff`的LCS算法M<sup>2</sup>（M：日志条数）次，也就是说最差的算法复杂度是O(2N<sup>2</sup>M<sup>2</sup>)，这可是十分可怕的……\n  \n\n再结合实际情况：一次批量写入最多512条日志，每秒写1次，日志进程向ElasticSearch写入日志经常会返回类似这样的错误：\n```\nversion conflict, current version [13] is different than the one provided [12]\n```\n\n而返回的错误我都会完整地打印log出来，以供IM报警（参见流程图），于是产生了大量非常非常长的错误log。这些log每隔5分钟会做一次统计聚合，于是产生了严重耗时的同步操作，导致所有异步回调都被阻塞，包括各个定时器和event订阅。\n\n## 解决方案\n1. 减少计算量  \n限制参与计算的日志长度和日志量，因为是用来聚合做IM报警的，本身就不需要完整显示出来，过长的日志可以直接截断。\n2. 减少错误出现次数  \nElastic会返回“version conflict”这个错误主要是因为存在多个进程同时写入一个文档的情况，官方也提供了[`retry_on_conflict`](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html#_parameters_2)这个参数来解决问题，在`bulk`操作中它的名字是`_retry_on_conflict`，用于指定返回错误前的重试次数，理论上来说调大它就会减少出现版本错误的概率\n\n做了上述处理之后，问题被修复\n## 总结\n1. 对不熟悉的事物保持敬畏，多翻文档多尝试\n2. 对自己的代码保持猜疑，注意考虑边界条件和兜底\n3. 善用工具能节省无谓的时间","slug":"一次Node代码bug的追踪过程","published":1,"updated":"2020-06-17T10:26:40.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbo000ksou54yq6gnya","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>业务接入了elk日志系统，考虑到能自定义日志格式和Mapping，没有使用logstash来抓取日志，而选择用本地RabbitMQ队列+Node的Elasticsearch模块来自己写日志，写日志的具体逻辑如下<br><img src=\"http://i1.piimg.com/4851/2d8505e03dc3e630.png\" alt=\"日志写入流程\"></p>\n<p>问题就出在这张图上。</p>\n<h2 id=\"bug描述\"><a href=\"#bug描述\" class=\"headerlink\" title=\"bug描述\"></a>bug描述</h2><p>在正式环境下这个日志写入进程会经常“挂”掉，因为有另一个进程定时检查RabbitMQ队列的消息量，所以会及时发现队列的消息堆积并发出报警，这个时候到RabbitMQ的管理界面上会看到日志进程断连了（日志队列的订阅者数量为0），RabbitMQ的日志也显示客户端心跳超时断连。正常来说连接断开会触发<code>amqplib</code>模块connection的close或者error之类的事件，而后进程会打印错误然后退出（PM2会自动重启），但从PM2上观察，日志进程却还在运行，也没有输出错误，然后在几十分钟后结束进程。</p>\n<p>找不到问题就加日志检查咯，由于是实时性要求不高的日志写入进程，所以随意重启调试也没关系。我在定期写入Elastic的函数（每秒执行1次）里加了调试打印，发现神奇的一幕：每逢整10分钟或20分钟，日志打印就会停止，从raabitmq管理界面上就看到进程断开了。从这里能推出两点：</p>\n<ol>\n<li>一定跟定时任务有关</li>\n<li>定时任务不再执行，最大的可能性是有严重耗时的同步操作阻塞了javascript主线程，这个也能解释为什么没有触发断开连接的事件，实际上是触发了，但事件还在Node的事件队列里等待异步处理</li>\n</ol>\n<p>但之后就没头绪了，因为我的代码里根本没有每10分钟触发一次的定时任务，也没有复杂到能够卡住几十分钟的同步cpu运算，我开始怀疑是系统其他定时任务的原因影响，但并没有找到线索。</p>\n<h2 id=\"进一步检查\"><a href=\"#进一步检查\" class=\"headerlink\" title=\"进一步检查\"></a>进一步检查</h2><p>说来惭愧，以前碰到bug基本上都是靠加log来追踪调试的，基本都能解决，但碰到这个连log都不打印的情况，加log都没用了，这个时候就要搬出<a href=\"https://nodejs.org/en/docs/guides/simple-profiling/\">Node的性能分析工具</a>，先运行<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --prof index.js</span><br></pre></td></tr></table></figure></p>\n<p>收集性能日志，一直运行到进程卡住挂起再停止，Node会在运行文件夹生成一个“isolate-0xnnnnnnnnnnnn-v8.log”文件，然后用它来生成简化的性能报告<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --prof-process isolate-<span class=\"number\">0</span>xnnnnnnnnnnnn-v8.log &gt; processed.txt</span><br></pre></td></tr></table></figure></p>\n<p>报告显示了代码中各个部分占用CPU时间的情况，检查“processed.txt”之后问题一目了然：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[JavaScript]:</span><br><span class=\"line\">  ticks  total  nonlib   name</span><br><span class=\"line\"> 687497   75.5%   75.9%  LazyCompile: *findMiddleSnake &#x2F;xxx&#x2F;node_modules&#x2F;.1.0.1@mdiff&#x2F;lib&#x2F;index.js:43:36</span><br><span class=\"line\"> 59471    6.5%    6.6%  Stub: StringCompareStub</span><br><span class=\"line\">  3137    0.3%    0.3%  Stub: CEntryStub &#123;1&#125;</span><br><span class=\"line\">  1545    0.2%    0.2%  Stub: CEntryStub</span><br><span class=\"line\">  1080    0.1%    0.1%  Stub: LoadICStub</span><br></pre></td></tr></table></figure></p>\n<p>看到<a href=\"https://github.com/tapirdata/mdiff\"><code>mdiff</code></a>这个模块还真是出乎意料，它用于流程图上“IM报警Appender”<a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L108\">（代码）</a>的聚合日志功能，简单来说就是计算两条输出日志的相似度，比较接近的日志可以统计条数再输出，避免被同样内容的日志刷屏。</p>\n<p>原理比较暴力，就是计算出最大相同子串（就是LCS算法，使用<code>mdiff</code>模块提供的函数来处理），计算子串长度占原串长度的百分比（相似度）再进行聚合。那么这个计算LCS的操作会占用很长的CPU时间吗？</p>\n<p><code>mdiff</code>的文档上给出了使用算法的<a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\">论文地址</a>，出于种种原因我们就不细究到具体算法了_(:3 」∠ )_，简单看了一下算法时间复杂度：O(ND)，在最坏条件下D=2N，也就是O(2N<sup>2</sup>)。而外层的统计聚合<a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L208\">（代码）</a>，在最坏的情况下会调用<code>mdiff</code>的LCS算法M<sup>2</sup>（M：日志条数）次，也就是说最差的算法复杂度是O(2N<sup>2</sup>M<sup>2</sup>)，这可是十分可怕的……</p>\n<p>再结合实际情况：一次批量写入最多512条日志，每秒写1次，日志进程向ElasticSearch写入日志经常会返回类似这样的错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version conflict, current version [13] is different than the one provided [12]</span><br></pre></td></tr></table></figure></p>\n<p>而返回的错误我都会完整地打印log出来，以供IM报警（参见流程图），于是产生了大量非常非常长的错误log。这些log每隔5分钟会做一次统计聚合，于是产生了严重耗时的同步操作，导致所有异步回调都被阻塞，包括各个定时器和event订阅。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li>减少计算量<br>限制参与计算的日志长度和日志量，因为是用来聚合做IM报警的，本身就不需要完整显示出来，过长的日志可以直接截断。</li>\n<li>减少错误出现次数<br>Elastic会返回“version conflict”这个错误主要是因为存在多个进程同时写入一个文档的情况，官方也提供了<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html#_parameters_2\"><code>retry_on_conflict</code></a>这个参数来解决问题，在<code>bulk</code>操作中它的名字是<code>_retry_on_conflict</code>，用于指定返回错误前的重试次数，理论上来说调大它就会减少出现版本错误的概率</li>\n</ol>\n<p>做了上述处理之后，问题被修复</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>对不熟悉的事物保持敬畏，多翻文档多尝试</li>\n<li>对自己的代码保持猜疑，注意考虑边界条件和兜底</li>\n<li>善用工具能节省无谓的时间</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>业务接入了elk日志系统，考虑到能自定义日志格式和Mapping，没有使用logstash来抓取日志，而选择用本地RabbitMQ队列+Node的Elasticsearch模块来自己写日志，写日志的具体逻辑如下<br><img src=\"http://i1.piimg.com/4851/2d8505e03dc3e630.png\" alt=\"日志写入流程\"></p>\n<p>问题就出在这张图上。</p>\n<h2 id=\"bug描述\"><a href=\"#bug描述\" class=\"headerlink\" title=\"bug描述\"></a>bug描述</h2><p>在正式环境下这个日志写入进程会经常“挂”掉，因为有另一个进程定时检查RabbitMQ队列的消息量，所以会及时发现队列的消息堆积并发出报警，这个时候到RabbitMQ的管理界面上会看到日志进程断连了（日志队列的订阅者数量为0），RabbitMQ的日志也显示客户端心跳超时断连。正常来说连接断开会触发<code>amqplib</code>模块connection的close或者error之类的事件，而后进程会打印错误然后退出（PM2会自动重启），但从PM2上观察，日志进程却还在运行，也没有输出错误，然后在几十分钟后结束进程。</p>\n<p>找不到问题就加日志检查咯，由于是实时性要求不高的日志写入进程，所以随意重启调试也没关系。我在定期写入Elastic的函数（每秒执行1次）里加了调试打印，发现神奇的一幕：每逢整10分钟或20分钟，日志打印就会停止，从raabitmq管理界面上就看到进程断开了。从这里能推出两点：</p>\n<ol>\n<li>一定跟定时任务有关</li>\n<li>定时任务不再执行，最大的可能性是有严重耗时的同步操作阻塞了javascript主线程，这个也能解释为什么没有触发断开连接的事件，实际上是触发了，但事件还在Node的事件队列里等待异步处理</li>\n</ol>\n<p>但之后就没头绪了，因为我的代码里根本没有每10分钟触发一次的定时任务，也没有复杂到能够卡住几十分钟的同步cpu运算，我开始怀疑是系统其他定时任务的原因影响，但并没有找到线索。</p>\n<h2 id=\"进一步检查\"><a href=\"#进一步检查\" class=\"headerlink\" title=\"进一步检查\"></a>进一步检查</h2><p>说来惭愧，以前碰到bug基本上都是靠加log来追踪调试的，基本都能解决，但碰到这个连log都不打印的情况，加log都没用了，这个时候就要搬出<a href=\"https://nodejs.org/en/docs/guides/simple-profiling/\">Node的性能分析工具</a>，先运行<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --prof index.js</span><br></pre></td></tr></table></figure></p>\n<p>收集性能日志，一直运行到进程卡住挂起再停止，Node会在运行文件夹生成一个“isolate-0xnnnnnnnnnnnn-v8.log”文件，然后用它来生成简化的性能报告<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --prof-process isolate-<span class=\"number\">0</span>xnnnnnnnnnnnn-v8.log &gt; processed.txt</span><br></pre></td></tr></table></figure></p>\n<p>报告显示了代码中各个部分占用CPU时间的情况，检查“processed.txt”之后问题一目了然：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[JavaScript]:</span><br><span class=\"line\">  ticks  total  nonlib   name</span><br><span class=\"line\"> 687497   75.5%   75.9%  LazyCompile: *findMiddleSnake &#x2F;xxx&#x2F;node_modules&#x2F;.1.0.1@mdiff&#x2F;lib&#x2F;index.js:43:36</span><br><span class=\"line\"> 59471    6.5%    6.6%  Stub: StringCompareStub</span><br><span class=\"line\">  3137    0.3%    0.3%  Stub: CEntryStub &#123;1&#125;</span><br><span class=\"line\">  1545    0.2%    0.2%  Stub: CEntryStub</span><br><span class=\"line\">  1080    0.1%    0.1%  Stub: LoadICStub</span><br></pre></td></tr></table></figure></p>\n<p>看到<a href=\"https://github.com/tapirdata/mdiff\"><code>mdiff</code></a>这个模块还真是出乎意料，它用于流程图上“IM报警Appender”<a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L108\">（代码）</a>的聚合日志功能，简单来说就是计算两条输出日志的相似度，比较接近的日志可以统计条数再输出，避免被同样内容的日志刷屏。</p>\n<p>原理比较暴力，就是计算出最大相同子串（就是LCS算法，使用<code>mdiff</code>模块提供的函数来处理），计算子串长度占原串长度的百分比（相似度）再进行聚合。那么这个计算LCS的操作会占用很长的CPU时间吗？</p>\n<p><code>mdiff</code>的文档上给出了使用算法的<a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\">论文地址</a>，出于种种原因我们就不细究到具体算法了_(:3 」∠ )_，简单看了一下算法时间复杂度：O(ND)，在最坏条件下D=2N，也就是O(2N<sup>2</sup>)。而外层的统计聚合<a href=\"https://github.com/ngtmuzi/wheel/blob/master/services/logger.js#L208\">（代码）</a>，在最坏的情况下会调用<code>mdiff</code>的LCS算法M<sup>2</sup>（M：日志条数）次，也就是说最差的算法复杂度是O(2N<sup>2</sup>M<sup>2</sup>)，这可是十分可怕的……</p>\n<p>再结合实际情况：一次批量写入最多512条日志，每秒写1次，日志进程向ElasticSearch写入日志经常会返回类似这样的错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version conflict, current version [13] is different than the one provided [12]</span><br></pre></td></tr></table></figure></p>\n<p>而返回的错误我都会完整地打印log出来，以供IM报警（参见流程图），于是产生了大量非常非常长的错误log。这些log每隔5分钟会做一次统计聚合，于是产生了严重耗时的同步操作，导致所有异步回调都被阻塞，包括各个定时器和event订阅。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li>减少计算量<br>限制参与计算的日志长度和日志量，因为是用来聚合做IM报警的，本身就不需要完整显示出来，过长的日志可以直接截断。</li>\n<li>减少错误出现次数<br>Elastic会返回“version conflict”这个错误主要是因为存在多个进程同时写入一个文档的情况，官方也提供了<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html#_parameters_2\"><code>retry_on_conflict</code></a>这个参数来解决问题，在<code>bulk</code>操作中它的名字是<code>_retry_on_conflict</code>，用于指定返回错误前的重试次数，理论上来说调大它就会减少出现版本错误的概率</li>\n</ol>\n<p>做了上述处理之后，问题被修复</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>对不熟悉的事物保持敬畏，多翻文档多尝试</li>\n<li>对自己的代码保持猜疑，注意考虑边界条件和兜底</li>\n<li>善用工具能节省无谓的时间</li>\n</ol>\n"},{"title":"个人使用Elastic+Kibana的一些经验","desc":"在记录日志的时候引入了elk栈，但日志写入部分是自己写的，并没有使用`logstash`，因此经验就不包括`logstash`啦","author":"ngtmuzi","date":"2017-07-17T11:03:51.000Z","_content":"在记录日志的时候引入了elk栈，但日志写入部分是自己写的，并没有使用`logstash`，因此经验就不包括`logstash`啦\n\n## ElasticSearch部分\n\n### 有一个管理后台\n\nElasticSearch（以下简称ES）本身不带GUI，官方插件集x-pack添加到kibana中的monitoring界面只能看索引/集群信息却不能做管理，在你想删除/关闭/合并分段等操作的时候就会感觉束手无策，用RESTful的工具（如Chrome的插件PostMan）来请求ES的接口固然是一种方法，但毕竟不是长久之策，除非你喜欢这么玩……\n\n目前Github上最受欢迎的项目是[elasticsearch-head](https://github.com/mobz/elasticsearch-head)，功能完善足以满足需求，不过在一些小细节不是很尽如人意……比如它是纯前端去访问ES接口的，会碰到跨域问题，官方提供的解决方法如下：\n* 去改ElasticSearch的配置允许跨域\n* 开一个允许跨域的本地代理（项目自身有提供）\n* 安装一个插件到ES上\n\n根据自己项目的实际情况也可以自己做一个后台实现一些简单的功能，类似这样\n\n![](/img/elk_desc_1.png)\n\n### 注意资源使用量\n\n数据量大而资源不足的情况下要尤其注意这点，即使按照ES官方文档的推荐设置好配置，也给了32G大内存，ES还是会在某些深夜默默地GC超时然后内存溢出崩溃，以下是一些建议：\n* 最好使用3台及以上的机器组成集群来使用\n* 负责接受写入请求的节点以及主节点最好不存数据，避免这个节点崩溃后上游调用方全都写不进数据\n* 定时清理内部的索引，一般推荐的索引维度是按天分索引，因此可以做一些通配条件来对一定时间前的索引做删除/关闭/合并分段操作减少内存占用\n\n### 注意文档字段的类型\n\n向ES写入数据时，要注意JSON内各字段的类型，ES会“智能”地以字段第一次出现时的类型来动态建立Mapping（参考[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/dynamic-field-mapping.html)），并且不能在之后改变。假设`a`字段第一次传的是字符串，而第二次传了数值，ES会返回一个Mapping不匹配的错误，另外如果你传的字符串第一次刚好符合日期的格式，那么这个字段就被认为是Date类型，下次传其他字符串的时候也会返回Mapping错误，这点要注意避免\n\n## kibana部分\n\n### lucene语法\n\n[官方文档](http://lucene.apache.org/core/6_6_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html)，个人的使用经验是遇事不决用括号`()`，很多时候搜索结果不符合预期是因为没有括号导致解析器误解了搜索条件\n\n### 慎用通配符\n\n在搜索字符串两侧都加`*`可能会有严重的性能问题，这点要小心\n\n### 导出数据到Excel\n\n虽然kibana本身的图表功能已经非常强大了，但总是有些需求要你导出数据到excel等工具上做进一步的分析，注意在图表的左下角有箭头，展开之后就能看到导出数据的按钮了\n\n![](/img/elk_desc_2.png)","source":"_posts/个人使用Elastic-Kibana的一些经验.md","raw":"---\ntitle: 个人使用Elastic+Kibana的一些经验\ndesc: 在记录日志的时候引入了elk栈，但日志写入部分是自己写的，并没有使用`logstash`，因此经验就不包括`logstash`啦\nauthor: ngtmuzi\ncategory: 班门弄斧\ndate: 2017-07-17 19:03:51\ntags: \n- ElasticSearch\n- Tool\n---\n在记录日志的时候引入了elk栈，但日志写入部分是自己写的，并没有使用`logstash`，因此经验就不包括`logstash`啦\n\n## ElasticSearch部分\n\n### 有一个管理后台\n\nElasticSearch（以下简称ES）本身不带GUI，官方插件集x-pack添加到kibana中的monitoring界面只能看索引/集群信息却不能做管理，在你想删除/关闭/合并分段等操作的时候就会感觉束手无策，用RESTful的工具（如Chrome的插件PostMan）来请求ES的接口固然是一种方法，但毕竟不是长久之策，除非你喜欢这么玩……\n\n目前Github上最受欢迎的项目是[elasticsearch-head](https://github.com/mobz/elasticsearch-head)，功能完善足以满足需求，不过在一些小细节不是很尽如人意……比如它是纯前端去访问ES接口的，会碰到跨域问题，官方提供的解决方法如下：\n* 去改ElasticSearch的配置允许跨域\n* 开一个允许跨域的本地代理（项目自身有提供）\n* 安装一个插件到ES上\n\n根据自己项目的实际情况也可以自己做一个后台实现一些简单的功能，类似这样\n\n![](/img/elk_desc_1.png)\n\n### 注意资源使用量\n\n数据量大而资源不足的情况下要尤其注意这点，即使按照ES官方文档的推荐设置好配置，也给了32G大内存，ES还是会在某些深夜默默地GC超时然后内存溢出崩溃，以下是一些建议：\n* 最好使用3台及以上的机器组成集群来使用\n* 负责接受写入请求的节点以及主节点最好不存数据，避免这个节点崩溃后上游调用方全都写不进数据\n* 定时清理内部的索引，一般推荐的索引维度是按天分索引，因此可以做一些通配条件来对一定时间前的索引做删除/关闭/合并分段操作减少内存占用\n\n### 注意文档字段的类型\n\n向ES写入数据时，要注意JSON内各字段的类型，ES会“智能”地以字段第一次出现时的类型来动态建立Mapping（参考[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/dynamic-field-mapping.html)），并且不能在之后改变。假设`a`字段第一次传的是字符串，而第二次传了数值，ES会返回一个Mapping不匹配的错误，另外如果你传的字符串第一次刚好符合日期的格式，那么这个字段就被认为是Date类型，下次传其他字符串的时候也会返回Mapping错误，这点要注意避免\n\n## kibana部分\n\n### lucene语法\n\n[官方文档](http://lucene.apache.org/core/6_6_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html)，个人的使用经验是遇事不决用括号`()`，很多时候搜索结果不符合预期是因为没有括号导致解析器误解了搜索条件\n\n### 慎用通配符\n\n在搜索字符串两侧都加`*`可能会有严重的性能问题，这点要小心\n\n### 导出数据到Excel\n\n虽然kibana本身的图表功能已经非常强大了，但总是有些需求要你导出数据到excel等工具上做进一步的分析，注意在图表的左下角有箭头，展开之后就能看到导出数据的按钮了\n\n![](/img/elk_desc_2.png)","slug":"个人使用Elastic-Kibana的一些经验","published":1,"updated":"2020-06-17T10:26:40.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbo000lsou512n60pr7","content":"<p>在记录日志的时候引入了elk栈，但日志写入部分是自己写的，并没有使用<code>logstash</code>，因此经验就不包括<code>logstash</code>啦</p>\n<h2 id=\"ElasticSearch部分\"><a href=\"#ElasticSearch部分\" class=\"headerlink\" title=\"ElasticSearch部分\"></a>ElasticSearch部分</h2><h3 id=\"有一个管理后台\"><a href=\"#有一个管理后台\" class=\"headerlink\" title=\"有一个管理后台\"></a>有一个管理后台</h3><p>ElasticSearch（以下简称ES）本身不带GUI，官方插件集x-pack添加到kibana中的monitoring界面只能看索引/集群信息却不能做管理，在你想删除/关闭/合并分段等操作的时候就会感觉束手无策，用RESTful的工具（如Chrome的插件PostMan）来请求ES的接口固然是一种方法，但毕竟不是长久之策，除非你喜欢这么玩……</p>\n<p>目前Github上最受欢迎的项目是<a href=\"https://github.com/mobz/elasticsearch-head\">elasticsearch-head</a>，功能完善足以满足需求，不过在一些小细节不是很尽如人意……比如它是纯前端去访问ES接口的，会碰到跨域问题，官方提供的解决方法如下：</p>\n<ul>\n<li>去改ElasticSearch的配置允许跨域</li>\n<li>开一个允许跨域的本地代理（项目自身有提供）</li>\n<li>安装一个插件到ES上</li>\n</ul>\n<p>根据自己项目的实际情况也可以自己做一个后台实现一些简单的功能，类似这样</p>\n<p><img src=\"/img/elk_desc_1.png\" alt=\"\"></p>\n<h3 id=\"注意资源使用量\"><a href=\"#注意资源使用量\" class=\"headerlink\" title=\"注意资源使用量\"></a>注意资源使用量</h3><p>数据量大而资源不足的情况下要尤其注意这点，即使按照ES官方文档的推荐设置好配置，也给了32G大内存，ES还是会在某些深夜默默地GC超时然后内存溢出崩溃，以下是一些建议：</p>\n<ul>\n<li>最好使用3台及以上的机器组成集群来使用</li>\n<li>负责接受写入请求的节点以及主节点最好不存数据，避免这个节点崩溃后上游调用方全都写不进数据</li>\n<li>定时清理内部的索引，一般推荐的索引维度是按天分索引，因此可以做一些通配条件来对一定时间前的索引做删除/关闭/合并分段操作减少内存占用</li>\n</ul>\n<h3 id=\"注意文档字段的类型\"><a href=\"#注意文档字段的类型\" class=\"headerlink\" title=\"注意文档字段的类型\"></a>注意文档字段的类型</h3><p>向ES写入数据时，要注意JSON内各字段的类型，ES会“智能”地以字段第一次出现时的类型来动态建立Mapping（参考<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.2/dynamic-field-mapping.html\">官方文档</a>），并且不能在之后改变。假设<code>a</code>字段第一次传的是字符串，而第二次传了数值，ES会返回一个Mapping不匹配的错误，另外如果你传的字符串第一次刚好符合日期的格式，那么这个字段就被认为是Date类型，下次传其他字符串的时候也会返回Mapping错误，这点要注意避免</p>\n<h2 id=\"kibana部分\"><a href=\"#kibana部分\" class=\"headerlink\" title=\"kibana部分\"></a>kibana部分</h2><h3 id=\"lucene语法\"><a href=\"#lucene语法\" class=\"headerlink\" title=\"lucene语法\"></a>lucene语法</h3><p><a href=\"http://lucene.apache.org/core/6_6_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html\">官方文档</a>，个人的使用经验是遇事不决用括号<code>()</code>，很多时候搜索结果不符合预期是因为没有括号导致解析器误解了搜索条件</p>\n<h3 id=\"慎用通配符\"><a href=\"#慎用通配符\" class=\"headerlink\" title=\"慎用通配符\"></a>慎用通配符</h3><p>在搜索字符串两侧都加<code>*</code>可能会有严重的性能问题，这点要小心</p>\n<h3 id=\"导出数据到Excel\"><a href=\"#导出数据到Excel\" class=\"headerlink\" title=\"导出数据到Excel\"></a>导出数据到Excel</h3><p>虽然kibana本身的图表功能已经非常强大了，但总是有些需求要你导出数据到excel等工具上做进一步的分析，注意在图表的左下角有箭头，展开之后就能看到导出数据的按钮了</p>\n<p><img src=\"/img/elk_desc_2.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在记录日志的时候引入了elk栈，但日志写入部分是自己写的，并没有使用<code>logstash</code>，因此经验就不包括<code>logstash</code>啦</p>\n<h2 id=\"ElasticSearch部分\"><a href=\"#ElasticSearch部分\" class=\"headerlink\" title=\"ElasticSearch部分\"></a>ElasticSearch部分</h2><h3 id=\"有一个管理后台\"><a href=\"#有一个管理后台\" class=\"headerlink\" title=\"有一个管理后台\"></a>有一个管理后台</h3><p>ElasticSearch（以下简称ES）本身不带GUI，官方插件集x-pack添加到kibana中的monitoring界面只能看索引/集群信息却不能做管理，在你想删除/关闭/合并分段等操作的时候就会感觉束手无策，用RESTful的工具（如Chrome的插件PostMan）来请求ES的接口固然是一种方法，但毕竟不是长久之策，除非你喜欢这么玩……</p>\n<p>目前Github上最受欢迎的项目是<a href=\"https://github.com/mobz/elasticsearch-head\">elasticsearch-head</a>，功能完善足以满足需求，不过在一些小细节不是很尽如人意……比如它是纯前端去访问ES接口的，会碰到跨域问题，官方提供的解决方法如下：</p>\n<ul>\n<li>去改ElasticSearch的配置允许跨域</li>\n<li>开一个允许跨域的本地代理（项目自身有提供）</li>\n<li>安装一个插件到ES上</li>\n</ul>\n<p>根据自己项目的实际情况也可以自己做一个后台实现一些简单的功能，类似这样</p>\n<p><img src=\"/img/elk_desc_1.png\" alt=\"\"></p>\n<h3 id=\"注意资源使用量\"><a href=\"#注意资源使用量\" class=\"headerlink\" title=\"注意资源使用量\"></a>注意资源使用量</h3><p>数据量大而资源不足的情况下要尤其注意这点，即使按照ES官方文档的推荐设置好配置，也给了32G大内存，ES还是会在某些深夜默默地GC超时然后内存溢出崩溃，以下是一些建议：</p>\n<ul>\n<li>最好使用3台及以上的机器组成集群来使用</li>\n<li>负责接受写入请求的节点以及主节点最好不存数据，避免这个节点崩溃后上游调用方全都写不进数据</li>\n<li>定时清理内部的索引，一般推荐的索引维度是按天分索引，因此可以做一些通配条件来对一定时间前的索引做删除/关闭/合并分段操作减少内存占用</li>\n</ul>\n<h3 id=\"注意文档字段的类型\"><a href=\"#注意文档字段的类型\" class=\"headerlink\" title=\"注意文档字段的类型\"></a>注意文档字段的类型</h3><p>向ES写入数据时，要注意JSON内各字段的类型，ES会“智能”地以字段第一次出现时的类型来动态建立Mapping（参考<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.2/dynamic-field-mapping.html\">官方文档</a>），并且不能在之后改变。假设<code>a</code>字段第一次传的是字符串，而第二次传了数值，ES会返回一个Mapping不匹配的错误，另外如果你传的字符串第一次刚好符合日期的格式，那么这个字段就被认为是Date类型，下次传其他字符串的时候也会返回Mapping错误，这点要注意避免</p>\n<h2 id=\"kibana部分\"><a href=\"#kibana部分\" class=\"headerlink\" title=\"kibana部分\"></a>kibana部分</h2><h3 id=\"lucene语法\"><a href=\"#lucene语法\" class=\"headerlink\" title=\"lucene语法\"></a>lucene语法</h3><p><a href=\"http://lucene.apache.org/core/6_6_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html\">官方文档</a>，个人的使用经验是遇事不决用括号<code>()</code>，很多时候搜索结果不符合预期是因为没有括号导致解析器误解了搜索条件</p>\n<h3 id=\"慎用通配符\"><a href=\"#慎用通配符\" class=\"headerlink\" title=\"慎用通配符\"></a>慎用通配符</h3><p>在搜索字符串两侧都加<code>*</code>可能会有严重的性能问题，这点要小心</p>\n<h3 id=\"导出数据到Excel\"><a href=\"#导出数据到Excel\" class=\"headerlink\" title=\"导出数据到Excel\"></a>导出数据到Excel</h3><p>虽然kibana本身的图表功能已经非常强大了，但总是有些需求要你导出数据到excel等工具上做进一步的分析，注意在图表的左下角有箭头，展开之后就能看到导出数据的按钮了</p>\n<p><img src=\"/img/elk_desc_2.png\" alt=\"\"></p>\n"},{"title":"个人博客绝赞内测中","subtitle":"来自hexo","desc":"现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧","date":"2015-11-29T10:29:53.000Z","author":"ngtmuzi","_content":"\n现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧","source":"_posts/个人博客绝赞内测中.md","raw":"---\ntitle: 个人博客绝赞内测中  \nsubtitle: 来自hexo  \ndesc: 现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧\ndate: 2015-11-29 18:29:53\ntags:  \nauthor: ngtmuzi  \ncategory: 随笔  \n---\n\n现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧","slug":"个人博客绝赞内测中","published":1,"updated":"2020-06-17T10:26:40.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbp000msou5eyiiba6d","content":"<p>现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧</p>\n"},{"title":"使用bash命令清理MSSQL内存","desc":"刷下博客活跃度","author":"ngtmuzi","date":"2019-07-03T08:46:59.000Z","_content":"\n首先你得在windows环境上有一个bash环境，比如 [git-bash](https://gitforwindows.org) 或 [cygwin64](https://cygwin.com/index.html)\n\n加了一个是否有活跃sql会话的判断，避免搞出问题，sql语句部分来源于热心网友\n\n```bash\n#释放mssql的内存\n. /etc/profile\n\nsessionNum=`osql -E -S . -Q \"select count(1) from sys.dm_exec_sessions where status!='sleeping'\" | sed -n 3p | tr -d [:blank:] | tr -d [:cntrl:]`\n\nif [ `expr $sessionNum` -ne 1 ]; then\n\techo \"存在正在执行的sql server会话，取消释放内存\";\n\texit 0;\nfi\n\nosql -E -S . -Q \"\nDBCC FREEPROCCACHE\nDBCC FREESESSIONCACHE\nDBCC FREESYSTEMCACHE('All')\nDBCC DROPCLEANBUFFERS\n\nUSE master\n\n-- 打开高级设置配置 \nEXEC sp_configure 'show advanced options', 1\nRECONFIGURE WITH OVERRIDE\n\n-- 先设置物理内存上限到1G \nEXEC sp_configure 'max server memory (MB)', 1024\nRECONFIGURE WITH OVERRIDE\n\"\n\nsleep 10s\n\nosql -E -S . -Q \"\n-- 还原原先的上限 \nEXEC sp_configure 'max server memory (MB)', 25600\nRECONFIGURE WITH OVERRIDE\n\"\n```\n","source":"_posts/使用bash命令清理MSSQL内存.md","raw":"---\ntitle: 使用bash命令清理MSSQL内存\ndesc: 刷下博客活跃度\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2019-07-03 16:46:59\ntags: \n- Bash\n- MSSQL\n---\n\n首先你得在windows环境上有一个bash环境，比如 [git-bash](https://gitforwindows.org) 或 [cygwin64](https://cygwin.com/index.html)\n\n加了一个是否有活跃sql会话的判断，避免搞出问题，sql语句部分来源于热心网友\n\n```bash\n#释放mssql的内存\n. /etc/profile\n\nsessionNum=`osql -E -S . -Q \"select count(1) from sys.dm_exec_sessions where status!='sleeping'\" | sed -n 3p | tr -d [:blank:] | tr -d [:cntrl:]`\n\nif [ `expr $sessionNum` -ne 1 ]; then\n\techo \"存在正在执行的sql server会话，取消释放内存\";\n\texit 0;\nfi\n\nosql -E -S . -Q \"\nDBCC FREEPROCCACHE\nDBCC FREESESSIONCACHE\nDBCC FREESYSTEMCACHE('All')\nDBCC DROPCLEANBUFFERS\n\nUSE master\n\n-- 打开高级设置配置 \nEXEC sp_configure 'show advanced options', 1\nRECONFIGURE WITH OVERRIDE\n\n-- 先设置物理内存上限到1G \nEXEC sp_configure 'max server memory (MB)', 1024\nRECONFIGURE WITH OVERRIDE\n\"\n\nsleep 10s\n\nosql -E -S . -Q \"\n-- 还原原先的上限 \nEXEC sp_configure 'max server memory (MB)', 25600\nRECONFIGURE WITH OVERRIDE\n\"\n```\n","slug":"使用bash命令清理MSSQL内存","published":1,"updated":"2020-06-17T10:26:40.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbp000nsou5712329k9","content":"<p>首先你得在windows环境上有一个bash环境，比如 <a href=\"https://gitforwindows.org\">git-bash</a> 或 <a href=\"https://cygwin.com/index.html\">cygwin64</a></p>\n<p>加了一个是否有活跃sql会话的判断，避免搞出问题，sql语句部分来源于热心网友</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#释放mssql的内存</span></span><br><span class=\"line\">. /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\">sessionNum=`osql -E -S . -Q <span class=\"string\">&quot;select count(1) from sys.dm_exec_sessions where status!=&#x27;sleeping&#x27;&quot;</span> | sed -n 3p | tr -d [:blank:] | tr -d [:cntrl:]`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ `expr <span class=\"variable\">$sessionNum</span>` -ne 1 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;存在正在执行的sql server会话，取消释放内存&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span> 0;</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">osql -E -S . -Q <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">DBCC FREEPROCCACHE</span></span><br><span class=\"line\"><span class=\"string\">DBCC FREESESSIONCACHE</span></span><br><span class=\"line\"><span class=\"string\">DBCC FREESYSTEMCACHE(&#x27;All&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">DBCC DROPCLEANBUFFERS</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">USE master</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">-- 打开高级设置配置 </span></span><br><span class=\"line\"><span class=\"string\">EXEC sp_configure &#x27;show advanced options&#x27;, 1</span></span><br><span class=\"line\"><span class=\"string\">RECONFIGURE WITH OVERRIDE</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">-- 先设置物理内存上限到1G </span></span><br><span class=\"line\"><span class=\"string\">EXEC sp_configure &#x27;max server memory (MB)&#x27;, 1024</span></span><br><span class=\"line\"><span class=\"string\">RECONFIGURE WITH OVERRIDE</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">sleep 10s</span><br><span class=\"line\"></span><br><span class=\"line\">osql -E -S . -Q <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">-- 还原原先的上限 </span></span><br><span class=\"line\"><span class=\"string\">EXEC sp_configure &#x27;max server memory (MB)&#x27;, 25600</span></span><br><span class=\"line\"><span class=\"string\">RECONFIGURE WITH OVERRIDE</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>首先你得在windows环境上有一个bash环境，比如 <a href=\"https://gitforwindows.org\">git-bash</a> 或 <a href=\"https://cygwin.com/index.html\">cygwin64</a></p>\n<p>加了一个是否有活跃sql会话的判断，避免搞出问题，sql语句部分来源于热心网友</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#释放mssql的内存</span></span><br><span class=\"line\">. /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\">sessionNum=`osql -E -S . -Q <span class=\"string\">&quot;select count(1) from sys.dm_exec_sessions where status!=&#x27;sleeping&#x27;&quot;</span> | sed -n 3p | tr -d [:blank:] | tr -d [:cntrl:]`</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ `expr <span class=\"variable\">$sessionNum</span>` -ne 1 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">&quot;存在正在执行的sql server会话，取消释放内存&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span> 0;</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">osql -E -S . -Q <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">DBCC FREEPROCCACHE</span></span><br><span class=\"line\"><span class=\"string\">DBCC FREESESSIONCACHE</span></span><br><span class=\"line\"><span class=\"string\">DBCC FREESYSTEMCACHE(&#x27;All&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">DBCC DROPCLEANBUFFERS</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">USE master</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">-- 打开高级设置配置 </span></span><br><span class=\"line\"><span class=\"string\">EXEC sp_configure &#x27;show advanced options&#x27;, 1</span></span><br><span class=\"line\"><span class=\"string\">RECONFIGURE WITH OVERRIDE</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">-- 先设置物理内存上限到1G </span></span><br><span class=\"line\"><span class=\"string\">EXEC sp_configure &#x27;max server memory (MB)&#x27;, 1024</span></span><br><span class=\"line\"><span class=\"string\">RECONFIGURE WITH OVERRIDE</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">sleep 10s</span><br><span class=\"line\"></span><br><span class=\"line\">osql -E -S . -Q <span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">-- 还原原先的上限 </span></span><br><span class=\"line\"><span class=\"string\">EXEC sp_configure &#x27;max server memory (MB)&#x27;, 25600</span></span><br><span class=\"line\"><span class=\"string\">RECONFIGURE WITH OVERRIDE</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"使用socket.io在页面上输出实时日志","desc":"类似webshell的小玩具","author":"ngtmuzi","date":"2017-04-19T12:02:57.000Z","_content":"### 需求\n\n想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会比较有用\n\n### 思路\n\n#### 来\n\n使用`tail -f`来得到实时的文件流或者用`pm2 logs`获取pm2进程的输出流，考虑为每个流加上一个`订阅id`，这样就可以实现多端同时订阅了\n\n#### 去\n\n在web页面上说到实时，自然就想到用`websocket`啦，逻辑并不复杂，客户端传来一个`订阅id`，就把它与id对应的流的`data`事件挂钩起来，这样便能将数据传递过去\n\n### 核心代码\n\n本文主要是给出一些实践的思路，所以不会有`socket.io`工作原理的说明\n\n#### 产生流\n\n使用`child_process.exec`运行子进程，该函数所返回的`stdout`属性就是一个可读流：\n\n```javascript\nconst exec = require('child_process').exec;\n//存储所有stream的集合\nconst streams = {};\n\n/**\n * 用tail -f读文件\n * @param file\n * @return id\n */\nfunction watchFile(file) {\n  return watchProcess(`tail -f ${file}`);\n}\n\n/**\n * 自定义的命令行，比如pm2 logs 0\n * @param cmd\n * @return id\n */\nfunction watchProcess(cmd) {\n  return watchStream(exec(cmd).stdout);\n}\n\n/**\n * 对流做一些额外处理\n * @param stream\n * @return id\n */\nfunction watchStream(stream) {\n  const id     = Date.now();\n  streams[id]  = stream;\n  stream._buff = '';\n\n  //处理流的data事件，使其按行(\\n结尾)来触发自定义的line事件\n  stream.on('data', data => {\n    stream._buff += data;\n    let lines    = stream._buff.split('\\n');\n    stream._buff = lines.pop();\n    lines.forEach(line => stream.emit('line', line));\n  });\n}\n```\n\n#### 将流与socket.io订阅绑定\n```javascript\n  const io = SocketIO(httpServer);\n\n  io.on('connection', function (socket) {\n    socket.on('sub', function (id) {\n      if (!streams[id]) return socket.emit('line', `该订阅id不存在: ${id}`);\n\n      //管道函数，收到流的line事件则将控制台的ansi格式内容转成html格式然后触发客户端的line事件\n      const pipe = line => socket.emit('line', ansiHTML(line));\n\n      //订阅流的line事件\n      streams[id].on('line', pipe);\n    });\n  });\n```\n\n#### 前端订阅id\n```javascript\n  var socket = io.connect();\n  socket.on('line', function (data) {\n    app.rawLines.push(data);\n    if (app.rawLines.length > 2000) app.rawLines.splice(0, app.rawLines.length - 2000); //行数上限设为2000\n  });\n\n  socket.on('connect', function () {\n    console.log('connect succeed');\n\n    socket.emit('sub', 'time');//根据各种业务逻辑拿到一个订阅id并订阅\n  });\n```\n\n前端页面为了方便渲染非常多行的元素，使用的是vue，代码就不贴了，最终效果如下\n\n![](/img/webshell_1.png)\n\n### 总结\n\n这个东西功能接近于webshell了，最起码输出是可以显示了，再加个输入的接口就可以远程执行命令了，这里要提醒下允许远程执行命令是 **非常危险** 的。\n\n主要的是思路，代码本身并不难，[demo已上传github](https://github.com/ngtmuzi/webshell-demo)，由于是demo，各种错误捕获和回收处理都不完善，这个还请自己研究了~\n\n### 2017-06-14补充\n\n监听逐行输出可以直接使用Node自带的`readline`模块，示例代码已更新","source":"_posts/使用socket-io在页面上输出实时日志.md","raw":"---\ntitle: 使用socket.io在页面上输出实时日志    \ndesc: 类似webshell的小玩具  \nauthor: ngtmuzi  \ncategory: 班门弄斧  \ndate: 2017-04-19 20:02:57  \ntags: \n- nodejs\n- socket.io\n\n---\n### 需求\n\n想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会比较有用\n\n### 思路\n\n#### 来\n\n使用`tail -f`来得到实时的文件流或者用`pm2 logs`获取pm2进程的输出流，考虑为每个流加上一个`订阅id`，这样就可以实现多端同时订阅了\n\n#### 去\n\n在web页面上说到实时，自然就想到用`websocket`啦，逻辑并不复杂，客户端传来一个`订阅id`，就把它与id对应的流的`data`事件挂钩起来，这样便能将数据传递过去\n\n### 核心代码\n\n本文主要是给出一些实践的思路，所以不会有`socket.io`工作原理的说明\n\n#### 产生流\n\n使用`child_process.exec`运行子进程，该函数所返回的`stdout`属性就是一个可读流：\n\n```javascript\nconst exec = require('child_process').exec;\n//存储所有stream的集合\nconst streams = {};\n\n/**\n * 用tail -f读文件\n * @param file\n * @return id\n */\nfunction watchFile(file) {\n  return watchProcess(`tail -f ${file}`);\n}\n\n/**\n * 自定义的命令行，比如pm2 logs 0\n * @param cmd\n * @return id\n */\nfunction watchProcess(cmd) {\n  return watchStream(exec(cmd).stdout);\n}\n\n/**\n * 对流做一些额外处理\n * @param stream\n * @return id\n */\nfunction watchStream(stream) {\n  const id     = Date.now();\n  streams[id]  = stream;\n  stream._buff = '';\n\n  //处理流的data事件，使其按行(\\n结尾)来触发自定义的line事件\n  stream.on('data', data => {\n    stream._buff += data;\n    let lines    = stream._buff.split('\\n');\n    stream._buff = lines.pop();\n    lines.forEach(line => stream.emit('line', line));\n  });\n}\n```\n\n#### 将流与socket.io订阅绑定\n```javascript\n  const io = SocketIO(httpServer);\n\n  io.on('connection', function (socket) {\n    socket.on('sub', function (id) {\n      if (!streams[id]) return socket.emit('line', `该订阅id不存在: ${id}`);\n\n      //管道函数，收到流的line事件则将控制台的ansi格式内容转成html格式然后触发客户端的line事件\n      const pipe = line => socket.emit('line', ansiHTML(line));\n\n      //订阅流的line事件\n      streams[id].on('line', pipe);\n    });\n  });\n```\n\n#### 前端订阅id\n```javascript\n  var socket = io.connect();\n  socket.on('line', function (data) {\n    app.rawLines.push(data);\n    if (app.rawLines.length > 2000) app.rawLines.splice(0, app.rawLines.length - 2000); //行数上限设为2000\n  });\n\n  socket.on('connect', function () {\n    console.log('connect succeed');\n\n    socket.emit('sub', 'time');//根据各种业务逻辑拿到一个订阅id并订阅\n  });\n```\n\n前端页面为了方便渲染非常多行的元素，使用的是vue，代码就不贴了，最终效果如下\n\n![](/img/webshell_1.png)\n\n### 总结\n\n这个东西功能接近于webshell了，最起码输出是可以显示了，再加个输入的接口就可以远程执行命令了，这里要提醒下允许远程执行命令是 **非常危险** 的。\n\n主要的是思路，代码本身并不难，[demo已上传github](https://github.com/ngtmuzi/webshell-demo)，由于是demo，各种错误捕获和回收处理都不完善，这个还请自己研究了~\n\n### 2017-06-14补充\n\n监听逐行输出可以直接使用Node自带的`readline`模块，示例代码已更新","slug":"使用socket-io在页面上输出实时日志","published":1,"updated":"2020-06-17T10:26:40.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbq000osou53snt1l9f","content":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会比较有用</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"来\"><a href=\"#来\" class=\"headerlink\" title=\"来\"></a>来</h4><p>使用<code>tail -f</code>来得到实时的文件流或者用<code>pm2 logs</code>获取pm2进程的输出流，考虑为每个流加上一个<code>订阅id</code>，这样就可以实现多端同时订阅了</p>\n<h4 id=\"去\"><a href=\"#去\" class=\"headerlink\" title=\"去\"></a>去</h4><p>在web页面上说到实时，自然就想到用<code>websocket</code>啦，逻辑并不复杂，客户端传来一个<code>订阅id</code>，就把它与id对应的流的<code>data</code>事件挂钩起来，这样便能将数据传递过去</p>\n<h3 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h3><p>本文主要是给出一些实践的思路，所以不会有<code>socket.io</code>工作原理的说明</p>\n<h4 id=\"产生流\"><a href=\"#产生流\" class=\"headerlink\" title=\"产生流\"></a>产生流</h4><p>使用<code>child_process.exec</code>运行子进程，该函数所返回的<code>stdout</code>属性就是一个可读流：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>).exec;</span><br><span class=\"line\"><span class=\"comment\">//存储所有stream的集合</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> streams = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用tail -f读文件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">file</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"variable\">id</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchFile</span>(<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> watchProcess(<span class=\"string\">`tail -f <span class=\"subst\">$&#123;file&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义的命令行，比如pm2 logs 0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">cmd</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"variable\">id</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchProcess</span>(<span class=\"params\">cmd</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> watchStream(exec(cmd).stdout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对流做一些额外处理</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">stream</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"variable\">id</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchStream</span>(<span class=\"params\">stream</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> id     = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  streams[id]  = stream;</span><br><span class=\"line\">  stream._buff = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//处理流的data事件，使其按行(\\n结尾)来触发自定义的line事件</span></span><br><span class=\"line\">  stream.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    stream._buff += data;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines    = stream._buff.split(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">    stream._buff = lines.pop();</span><br><span class=\"line\">    lines.forEach(<span class=\"function\"><span class=\"params\">line</span> =&gt;</span> stream.emit(<span class=\"string\">&#x27;line&#x27;</span>, line));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"将流与socket-io订阅绑定\"><a href=\"#将流与socket-io订阅绑定\" class=\"headerlink\" title=\"将流与socket.io订阅绑定\"></a>将流与socket.io订阅绑定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = SocketIO(httpServer);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">&#x27;sub&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!streams[id]) <span class=\"keyword\">return</span> socket.emit(<span class=\"string\">&#x27;line&#x27;</span>, <span class=\"string\">`该订阅id不存在: <span class=\"subst\">$&#123;id&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//管道函数，收到流的line事件则将控制台的ansi格式内容转成html格式然后触发客户端的line事件</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pipe = <span class=\"function\"><span class=\"params\">line</span> =&gt;</span> socket.emit(<span class=\"string\">&#x27;line&#x27;</span>, ansiHTML(line));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//订阅流的line事件</span></span><br><span class=\"line\">    streams[id].on(<span class=\"string\">&#x27;line&#x27;</span>, pipe);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"前端订阅id\"><a href=\"#前端订阅id\" class=\"headerlink\" title=\"前端订阅id\"></a>前端订阅id</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = io.connect();</span><br><span class=\"line\">socket.on(<span class=\"string\">&#x27;line&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  app.rawLines.push(data);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (app.rawLines.length &gt; <span class=\"number\">2000</span>) app.rawLines.splice(<span class=\"number\">0</span>, app.rawLines.length - <span class=\"number\">2000</span>); <span class=\"comment\">//行数上限设为2000</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">&#x27;connect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;connect succeed&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.emit(<span class=\"string\">&#x27;sub&#x27;</span>, <span class=\"string\">&#x27;time&#x27;</span>);<span class=\"comment\">//根据各种业务逻辑拿到一个订阅id并订阅</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>前端页面为了方便渲染非常多行的元素，使用的是vue，代码就不贴了，最终效果如下</p>\n<p><img src=\"/img/webshell_1.png\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这个东西功能接近于webshell了，最起码输出是可以显示了，再加个输入的接口就可以远程执行命令了，这里要提醒下允许远程执行命令是 <strong>非常危险</strong> 的。</p>\n<p>主要的是思路，代码本身并不难，<a href=\"https://github.com/ngtmuzi/webshell-demo\">demo已上传github</a>，由于是demo，各种错误捕获和回收处理都不完善，这个还请自己研究了~</p>\n<h3 id=\"2017-06-14补充\"><a href=\"#2017-06-14补充\" class=\"headerlink\" title=\"2017-06-14补充\"></a>2017-06-14补充</h3><p>监听逐行输出可以直接使用Node自带的<code>readline</code>模块，示例代码已更新</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>想在管理页面上看到日志文件/进程的实时输出日志，这对于某些不能直接ssh登录服务器，又没有良好的日志工具，或者单纯只是想检查运行输出的场景会比较有用</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"来\"><a href=\"#来\" class=\"headerlink\" title=\"来\"></a>来</h4><p>使用<code>tail -f</code>来得到实时的文件流或者用<code>pm2 logs</code>获取pm2进程的输出流，考虑为每个流加上一个<code>订阅id</code>，这样就可以实现多端同时订阅了</p>\n<h4 id=\"去\"><a href=\"#去\" class=\"headerlink\" title=\"去\"></a>去</h4><p>在web页面上说到实时，自然就想到用<code>websocket</code>啦，逻辑并不复杂，客户端传来一个<code>订阅id</code>，就把它与id对应的流的<code>data</code>事件挂钩起来，这样便能将数据传递过去</p>\n<h3 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h3><p>本文主要是给出一些实践的思路，所以不会有<code>socket.io</code>工作原理的说明</p>\n<h4 id=\"产生流\"><a href=\"#产生流\" class=\"headerlink\" title=\"产生流\"></a>产生流</h4><p>使用<code>child_process.exec</code>运行子进程，该函数所返回的<code>stdout</code>属性就是一个可读流：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>).exec;</span><br><span class=\"line\"><span class=\"comment\">//存储所有stream的集合</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> streams = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用tail -f读文件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">file</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"variable\">id</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchFile</span>(<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> watchProcess(<span class=\"string\">`tail -f <span class=\"subst\">$&#123;file&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义的命令行，比如pm2 logs 0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">cmd</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"variable\">id</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchProcess</span>(<span class=\"params\">cmd</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> watchStream(exec(cmd).stdout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对流做一些额外处理</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">stream</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"variable\">id</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watchStream</span>(<span class=\"params\">stream</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> id     = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  streams[id]  = stream;</span><br><span class=\"line\">  stream._buff = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//处理流的data事件，使其按行(\\n结尾)来触发自定义的line事件</span></span><br><span class=\"line\">  stream.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    stream._buff += data;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines    = stream._buff.split(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">    stream._buff = lines.pop();</span><br><span class=\"line\">    lines.forEach(<span class=\"function\"><span class=\"params\">line</span> =&gt;</span> stream.emit(<span class=\"string\">&#x27;line&#x27;</span>, line));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"将流与socket-io订阅绑定\"><a href=\"#将流与socket-io订阅绑定\" class=\"headerlink\" title=\"将流与socket.io订阅绑定\"></a>将流与socket.io订阅绑定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = SocketIO(httpServer);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">&#x27;sub&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!streams[id]) <span class=\"keyword\">return</span> socket.emit(<span class=\"string\">&#x27;line&#x27;</span>, <span class=\"string\">`该订阅id不存在: <span class=\"subst\">$&#123;id&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//管道函数，收到流的line事件则将控制台的ansi格式内容转成html格式然后触发客户端的line事件</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pipe = <span class=\"function\"><span class=\"params\">line</span> =&gt;</span> socket.emit(<span class=\"string\">&#x27;line&#x27;</span>, ansiHTML(line));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//订阅流的line事件</span></span><br><span class=\"line\">    streams[id].on(<span class=\"string\">&#x27;line&#x27;</span>, pipe);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"前端订阅id\"><a href=\"#前端订阅id\" class=\"headerlink\" title=\"前端订阅id\"></a>前端订阅id</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = io.connect();</span><br><span class=\"line\">socket.on(<span class=\"string\">&#x27;line&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  app.rawLines.push(data);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (app.rawLines.length &gt; <span class=\"number\">2000</span>) app.rawLines.splice(<span class=\"number\">0</span>, app.rawLines.length - <span class=\"number\">2000</span>); <span class=\"comment\">//行数上限设为2000</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">&#x27;connect&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;connect succeed&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.emit(<span class=\"string\">&#x27;sub&#x27;</span>, <span class=\"string\">&#x27;time&#x27;</span>);<span class=\"comment\">//根据各种业务逻辑拿到一个订阅id并订阅</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>前端页面为了方便渲染非常多行的元素，使用的是vue，代码就不贴了，最终效果如下</p>\n<p><img src=\"/img/webshell_1.png\" alt=\"\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这个东西功能接近于webshell了，最起码输出是可以显示了，再加个输入的接口就可以远程执行命令了，这里要提醒下允许远程执行命令是 <strong>非常危险</strong> 的。</p>\n<p>主要的是思路，代码本身并不难，<a href=\"https://github.com/ngtmuzi/webshell-demo\">demo已上传github</a>，由于是demo，各种错误捕获和回收处理都不完善，这个还请自己研究了~</p>\n<h3 id=\"2017-06-14补充\"><a href=\"#2017-06-14补充\" class=\"headerlink\" title=\"2017-06-14补充\"></a>2017-06-14补充</h3><p>监听逐行输出可以直接使用Node自带的<code>readline</code>模块，示例代码已更新</p>\n"},{"title":"博客迁移到hexo","date":"2017-01-22T08:56:56.000Z","author":"ngtmuzi","_content":"\n博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~","source":"_posts/博客迁移到hexo.md","raw":"---\ntitle: 博客迁移到hexo\ndate: 2017-01-22 16:56:56\ncategory: 随笔\nauthor: ngtmuzi\n---\n\n博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~","slug":"博客迁移到hexo","published":1,"updated":"2020-06-17T10:26:40.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbq000psou50i9wf1be","content":"<p>博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~</p>\n"},{"title":"在前端确认框上套用Promise","desc":"jquery + bootstrap环境","author":"ngtmuzi","date":"2017-04-01T07:08:32.000Z","_content":"```javascript\n//jquery + bootstrap\nfunction askDlg(title, content) {\n  return new Promise(function (resolve, reject) {\n    $('#ask-title').text(title || '确认操作');\n    $('#ask-content').text(content || '确认操作吗？');\n\n    $('#ask-btn-yes').one('click', function () {\n      resolve();\n      $('#ask-dlg').modal('hide');\n    });\n\n    $('#ask-dlg').modal('show').one('hidden.bs.modal', reject);\n  });\n}\n```","source":"_posts/在前端确认框上套用Promise.md","raw":"---\ntitle: 在前端确认框上套用Promise\ndesc: jquery + bootstrap环境\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2017-04-01 15:08:32\ntags:\n- Promise\n- javaScript\n- 前端\n---\n```javascript\n//jquery + bootstrap\nfunction askDlg(title, content) {\n  return new Promise(function (resolve, reject) {\n    $('#ask-title').text(title || '确认操作');\n    $('#ask-content').text(content || '确认操作吗？');\n\n    $('#ask-btn-yes').one('click', function () {\n      resolve();\n      $('#ask-dlg').modal('hide');\n    });\n\n    $('#ask-dlg').modal('show').one('hidden.bs.modal', reject);\n  });\n}\n```","slug":"在前端确认框上套用Promise","published":1,"updated":"2020-06-17T10:26:40.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbr000qsou5ff1xg9vl","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jquery + bootstrap</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">askDlg</span>(<span class=\"params\">title, content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;#ask-title&#x27;</span>).text(title || <span class=\"string\">&#x27;确认操作&#x27;</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;#ask-content&#x27;</span>).text(content || <span class=\"string\">&#x27;确认操作吗？&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    $(<span class=\"string\">&#x27;#ask-btn-yes&#x27;</span>).one(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">      $(<span class=\"string\">&#x27;#ask-dlg&#x27;</span>).modal(<span class=\"string\">&#x27;hide&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    $(<span class=\"string\">&#x27;#ask-dlg&#x27;</span>).modal(<span class=\"string\">&#x27;show&#x27;</span>).one(<span class=\"string\">&#x27;hidden.bs.modal&#x27;</span>, reject);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jquery + bootstrap</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">askDlg</span>(<span class=\"params\">title, content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;#ask-title&#x27;</span>).text(title || <span class=\"string\">&#x27;确认操作&#x27;</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;#ask-content&#x27;</span>).text(content || <span class=\"string\">&#x27;确认操作吗？&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    $(<span class=\"string\">&#x27;#ask-btn-yes&#x27;</span>).one(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">      $(<span class=\"string\">&#x27;#ask-dlg&#x27;</span>).modal(<span class=\"string\">&#x27;hide&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    $(<span class=\"string\">&#x27;#ask-dlg&#x27;</span>).modal(<span class=\"string\">&#x27;show&#x27;</span>).one(<span class=\"string\">&#x27;hidden.bs.modal&#x27;</span>, reject);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"实现一个嵌套对象式的路由中间件","desc":"后端只要增删改查就行了……","author":"ngtmuzi","date":"2018-06-15T08:17:52.000Z","_content":"## 起因\n不喜欢命令式地一行行声明路由和处理函数，也觉得`koa`栈的各类路由中间件不好用，所以就想着自己做个玩\n## 设计\n### 对象路径=路由路径，无next逻辑\n这个中间件的定位相当于最终路由，不支持内部的多层next的结构（但有提供框架本身的next参数），也不考虑RESTful的实现，所以代码还是挺简单的（要实现RESTful可以在处理函数内自己加判断，或者多做一层代理）\n### msg=路由参数+query+body\n所有参数都从msg一个对象里取，类似`ASP.NET`的做法，在大多数情况下能方便开发，当然要想分别从不同地方取也是可以的\n### 接受异步返回(promise)\n得益于Node8.0+的`async/await`特性支持，我们终于可以写优雅的异步代码了（`koa`自身支持，不过`express`还是要加点处理）\n### 统一的输出控制/错误捕获层\n大多数项目都会想要一个统一的输出/错误处理层，所以提供了这个逻辑\n### 支持路由参数\n参考了`express`的实现代码引入`path-to-regexp`模块，可以写一些很cool的路由了\n### koa与express都支持\n代码暂时还是分开维护的，毕竟两个框架实现上还是有很大不同\n## 总结\n反正我在生产环境用了挺久的，具体用法可以参考下面的链接\n## 链接\n[Github-nRouter](https://github.com/ngtmuzi/nRouter)  \n暂时没有发布npm的打算（写英文好累的）","source":"_posts/实现一个嵌套对象式的路由中间件.md","raw":"---\ntitle: 实现一个嵌套对象式的路由中间件\ndesc: 后端只要增删改查就行了……\nauthor: ngtmuzi\ncategory: 班门弄斧\ndate: 2018-06-15 16:17:52\ntags: \n- nodejs\n- koa\n- express\n---\n## 起因\n不喜欢命令式地一行行声明路由和处理函数，也觉得`koa`栈的各类路由中间件不好用，所以就想着自己做个玩\n## 设计\n### 对象路径=路由路径，无next逻辑\n这个中间件的定位相当于最终路由，不支持内部的多层next的结构（但有提供框架本身的next参数），也不考虑RESTful的实现，所以代码还是挺简单的（要实现RESTful可以在处理函数内自己加判断，或者多做一层代理）\n### msg=路由参数+query+body\n所有参数都从msg一个对象里取，类似`ASP.NET`的做法，在大多数情况下能方便开发，当然要想分别从不同地方取也是可以的\n### 接受异步返回(promise)\n得益于Node8.0+的`async/await`特性支持，我们终于可以写优雅的异步代码了（`koa`自身支持，不过`express`还是要加点处理）\n### 统一的输出控制/错误捕获层\n大多数项目都会想要一个统一的输出/错误处理层，所以提供了这个逻辑\n### 支持路由参数\n参考了`express`的实现代码引入`path-to-regexp`模块，可以写一些很cool的路由了\n### koa与express都支持\n代码暂时还是分开维护的，毕竟两个框架实现上还是有很大不同\n## 总结\n反正我在生产环境用了挺久的，具体用法可以参考下面的链接\n## 链接\n[Github-nRouter](https://github.com/ngtmuzi/nRouter)  \n暂时没有发布npm的打算（写英文好累的）","slug":"实现一个嵌套对象式的路由中间件","published":1,"updated":"2020-06-17T10:26:40.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbr000rsou53z4odx8e","content":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>不喜欢命令式地一行行声明路由和处理函数，也觉得<code>koa</code>栈的各类路由中间件不好用，所以就想着自己做个玩</p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><h3 id=\"对象路径-路由路径，无next逻辑\"><a href=\"#对象路径-路由路径，无next逻辑\" class=\"headerlink\" title=\"对象路径=路由路径，无next逻辑\"></a>对象路径=路由路径，无next逻辑</h3><p>这个中间件的定位相当于最终路由，不支持内部的多层next的结构（但有提供框架本身的next参数），也不考虑RESTful的实现，所以代码还是挺简单的（要实现RESTful可以在处理函数内自己加判断，或者多做一层代理）</p>\n<h3 id=\"msg-路由参数-query-body\"><a href=\"#msg-路由参数-query-body\" class=\"headerlink\" title=\"msg=路由参数+query+body\"></a>msg=路由参数+query+body</h3><p>所有参数都从msg一个对象里取，类似<code>ASP.NET</code>的做法，在大多数情况下能方便开发，当然要想分别从不同地方取也是可以的</p>\n<h3 id=\"接受异步返回-promise\"><a href=\"#接受异步返回-promise\" class=\"headerlink\" title=\"接受异步返回(promise)\"></a>接受异步返回(promise)</h3><p>得益于Node8.0+的<code>async/await</code>特性支持，我们终于可以写优雅的异步代码了（<code>koa</code>自身支持，不过<code>express</code>还是要加点处理）</p>\n<h3 id=\"统一的输出控制-错误捕获层\"><a href=\"#统一的输出控制-错误捕获层\" class=\"headerlink\" title=\"统一的输出控制/错误捕获层\"></a>统一的输出控制/错误捕获层</h3><p>大多数项目都会想要一个统一的输出/错误处理层，所以提供了这个逻辑</p>\n<h3 id=\"支持路由参数\"><a href=\"#支持路由参数\" class=\"headerlink\" title=\"支持路由参数\"></a>支持路由参数</h3><p>参考了<code>express</code>的实现代码引入<code>path-to-regexp</code>模块，可以写一些很cool的路由了</p>\n<h3 id=\"koa与express都支持\"><a href=\"#koa与express都支持\" class=\"headerlink\" title=\"koa与express都支持\"></a>koa与express都支持</h3><p>代码暂时还是分开维护的，毕竟两个框架实现上还是有很大不同</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>反正我在生产环境用了挺久的，具体用法可以参考下面的链接</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://github.com/ngtmuzi/nRouter\">Github-nRouter</a><br>暂时没有发布npm的打算（写英文好累的）</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>不喜欢命令式地一行行声明路由和处理函数，也觉得<code>koa</code>栈的各类路由中间件不好用，所以就想着自己做个玩</p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><h3 id=\"对象路径-路由路径，无next逻辑\"><a href=\"#对象路径-路由路径，无next逻辑\" class=\"headerlink\" title=\"对象路径=路由路径，无next逻辑\"></a>对象路径=路由路径，无next逻辑</h3><p>这个中间件的定位相当于最终路由，不支持内部的多层next的结构（但有提供框架本身的next参数），也不考虑RESTful的实现，所以代码还是挺简单的（要实现RESTful可以在处理函数内自己加判断，或者多做一层代理）</p>\n<h3 id=\"msg-路由参数-query-body\"><a href=\"#msg-路由参数-query-body\" class=\"headerlink\" title=\"msg=路由参数+query+body\"></a>msg=路由参数+query+body</h3><p>所有参数都从msg一个对象里取，类似<code>ASP.NET</code>的做法，在大多数情况下能方便开发，当然要想分别从不同地方取也是可以的</p>\n<h3 id=\"接受异步返回-promise\"><a href=\"#接受异步返回-promise\" class=\"headerlink\" title=\"接受异步返回(promise)\"></a>接受异步返回(promise)</h3><p>得益于Node8.0+的<code>async/await</code>特性支持，我们终于可以写优雅的异步代码了（<code>koa</code>自身支持，不过<code>express</code>还是要加点处理）</p>\n<h3 id=\"统一的输出控制-错误捕获层\"><a href=\"#统一的输出控制-错误捕获层\" class=\"headerlink\" title=\"统一的输出控制/错误捕获层\"></a>统一的输出控制/错误捕获层</h3><p>大多数项目都会想要一个统一的输出/错误处理层，所以提供了这个逻辑</p>\n<h3 id=\"支持路由参数\"><a href=\"#支持路由参数\" class=\"headerlink\" title=\"支持路由参数\"></a>支持路由参数</h3><p>参考了<code>express</code>的实现代码引入<code>path-to-regexp</code>模块，可以写一些很cool的路由了</p>\n<h3 id=\"koa与express都支持\"><a href=\"#koa与express都支持\" class=\"headerlink\" title=\"koa与express都支持\"></a>koa与express都支持</h3><p>代码暂时还是分开维护的，毕竟两个框架实现上还是有很大不同</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>反正我在生产环境用了挺久的，具体用法可以参考下面的链接</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://github.com/ngtmuzi/nRouter\">Github-nRouter</a><br>暂时没有发布npm的打算（写英文好累的）</p>\n"},{"title":"实现一个简单的Promise队列","desc":"Promise本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。","date":"2017-06-21T14:00:00.000Z","author":"ngtmuzi","_content":"\n*原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00*\n\n## 需求\n\n来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。\n\n很直观的改进方案就是用队列，系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是Promise写的，做流程控制好歹比callback简单多了\n\n## 思路\n\n* `Promise`本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。\n\n* 队列本身要有节流功能，即可以控制同一时间内在运行的`Promise`数量，参考`bluebird`的`map`函数中的concurrency(并发)字段。\n\n## 实现\n\n比较核心的代码简化起来就这一段：\n```javascript\n  function add(fn) {\n    return new Promise((resolve, reject) => {\n      this.queue.push(() =>\n        Promise.resolve()\n          .then(fn)\n          .then(resolve, reject)\n      );\n    });\n  }\n```\n\n可以看到我们是往`queue`队列里加入了一个函数，这个函数包裹了原函数`fn`，将它执行的同步或者异步的结果传给外层的`Promise`，这样对外表现就还是一个`Promise`，这个函数进入队列，等待轮到它执行的时机\n\n之后就是在内部维护一个“正在运行的任务数量”，在`fn`运行前后做加减和判断，就可以控制并行数了\n  \n完整代码：[np-queue](https://github.com/ngtmuzi/np-queue)  \n\n运行起来的感觉类似这样\n\n```javascript\nconst q = new Queue();\nconst delay = (value) =>  \n  new Promise(resolve => {\n    setTimeout(() => resolve(value), 1000);  \n  });\n\nq.add(()=>delay(1)).then(console.log);\nq.add(()=>delay(2)).then(console.log);\n\nconst delay_wrap = q.wrap(delay);\n\ndelay_wrap(3).then(console.log);\ndelay_wrap(4).then(console.log);\n```\n\n默认并发数是1，因此代码会相隔1秒依次输出`1,2,3,4`\n\n放到业务代码上，原代码是`delay().then(...)`，现在改为`q.add(delay).then(...)`，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解\n\n再配合`wrap()`方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：\n```javascript\nconst wrapFn = function () {\n  return queue.add(fn.bind(thisArg, ...arguments));\n};\n```\n原代码为`delay(a,b).then(...)`我们可以改为`delay_wrap(a,b).then(...)`，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。","source":"_posts/实现一个简单的promise队列.md","raw":"---\ntitle: 实现一个简单的Promise队列\ndesc: Promise本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。  \ndate: 2017-6-21 22:00:00.000  \ntags: \n- javascript\n- Promise\n- ES6\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n\n*原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00*\n\n## 需求\n\n来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。\n\n很直观的改进方案就是用队列，系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是Promise写的，做流程控制好歹比callback简单多了\n\n## 思路\n\n* `Promise`本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。\n\n* 队列本身要有节流功能，即可以控制同一时间内在运行的`Promise`数量，参考`bluebird`的`map`函数中的concurrency(并发)字段。\n\n## 实现\n\n比较核心的代码简化起来就这一段：\n```javascript\n  function add(fn) {\n    return new Promise((resolve, reject) => {\n      this.queue.push(() =>\n        Promise.resolve()\n          .then(fn)\n          .then(resolve, reject)\n      );\n    });\n  }\n```\n\n可以看到我们是往`queue`队列里加入了一个函数，这个函数包裹了原函数`fn`，将它执行的同步或者异步的结果传给外层的`Promise`，这样对外表现就还是一个`Promise`，这个函数进入队列，等待轮到它执行的时机\n\n之后就是在内部维护一个“正在运行的任务数量”，在`fn`运行前后做加减和判断，就可以控制并行数了\n  \n完整代码：[np-queue](https://github.com/ngtmuzi/np-queue)  \n\n运行起来的感觉类似这样\n\n```javascript\nconst q = new Queue();\nconst delay = (value) =>  \n  new Promise(resolve => {\n    setTimeout(() => resolve(value), 1000);  \n  });\n\nq.add(()=>delay(1)).then(console.log);\nq.add(()=>delay(2)).then(console.log);\n\nconst delay_wrap = q.wrap(delay);\n\ndelay_wrap(3).then(console.log);\ndelay_wrap(4).then(console.log);\n```\n\n默认并发数是1，因此代码会相隔1秒依次输出`1,2,3,4`\n\n放到业务代码上，原代码是`delay().then(...)`，现在改为`q.add(delay).then(...)`，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解\n\n再配合`wrap()`方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：\n```javascript\nconst wrapFn = function () {\n  return queue.add(fn.bind(thisArg, ...arguments));\n};\n```\n原代码为`delay(a,b).then(...)`我们可以改为`delay_wrap(a,b).then(...)`，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。","slug":"实现一个简单的promise队列","published":1,"updated":"2020-06-17T10:26:40.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbr000ssou51bvo3663","content":"<p><em>原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00</em></p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。</p>\n<p>很直观的改进方案就是用队列，系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是Promise写的，做流程控制好歹比callback简单多了</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ul>\n<li><p><code>Promise</code>本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。</p>\n</li>\n<li><p>队列本身要有节流功能，即可以控制同一时间内在运行的<code>Promise</code>数量，参考<code>bluebird</code>的<code>map</code>函数中的concurrency(并发)字段。</p>\n</li>\n</ul>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>比较核心的代码简化起来就这一段：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.queue.push(<span class=\"function\">() =&gt;</span></span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve()</span><br><span class=\"line\">        .then(fn)</span><br><span class=\"line\">        .then(resolve, reject)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到我们是往<code>queue</code>队列里加入了一个函数，这个函数包裹了原函数<code>fn</code>，将它执行的同步或者异步的结果传给外层的<code>Promise</code>，这样对外表现就还是一个<code>Promise</code>，这个函数进入队列，等待轮到它执行的时机</p>\n<p>之后就是在内部维护一个“正在运行的任务数量”，在<code>fn</code>运行前后做加减和判断，就可以控制并行数了</p>\n<p>完整代码：<a href=\"https://github.com/ngtmuzi/np-queue\">np-queue</a>  </p>\n<p>运行起来的感觉类似这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> q = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span>  </span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> resolve(value), <span class=\"number\">1000</span>);  </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">q.add(<span class=\"function\">()=&gt;</span>delay(<span class=\"number\">1</span>)).then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\">q.add(<span class=\"function\">()=&gt;</span>delay(<span class=\"number\">2</span>)).then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> delay_wrap = q.wrap(delay);</span><br><span class=\"line\"></span><br><span class=\"line\">delay_wrap(<span class=\"number\">3</span>).then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\">delay_wrap(<span class=\"number\">4</span>).then(<span class=\"built_in\">console</span>.log);</span><br></pre></td></tr></table></figure>\n<p>默认并发数是1，因此代码会相隔1秒依次输出<code>1,2,3,4</code></p>\n<p>放到业务代码上，原代码是<code>delay().then(...)</code>，现在改为<code>q.add(delay).then(...)</code>，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解</p>\n<p>再配合<code>wrap()</code>方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wrapFn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> queue.add(fn.bind(thisArg, ...arguments));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>原代码为<code>delay(a,b).then(...)</code>我们可以改为<code>delay_wrap(a,b).then(...)</code>，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>原博客创建于 2016-9-18 22:34:48， 更新于 2017-6-21 22:00:00</em></p>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。</p>\n<p>很直观的改进方案就是用队列，系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是Promise写的，做流程控制好歹比callback简单多了</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ul>\n<li><p><code>Promise</code>本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。</p>\n</li>\n<li><p>队列本身要有节流功能，即可以控制同一时间内在运行的<code>Promise</code>数量，参考<code>bluebird</code>的<code>map</code>函数中的concurrency(并发)字段。</p>\n</li>\n</ul>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>比较核心的代码简化起来就这一段：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.queue.push(<span class=\"function\">() =&gt;</span></span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve()</span><br><span class=\"line\">        .then(fn)</span><br><span class=\"line\">        .then(resolve, reject)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到我们是往<code>queue</code>队列里加入了一个函数，这个函数包裹了原函数<code>fn</code>，将它执行的同步或者异步的结果传给外层的<code>Promise</code>，这样对外表现就还是一个<code>Promise</code>，这个函数进入队列，等待轮到它执行的时机</p>\n<p>之后就是在内部维护一个“正在运行的任务数量”，在<code>fn</code>运行前后做加减和判断，就可以控制并行数了</p>\n<p>完整代码：<a href=\"https://github.com/ngtmuzi/np-queue\">np-queue</a>  </p>\n<p>运行起来的感觉类似这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> q = <span class=\"keyword\">new</span> Queue();</span><br><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span>  </span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> resolve(value), <span class=\"number\">1000</span>);  </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">q.add(<span class=\"function\">()=&gt;</span>delay(<span class=\"number\">1</span>)).then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\">q.add(<span class=\"function\">()=&gt;</span>delay(<span class=\"number\">2</span>)).then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> delay_wrap = q.wrap(delay);</span><br><span class=\"line\"></span><br><span class=\"line\">delay_wrap(<span class=\"number\">3</span>).then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\">delay_wrap(<span class=\"number\">4</span>).then(<span class=\"built_in\">console</span>.log);</span><br></pre></td></tr></table></figure>\n<p>默认并发数是1，因此代码会相隔1秒依次输出<code>1,2,3,4</code></p>\n<p>放到业务代码上，原代码是<code>delay().then(...)</code>，现在改为<code>q.add(delay).then(...)</code>，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解</p>\n<p>再配合<code>wrap()</code>方法我们能更透明地完成这件事，它直接给一个函数提供了一层包装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wrapFn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> queue.add(fn.bind(thisArg, ...arguments));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>原代码为<code>delay(a,b).then(...)</code>我们可以改为<code>delay_wrap(a,b).then(...)</code>，参数都不用改，透明地加了一层控制并发的逻辑，感觉很好。</p>\n"},{"title":"屏蔽参数中的敏感字段","desc":"难得能写些有趣的代码","author":"ngtmuzi","date":"2017-04-01T07:14:31.000Z","_content":"```javascript\nconst pwdFields = ['password','pwd'];\n\nfunction filterPwdField(obj) {\n  return lodash.mapValues(obj, (value, key) => {\n    if (lodash.isPlainObject(value))\n      return filterPwdField(value);\n\n    if (typeof  value === 'string') {\n      if (pwdFields.some(field => value.toLowerCase().includes(field.toLowerCase()))) { //屏蔽类似password=xxxxx的字符串\n        pwdFields.forEach(field =>\n          value = value.replace(new RegExp(`(${field})=(.+?)(&|$)`, 'gi'), (match, $1, $2, $3) =>\n            `${$1}=${$2.slice(0, -5) + '*****'}${$3 || ''}`\n          ));\n      }\n\n      if (pwdFields.some(field => key.toLowerCase().includes(field.toLowerCase())))\n        value = value.slice(0, -5) + '*****';  //密码字段做屏蔽\n    }\n    return value;\n  });\n}\n```","source":"_posts/屏蔽参数中的敏感字段.md","raw":"---\ntitle: 屏蔽参数中的敏感字段\ndesc: 难得能写些有趣的代码\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2017-04-01 15:14:31\ntags: javaScript\n---\n```javascript\nconst pwdFields = ['password','pwd'];\n\nfunction filterPwdField(obj) {\n  return lodash.mapValues(obj, (value, key) => {\n    if (lodash.isPlainObject(value))\n      return filterPwdField(value);\n\n    if (typeof  value === 'string') {\n      if (pwdFields.some(field => value.toLowerCase().includes(field.toLowerCase()))) { //屏蔽类似password=xxxxx的字符串\n        pwdFields.forEach(field =>\n          value = value.replace(new RegExp(`(${field})=(.+?)(&|$)`, 'gi'), (match, $1, $2, $3) =>\n            `${$1}=${$2.slice(0, -5) + '*****'}${$3 || ''}`\n          ));\n      }\n\n      if (pwdFields.some(field => key.toLowerCase().includes(field.toLowerCase())))\n        value = value.slice(0, -5) + '*****';  //密码字段做屏蔽\n    }\n    return value;\n  });\n}\n```","slug":"屏蔽参数中的敏感字段","published":1,"updated":"2020-06-17T10:26:40.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbs000tsou5cm91a54j","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pwdFields = [<span class=\"string\">&#x27;password&#x27;</span>,<span class=\"string\">&#x27;pwd&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterPwdField</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> lodash.mapValues(obj, <span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lodash.isPlainObject(value))</span><br><span class=\"line\">      <span class=\"keyword\">return</span> filterPwdField(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>  value === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (pwdFields.some(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span> value.toLowerCase().includes(field.toLowerCase()))) &#123; <span class=\"comment\">//屏蔽类似password=xxxxx的字符串</span></span><br><span class=\"line\">        pwdFields.forEach(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span></span><br><span class=\"line\">          value = value.replace(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`(<span class=\"subst\">$&#123;field&#125;</span>)=(.+?)(&amp;|$)`</span>, <span class=\"string\">&#x27;gi&#x27;</span>), <span class=\"function\">(<span class=\"params\">match, $<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span></span>) =&gt;</span></span><br><span class=\"line\">            <span class=\"string\">`<span class=\"subst\">$&#123;$<span class=\"number\">1</span>&#125;</span>=<span class=\"subst\">$&#123;$<span class=\"number\">2.</span>slice(<span class=\"number\">0</span>, -<span class=\"number\">5</span>) + <span class=\"string\">&#x27;*****&#x27;</span>&#125;</span><span class=\"subst\">$&#123;$<span class=\"number\">3</span> || <span class=\"string\">&#x27;&#x27;</span>&#125;</span>`</span></span><br><span class=\"line\">          ));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (pwdFields.some(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span> key.toLowerCase().includes(field.toLowerCase())))</span><br><span class=\"line\">        value = value.slice(<span class=\"number\">0</span>, -<span class=\"number\">5</span>) + <span class=\"string\">&#x27;*****&#x27;</span>;  <span class=\"comment\">//密码字段做屏蔽</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pwdFields = [<span class=\"string\">&#x27;password&#x27;</span>,<span class=\"string\">&#x27;pwd&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterPwdField</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> lodash.mapValues(obj, <span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lodash.isPlainObject(value))</span><br><span class=\"line\">      <span class=\"keyword\">return</span> filterPwdField(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span>  value === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (pwdFields.some(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span> value.toLowerCase().includes(field.toLowerCase()))) &#123; <span class=\"comment\">//屏蔽类似password=xxxxx的字符串</span></span><br><span class=\"line\">        pwdFields.forEach(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span></span><br><span class=\"line\">          value = value.replace(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`(<span class=\"subst\">$&#123;field&#125;</span>)=(.+?)(&amp;|$)`</span>, <span class=\"string\">&#x27;gi&#x27;</span>), <span class=\"function\">(<span class=\"params\">match, $<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span></span>) =&gt;</span></span><br><span class=\"line\">            <span class=\"string\">`<span class=\"subst\">$&#123;$<span class=\"number\">1</span>&#125;</span>=<span class=\"subst\">$&#123;$<span class=\"number\">2.</span>slice(<span class=\"number\">0</span>, -<span class=\"number\">5</span>) + <span class=\"string\">&#x27;*****&#x27;</span>&#125;</span><span class=\"subst\">$&#123;$<span class=\"number\">3</span> || <span class=\"string\">&#x27;&#x27;</span>&#125;</span>`</span></span><br><span class=\"line\">          ));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (pwdFields.some(<span class=\"function\"><span class=\"params\">field</span> =&gt;</span> key.toLowerCase().includes(field.toLowerCase())))</span><br><span class=\"line\">        value = value.slice(<span class=\"number\">0</span>, -<span class=\"number\">5</span>) + <span class=\"string\">&#x27;*****&#x27;</span>;  <span class=\"comment\">//密码字段做屏蔽</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"异步编程，async/await还是promise？","desc":"还是bluebird好用啊","date":"2017-04-19T11:00:14.000Z","author":"ngtmuzi","_content":"\nNode.js的`v7.6`版本出来之后`async/await`正式成为可用特性，其最大的亮点就是将异步的逻辑写在同步的代码里，还能捕捉到异步错误，成为了异步编程的最佳实践，但我们真的能完全抛弃掉`promise`吗？  \n\n* Node的自带模块提供的异步接口都是回调式的，想封成async函数你起码还得用类似bluebird的`Promise.promisify`来封装一遍\n* 同步的错误捕获也并不一定就最好，起码`try/catch`比起`.catch()`还是要多上几行的，想要在各层代码做捕获还要多加几层`try/catch`，看起来很乱\n* `async`定义的函数所返回的是javascript原生的`Promise`对象，也就是说第三方Promise库所提供的各种特性不能在`async`函数后直接使用了，外面还要再包一层`Promise.resolve()`才能转成当前所用的Promise对象，考虑到这点挺烦人的，有些小特性我就干脆直接往原生`Promise`的原型链上挂了\n\n\n异步编程必然要考虑超时，但使用`async`定义的函数并没有这么方便的功能，那我们就参考`bluebird`的格式加到原生`Promise`原型上好了：\n```javascript\nPromise.prototype.timeout = function (ms) {\n  return new Promise((resolve, reject) => {\n    this.then(resolve, reject);\n    setTimeout(() => reject(new Error('promise timeout')), +ms);\n  });\n};\n```\n\n也可以在`new Promise()`时直接使用第三方的Promise库，这样就相当于调过`.timeout()`的`promise`都做了一层包装了，唯一注意的一点是在这段代码之前可不要用类似`global.Promise = require('bluebird')`的语句替换掉原生`Promise`对象\n\n\n最后总结下自己对于`async/await`/`Promise`的一些抉择：\n* 业务逻辑代码可以多用`async/await`，以便在各种条件分支中同步地调用异步代码和捕捉错误\n* 注重流程的，没有太多分支的较底层代码，和已经使用`Promise`开发的旧代码，没有必要转成`async/await`，各种Promise库提供的特性更方便实现各种复杂的异步逻辑\n\n\n简言之，就是业务逻辑多用`async/await`，底层代码多用`Promise`","source":"_posts/异步编程，asyncawait还是promise？.md","raw":"---\ntitle: 异步编程，async/await还是promise？  \ndesc: 还是bluebird好用啊  \ndate: 2017-4-19 19:00:14  \ntags: \n- promise\n- async\n- es7\nauthor: ngtmuzi  \ncategory: 神秘代码\n\n---\n\nNode.js的`v7.6`版本出来之后`async/await`正式成为可用特性，其最大的亮点就是将异步的逻辑写在同步的代码里，还能捕捉到异步错误，成为了异步编程的最佳实践，但我们真的能完全抛弃掉`promise`吗？  \n\n* Node的自带模块提供的异步接口都是回调式的，想封成async函数你起码还得用类似bluebird的`Promise.promisify`来封装一遍\n* 同步的错误捕获也并不一定就最好，起码`try/catch`比起`.catch()`还是要多上几行的，想要在各层代码做捕获还要多加几层`try/catch`，看起来很乱\n* `async`定义的函数所返回的是javascript原生的`Promise`对象，也就是说第三方Promise库所提供的各种特性不能在`async`函数后直接使用了，外面还要再包一层`Promise.resolve()`才能转成当前所用的Promise对象，考虑到这点挺烦人的，有些小特性我就干脆直接往原生`Promise`的原型链上挂了\n\n\n异步编程必然要考虑超时，但使用`async`定义的函数并没有这么方便的功能，那我们就参考`bluebird`的格式加到原生`Promise`原型上好了：\n```javascript\nPromise.prototype.timeout = function (ms) {\n  return new Promise((resolve, reject) => {\n    this.then(resolve, reject);\n    setTimeout(() => reject(new Error('promise timeout')), +ms);\n  });\n};\n```\n\n也可以在`new Promise()`时直接使用第三方的Promise库，这样就相当于调过`.timeout()`的`promise`都做了一层包装了，唯一注意的一点是在这段代码之前可不要用类似`global.Promise = require('bluebird')`的语句替换掉原生`Promise`对象\n\n\n最后总结下自己对于`async/await`/`Promise`的一些抉择：\n* 业务逻辑代码可以多用`async/await`，以便在各种条件分支中同步地调用异步代码和捕捉错误\n* 注重流程的，没有太多分支的较底层代码，和已经使用`Promise`开发的旧代码，没有必要转成`async/await`，各种Promise库提供的特性更方便实现各种复杂的异步逻辑\n\n\n简言之，就是业务逻辑多用`async/await`，底层代码多用`Promise`","slug":"异步编程，asyncawait还是promise？","published":1,"updated":"2020-06-17T10:26:40.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbs000usou54ri1edxe","content":"<p>Node.js的<code>v7.6</code>版本出来之后<code>async/await</code>正式成为可用特性，其最大的亮点就是将异步的逻辑写在同步的代码里，还能捕捉到异步错误，成为了异步编程的最佳实践，但我们真的能完全抛弃掉<code>promise</code>吗？  </p>\n<ul>\n<li>Node的自带模块提供的异步接口都是回调式的，想封成async函数你起码还得用类似bluebird的<code>Promise.promisify</code>来封装一遍</li>\n<li>同步的错误捕获也并不一定就最好，起码<code>try/catch</code>比起<code>.catch()</code>还是要多上几行的，想要在各层代码做捕获还要多加几层<code>try/catch</code>，看起来很乱</li>\n<li><code>async</code>定义的函数所返回的是javascript原生的<code>Promise</code>对象，也就是说第三方Promise库所提供的各种特性不能在<code>async</code>函数后直接使用了，外面还要再包一层<code>Promise.resolve()</code>才能转成当前所用的Promise对象，考虑到这点挺烦人的，有些小特性我就干脆直接往原生<code>Promise</code>的原型链上挂了</li>\n</ul>\n<p>异步编程必然要考虑超时，但使用<code>async</code>定义的函数并没有这么方便的功能，那我们就参考<code>bluebird</code>的格式加到原生<code>Promise</code>原型上好了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.timeout = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then(resolve, reject);</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;promise timeout&#x27;</span>)), +ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>也可以在<code>new Promise()</code>时直接使用第三方的Promise库，这样就相当于调过<code>.timeout()</code>的<code>promise</code>都做了一层包装了，唯一注意的一点是在这段代码之前可不要用类似<code>global.Promise = require(&#39;bluebird&#39;)</code>的语句替换掉原生<code>Promise</code>对象</p>\n<p>最后总结下自己对于<code>async/await</code>/<code>Promise</code>的一些抉择：</p>\n<ul>\n<li>业务逻辑代码可以多用<code>async/await</code>，以便在各种条件分支中同步地调用异步代码和捕捉错误</li>\n<li>注重流程的，没有太多分支的较底层代码，和已经使用<code>Promise</code>开发的旧代码，没有必要转成<code>async/await</code>，各种Promise库提供的特性更方便实现各种复杂的异步逻辑</li>\n</ul>\n<p>简言之，就是业务逻辑多用<code>async/await</code>，底层代码多用<code>Promise</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Node.js的<code>v7.6</code>版本出来之后<code>async/await</code>正式成为可用特性，其最大的亮点就是将异步的逻辑写在同步的代码里，还能捕捉到异步错误，成为了异步编程的最佳实践，但我们真的能完全抛弃掉<code>promise</code>吗？  </p>\n<ul>\n<li>Node的自带模块提供的异步接口都是回调式的，想封成async函数你起码还得用类似bluebird的<code>Promise.promisify</code>来封装一遍</li>\n<li>同步的错误捕获也并不一定就最好，起码<code>try/catch</code>比起<code>.catch()</code>还是要多上几行的，想要在各层代码做捕获还要多加几层<code>try/catch</code>，看起来很乱</li>\n<li><code>async</code>定义的函数所返回的是javascript原生的<code>Promise</code>对象，也就是说第三方Promise库所提供的各种特性不能在<code>async</code>函数后直接使用了，外面还要再包一层<code>Promise.resolve()</code>才能转成当前所用的Promise对象，考虑到这点挺烦人的，有些小特性我就干脆直接往原生<code>Promise</code>的原型链上挂了</li>\n</ul>\n<p>异步编程必然要考虑超时，但使用<code>async</code>定义的函数并没有这么方便的功能，那我们就参考<code>bluebird</code>的格式加到原生<code>Promise</code>原型上好了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.timeout = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.then(resolve, reject);</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;promise timeout&#x27;</span>)), +ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>也可以在<code>new Promise()</code>时直接使用第三方的Promise库，这样就相当于调过<code>.timeout()</code>的<code>promise</code>都做了一层包装了，唯一注意的一点是在这段代码之前可不要用类似<code>global.Promise = require(&#39;bluebird&#39;)</code>的语句替换掉原生<code>Promise</code>对象</p>\n<p>最后总结下自己对于<code>async/await</code>/<code>Promise</code>的一些抉择：</p>\n<ul>\n<li>业务逻辑代码可以多用<code>async/await</code>，以便在各种条件分支中同步地调用异步代码和捕捉错误</li>\n<li>注重流程的，没有太多分支的较底层代码，和已经使用<code>Promise</code>开发的旧代码，没有必要转成<code>async/await</code>，各种Promise库提供的特性更方便实现各种复杂的异步逻辑</li>\n</ul>\n<p>简言之，就是业务逻辑多用<code>async/await</code>，底层代码多用<code>Promise</code></p>\n"},{"title":"维持一个超长时间的mongodb游标","desc":"又在发废文","author":"ngtmuzi","date":"2020-06-17T10:29:46.000Z","_content":"\n**本文使用的是node.js版本的mongodb连接库**\n\n写这篇的时候才发现我根本没写过`tag`是 [#mongodb](https://ngtmuzi.com/tags/mongodb/) 的博客，足以见得知识浅薄，甚至这篇也没有什么技术含量\n\n有个有趣的工作是遍历某mongo库的索引，对其上符合要求的文档做某些操作，数据量大到可能要跑十天半个月，中途可能还要避开业务高峰期，而每次都用`find({_id:{$gt:lastid}}).sort().skip().limit()`感觉又不够好玩\n\n于是计划用一个游标从头遍历到尾，这样的好处是不会重复发出多次op，在网络请求层面上还是要好一点的（游标有一个`batchSize`控制每次读取的数据量，可以视情况调整），而我又可以使用游标的流特性，来做一些下游打包、管道之类的好玩操作（见[《Stream研究笔记II》](https://ngtmuzi.com/NodeJS%EF%BC%9AStream%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0II/)）\n\n## 延长查询超时时间\n\n> [官方文档-MongoClient](http://mongodb.github.io/node-mongodb-native/3.5/api/MongoClient.html)\n\n`MongoClient`建立实例时传递的`socketTimeoutMS`选项默认是6分钟，当查询耗时非常长时（比如没命中索引的`count()`），客户端将不再等待服务端返回并抛错，此选项只是以防万一，如果没有耗时很长的单次查询，这个可以保持默认\n\n## 设置游标不超时\n\n> [官方文档-Collection.find()](http://mongodb.github.io/node-mongodb-native/3.5/api/Collection.html#find)\n\n在`find()`的参数内传递`noCursorTimeout`，避免闲置的游标被服务端主动释放\n\n## 设置session活跃\n\n然而只靠上面的选项还不够，[官方文档-cursor.noCursorTimeout](https://docs.mongodb.com/manual/reference/method/cursor.noCursorTimeout//) 又说了，服务端还是会清理闲置30分钟以上的`session`（每个`op`都包含在`session`中，不主动指定的话会生成一个隐式的），除非你主动地定期刷新`session`的活跃状态，连代码都附出来了\n\n```javascript\nvar session = db.getMongo().startSession()\nvar sessionId = session.getSessionId().id\n\nvar cursor = session.getDatabase(\"examples\").getCollection(\"data\").find().noCursorTimeout()\nvar refreshTimestamp = new Date() // take note of time at operation start\n\nwhile (cursor.hasNext()) {\n\n  // Check if more than 5 minutes have passed since the last refresh\n  if ( (new Date()-refreshTimestamp)/1000 > 300 ) {\n    print(\"refreshing session\")\n    db.adminCommand({\"refreshSessions\" : [sessionId]})\n    refreshTimestamp = new Date()\n  }\n\n  // process cursor normally\n\n}\n```\n需要自己显示声明一个`session`，在它之上发起游标查询，然后定期刷新`session`，这样游标就不会被服务器给释放掉了\n","source":"_posts/维持一个超长时间的mongodb游标.md","raw":"---\ntitle: 维持一个超长时间的mongodb游标\ndesc: 又在发废文\nauthor: ngtmuzi\ncategory: 班门弄斧\ndate: 2020-06-17 18:29:46\ntags: \n- mongodb\n---\n\n**本文使用的是node.js版本的mongodb连接库**\n\n写这篇的时候才发现我根本没写过`tag`是 [#mongodb](https://ngtmuzi.com/tags/mongodb/) 的博客，足以见得知识浅薄，甚至这篇也没有什么技术含量\n\n有个有趣的工作是遍历某mongo库的索引，对其上符合要求的文档做某些操作，数据量大到可能要跑十天半个月，中途可能还要避开业务高峰期，而每次都用`find({_id:{$gt:lastid}}).sort().skip().limit()`感觉又不够好玩\n\n于是计划用一个游标从头遍历到尾，这样的好处是不会重复发出多次op，在网络请求层面上还是要好一点的（游标有一个`batchSize`控制每次读取的数据量，可以视情况调整），而我又可以使用游标的流特性，来做一些下游打包、管道之类的好玩操作（见[《Stream研究笔记II》](https://ngtmuzi.com/NodeJS%EF%BC%9AStream%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0II/)）\n\n## 延长查询超时时间\n\n> [官方文档-MongoClient](http://mongodb.github.io/node-mongodb-native/3.5/api/MongoClient.html)\n\n`MongoClient`建立实例时传递的`socketTimeoutMS`选项默认是6分钟，当查询耗时非常长时（比如没命中索引的`count()`），客户端将不再等待服务端返回并抛错，此选项只是以防万一，如果没有耗时很长的单次查询，这个可以保持默认\n\n## 设置游标不超时\n\n> [官方文档-Collection.find()](http://mongodb.github.io/node-mongodb-native/3.5/api/Collection.html#find)\n\n在`find()`的参数内传递`noCursorTimeout`，避免闲置的游标被服务端主动释放\n\n## 设置session活跃\n\n然而只靠上面的选项还不够，[官方文档-cursor.noCursorTimeout](https://docs.mongodb.com/manual/reference/method/cursor.noCursorTimeout//) 又说了，服务端还是会清理闲置30分钟以上的`session`（每个`op`都包含在`session`中，不主动指定的话会生成一个隐式的），除非你主动地定期刷新`session`的活跃状态，连代码都附出来了\n\n```javascript\nvar session = db.getMongo().startSession()\nvar sessionId = session.getSessionId().id\n\nvar cursor = session.getDatabase(\"examples\").getCollection(\"data\").find().noCursorTimeout()\nvar refreshTimestamp = new Date() // take note of time at operation start\n\nwhile (cursor.hasNext()) {\n\n  // Check if more than 5 minutes have passed since the last refresh\n  if ( (new Date()-refreshTimestamp)/1000 > 300 ) {\n    print(\"refreshing session\")\n    db.adminCommand({\"refreshSessions\" : [sessionId]})\n    refreshTimestamp = new Date()\n  }\n\n  // process cursor normally\n\n}\n```\n需要自己显示声明一个`session`，在它之上发起游标查询，然后定期刷新`session`，这样游标就不会被服务器给释放掉了\n","slug":"维持一个超长时间的mongodb游标","published":1,"updated":"2020-06-17T11:33:21.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbt000vsou56o96elfs","content":"<p><strong>本文使用的是node.js版本的mongodb连接库</strong></p>\n<p>写这篇的时候才发现我根本没写过<code>tag</code>是 <a href=\"https://ngtmuzi.com/tags/mongodb/\">#mongodb</a> 的博客，足以见得知识浅薄，甚至这篇也没有什么技术含量</p>\n<p>有个有趣的工作是遍历某mongo库的索引，对其上符合要求的文档做某些操作，数据量大到可能要跑十天半个月，中途可能还要避开业务高峰期，而每次都用<code>find(&#123;_id:&#123;$gt:lastid&#125;&#125;).sort().skip().limit()</code>感觉又不够好玩</p>\n<p>于是计划用一个游标从头遍历到尾，这样的好处是不会重复发出多次op，在网络请求层面上还是要好一点的（游标有一个<code>batchSize</code>控制每次读取的数据量，可以视情况调整），而我又可以使用游标的流特性，来做一些下游打包、管道之类的好玩操作（见<a href=\"https://ngtmuzi.com/NodeJS%EF%BC%9AStream%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0II/\">《Stream研究笔记II》</a>）</p>\n<h2 id=\"延长查询超时时间\"><a href=\"#延长查询超时时间\" class=\"headerlink\" title=\"延长查询超时时间\"></a>延长查询超时时间</h2><blockquote>\n<p><a href=\"http://mongodb.github.io/node-mongodb-native/3.5/api/MongoClient.html\">官方文档-MongoClient</a></p>\n</blockquote>\n<p><code>MongoClient</code>建立实例时传递的<code>socketTimeoutMS</code>选项默认是6分钟，当查询耗时非常长时（比如没命中索引的<code>count()</code>），客户端将不再等待服务端返回并抛错，此选项只是以防万一，如果没有耗时很长的单次查询，这个可以保持默认</p>\n<h2 id=\"设置游标不超时\"><a href=\"#设置游标不超时\" class=\"headerlink\" title=\"设置游标不超时\"></a>设置游标不超时</h2><blockquote>\n<p><a href=\"http://mongodb.github.io/node-mongodb-native/3.5/api/Collection.html#find\">官方文档-Collection.find()</a></p>\n</blockquote>\n<p>在<code>find()</code>的参数内传递<code>noCursorTimeout</code>，避免闲置的游标被服务端主动释放</p>\n<h2 id=\"设置session活跃\"><a href=\"#设置session活跃\" class=\"headerlink\" title=\"设置session活跃\"></a>设置session活跃</h2><p>然而只靠上面的选项还不够，<a href=\"https://docs.mongodb.com/manual/reference/method/cursor.noCursorTimeout//\">官方文档-cursor.noCursorTimeout</a> 又说了，服务端还是会清理闲置30分钟以上的<code>session</code>（每个<code>op</code>都包含在<code>session</code>中，不主动指定的话会生成一个隐式的），除非你主动地定期刷新<code>session</code>的活跃状态，连代码都附出来了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> session = db.getMongo().startSession()</span><br><span class=\"line\"><span class=\"keyword\">var</span> sessionId = session.getSessionId().id</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cursor = session.getDatabase(<span class=\"string\">&quot;examples&quot;</span>).getCollection(<span class=\"string\">&quot;data&quot;</span>).find().noCursorTimeout()</span><br><span class=\"line\"><span class=\"keyword\">var</span> refreshTimestamp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() <span class=\"comment\">// take note of time at operation start</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (cursor.hasNext()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Check if more than 5 minutes have passed since the last refresh</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()-refreshTimestamp)/<span class=\"number\">1000</span> &gt; <span class=\"number\">300</span> ) &#123;</span><br><span class=\"line\">    print(<span class=\"string\">&quot;refreshing session&quot;</span>)</span><br><span class=\"line\">    db.adminCommand(&#123;<span class=\"string\">&quot;refreshSessions&quot;</span> : [sessionId]&#125;)</span><br><span class=\"line\">    refreshTimestamp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// process cursor normally</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要自己显示声明一个<code>session</code>，在它之上发起游标查询，然后定期刷新<code>session</code>，这样游标就不会被服务器给释放掉了</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>本文使用的是node.js版本的mongodb连接库</strong></p>\n<p>写这篇的时候才发现我根本没写过<code>tag</code>是 <a href=\"https://ngtmuzi.com/tags/mongodb/\">#mongodb</a> 的博客，足以见得知识浅薄，甚至这篇也没有什么技术含量</p>\n<p>有个有趣的工作是遍历某mongo库的索引，对其上符合要求的文档做某些操作，数据量大到可能要跑十天半个月，中途可能还要避开业务高峰期，而每次都用<code>find(&#123;_id:&#123;$gt:lastid&#125;&#125;).sort().skip().limit()</code>感觉又不够好玩</p>\n<p>于是计划用一个游标从头遍历到尾，这样的好处是不会重复发出多次op，在网络请求层面上还是要好一点的（游标有一个<code>batchSize</code>控制每次读取的数据量，可以视情况调整），而我又可以使用游标的流特性，来做一些下游打包、管道之类的好玩操作（见<a href=\"https://ngtmuzi.com/NodeJS%EF%BC%9AStream%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0II/\">《Stream研究笔记II》</a>）</p>\n<h2 id=\"延长查询超时时间\"><a href=\"#延长查询超时时间\" class=\"headerlink\" title=\"延长查询超时时间\"></a>延长查询超时时间</h2><blockquote>\n<p><a href=\"http://mongodb.github.io/node-mongodb-native/3.5/api/MongoClient.html\">官方文档-MongoClient</a></p>\n</blockquote>\n<p><code>MongoClient</code>建立实例时传递的<code>socketTimeoutMS</code>选项默认是6分钟，当查询耗时非常长时（比如没命中索引的<code>count()</code>），客户端将不再等待服务端返回并抛错，此选项只是以防万一，如果没有耗时很长的单次查询，这个可以保持默认</p>\n<h2 id=\"设置游标不超时\"><a href=\"#设置游标不超时\" class=\"headerlink\" title=\"设置游标不超时\"></a>设置游标不超时</h2><blockquote>\n<p><a href=\"http://mongodb.github.io/node-mongodb-native/3.5/api/Collection.html#find\">官方文档-Collection.find()</a></p>\n</blockquote>\n<p>在<code>find()</code>的参数内传递<code>noCursorTimeout</code>，避免闲置的游标被服务端主动释放</p>\n<h2 id=\"设置session活跃\"><a href=\"#设置session活跃\" class=\"headerlink\" title=\"设置session活跃\"></a>设置session活跃</h2><p>然而只靠上面的选项还不够，<a href=\"https://docs.mongodb.com/manual/reference/method/cursor.noCursorTimeout//\">官方文档-cursor.noCursorTimeout</a> 又说了，服务端还是会清理闲置30分钟以上的<code>session</code>（每个<code>op</code>都包含在<code>session</code>中，不主动指定的话会生成一个隐式的），除非你主动地定期刷新<code>session</code>的活跃状态，连代码都附出来了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> session = db.getMongo().startSession()</span><br><span class=\"line\"><span class=\"keyword\">var</span> sessionId = session.getSessionId().id</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cursor = session.getDatabase(<span class=\"string\">&quot;examples&quot;</span>).getCollection(<span class=\"string\">&quot;data&quot;</span>).find().noCursorTimeout()</span><br><span class=\"line\"><span class=\"keyword\">var</span> refreshTimestamp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() <span class=\"comment\">// take note of time at operation start</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (cursor.hasNext()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Check if more than 5 minutes have passed since the last refresh</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()-refreshTimestamp)/<span class=\"number\">1000</span> &gt; <span class=\"number\">300</span> ) &#123;</span><br><span class=\"line\">    print(<span class=\"string\">&quot;refreshing session&quot;</span>)</span><br><span class=\"line\">    db.adminCommand(&#123;<span class=\"string\">&quot;refreshSessions&quot;</span> : [sessionId]&#125;)</span><br><span class=\"line\">    refreshTimestamp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// process cursor normally</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要自己显示声明一个<code>session</code>，在它之上发起游标查询，然后定期刷新<code>session</code>，这样游标就不会被服务器给释放掉了</p>\n"},{"title":"第一次面试官经验","desc":"纸上得来终觉浅，绝知此事要躬行","author":"ngtmuzi","date":"2018-09-12T12:51:53.000Z","_content":"\n被拉过去面应届生，都是互联网研发方向，技术栈全是清一色的JAVA+SMM开发，详情不细说，最后说下自己的感想吧\n\n* 非本专业的还是吃亏，很多基础科目的知识会漏，程序员并不是只要会写一门语言就能当的\n* 无论是否有实习过，一般的应届生知识面还是很窄的，很多工作中会遇到的问题和知识点还是没听说过\n* 笔试那些考C语言奇技淫巧和数学推理的都是什么沙雕题，有些参考答案还是错的，改卷人也很水\n* 面试主要还是看一个人“如何配得上这份工作”，所以一般学校里那种千篇一律的项目真的没什么吸引力\n* 问题没法深入问，到后面基本都是“不是很了解”\n* 新的技术和热点不是很关注，很少有博客和github以及开源项目\n\n最后脑子里一直就这句话`纸上得来终觉浅，绝知此事要躬行`\n\n面试别人比自己面试还累，喉咙都哑了，以后不干这个夭寿的活了","source":"_posts/第一次面试官经验.md","raw":"---\ntitle: 第一次面试官经验\ndesc: 纸上得来终觉浅，绝知此事要躬行\nauthor: ngtmuzi\ncategory: 随笔\ndate: 2018-09-12 20:51:53\ntags:\n---\n\n被拉过去面应届生，都是互联网研发方向，技术栈全是清一色的JAVA+SMM开发，详情不细说，最后说下自己的感想吧\n\n* 非本专业的还是吃亏，很多基础科目的知识会漏，程序员并不是只要会写一门语言就能当的\n* 无论是否有实习过，一般的应届生知识面还是很窄的，很多工作中会遇到的问题和知识点还是没听说过\n* 笔试那些考C语言奇技淫巧和数学推理的都是什么沙雕题，有些参考答案还是错的，改卷人也很水\n* 面试主要还是看一个人“如何配得上这份工作”，所以一般学校里那种千篇一律的项目真的没什么吸引力\n* 问题没法深入问，到后面基本都是“不是很了解”\n* 新的技术和热点不是很关注，很少有博客和github以及开源项目\n\n最后脑子里一直就这句话`纸上得来终觉浅，绝知此事要躬行`\n\n面试别人比自己面试还累，喉咙都哑了，以后不干这个夭寿的活了","slug":"第一次面试官经验","published":1,"updated":"2020-06-17T10:26:40.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbt000wsou55hpmf9te","content":"<p>被拉过去面应届生，都是互联网研发方向，技术栈全是清一色的JAVA+SMM开发，详情不细说，最后说下自己的感想吧</p>\n<ul>\n<li>非本专业的还是吃亏，很多基础科目的知识会漏，程序员并不是只要会写一门语言就能当的</li>\n<li>无论是否有实习过，一般的应届生知识面还是很窄的，很多工作中会遇到的问题和知识点还是没听说过</li>\n<li>笔试那些考C语言奇技淫巧和数学推理的都是什么沙雕题，有些参考答案还是错的，改卷人也很水</li>\n<li>面试主要还是看一个人“如何配得上这份工作”，所以一般学校里那种千篇一律的项目真的没什么吸引力</li>\n<li>问题没法深入问，到后面基本都是“不是很了解”</li>\n<li>新的技术和热点不是很关注，很少有博客和github以及开源项目</li>\n</ul>\n<p>最后脑子里一直就这句话<code>纸上得来终觉浅，绝知此事要躬行</code></p>\n<p>面试别人比自己面试还累，喉咙都哑了，以后不干这个夭寿的活了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>被拉过去面应届生，都是互联网研发方向，技术栈全是清一色的JAVA+SMM开发，详情不细说，最后说下自己的感想吧</p>\n<ul>\n<li>非本专业的还是吃亏，很多基础科目的知识会漏，程序员并不是只要会写一门语言就能当的</li>\n<li>无论是否有实习过，一般的应届生知识面还是很窄的，很多工作中会遇到的问题和知识点还是没听说过</li>\n<li>笔试那些考C语言奇技淫巧和数学推理的都是什么沙雕题，有些参考答案还是错的，改卷人也很水</li>\n<li>面试主要还是看一个人“如何配得上这份工作”，所以一般学校里那种千篇一律的项目真的没什么吸引力</li>\n<li>问题没法深入问，到后面基本都是“不是很了解”</li>\n<li>新的技术和热点不是很关注，很少有博客和github以及开源项目</li>\n</ul>\n<p>最后脑子里一直就这句话<code>纸上得来终觉浅，绝知此事要躬行</code></p>\n<p>面试别人比自己面试还累，喉咙都哑了，以后不干这个夭寿的活了</p>\n"},{"title":"自己撸一个Promise库的过程","desc":"因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧","date":"2017-01-19T01:54:47.349Z","author":"ngtmuzi","_content":"\n新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，`Promise`从ES6出来就用到现在，`then/catch`那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下\n\n## 参考资料：\n\n>[Promises/A+规范](https://promisesaplus.com/)  \n>[崔鹏飞的博客](http://cuipengfei.me/blog/2016/05/15/promise/)  \n>[Promise测试库](https://github.com/promises-aplus/promises-tests)\n\n\n从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。\n\n## 注意点\n\n因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：\n\n* 三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)\n* **规范2.2.4**：`onFulfilled`或`onRejected`在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使`Promise`已经`resolved`），而常用的异步执行函数就是`setTimeout`、`setImmediate`以及node特有的`process.nextTick`等函数，具体函数的不同会影响到整个`Promise`执行的效率，这里可以关注一下\n* **规范2.2.6.1**：当`Promise`进入完成状态，所有`onFulfilled`都需要按它们调用`then`的顺序来触发；这里隐含了一个点：`then`里传进去的函数是通过主动回调来触发的，也就是说`Promise`本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少\n* **规范2.3**：Promise解决程序，规范里将它表示为`[[Resolve]](promise, x)`，实际上就是写一个函数，输入一个未完成的`promise`和值`x`，通过一系列规则判断，以确定这个`promise`最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进`x.then`的函数仅能被调用一次，全程记得用`try-catch`包裹\n\n\n这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些`bluebird`的常用方法，比如`try`、`all`、`map`之类的，对理解代码逻辑很有帮助。\n\n\n附上[我的Promise库](https://github.com/ngtmuzi/np/blob/master/index.js)。另外要说一句，多尝试`new Promise()`来自己封装异步代码，我是见过不少同事只懂从`Promise.resolve()`开始的，那就弄丢了Promise最强大的部分","source":"_posts/自己撸一个Promise库的过程.md","raw":"---\ntitle: 自己撸一个Promise库的过程\ndesc: 因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧  \ndate: 2017-1-19 9:54:47.349\ntags: \n- Promise\n- ES6  \nauthor: ngtmuzi  \ncategory: 班门弄斧\n---\n\n新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，`Promise`从ES6出来就用到现在，`then/catch`那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下\n\n## 参考资料：\n\n>[Promises/A+规范](https://promisesaplus.com/)  \n>[崔鹏飞的博客](http://cuipengfei.me/blog/2016/05/15/promise/)  \n>[Promise测试库](https://github.com/promises-aplus/promises-tests)\n\n\n从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。\n\n## 注意点\n\n因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：\n\n* 三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)\n* **规范2.2.4**：`onFulfilled`或`onRejected`在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使`Promise`已经`resolved`），而常用的异步执行函数就是`setTimeout`、`setImmediate`以及node特有的`process.nextTick`等函数，具体函数的不同会影响到整个`Promise`执行的效率，这里可以关注一下\n* **规范2.2.6.1**：当`Promise`进入完成状态，所有`onFulfilled`都需要按它们调用`then`的顺序来触发；这里隐含了一个点：`then`里传进去的函数是通过主动回调来触发的，也就是说`Promise`本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少\n* **规范2.3**：Promise解决程序，规范里将它表示为`[[Resolve]](promise, x)`，实际上就是写一个函数，输入一个未完成的`promise`和值`x`，通过一系列规则判断，以确定这个`promise`最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进`x.then`的函数仅能被调用一次，全程记得用`try-catch`包裹\n\n\n这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些`bluebird`的常用方法，比如`try`、`all`、`map`之类的，对理解代码逻辑很有帮助。\n\n\n附上[我的Promise库](https://github.com/ngtmuzi/np/blob/master/index.js)。另外要说一句，多尝试`new Promise()`来自己封装异步代码，我是见过不少同事只懂从`Promise.resolve()`开始的，那就弄丢了Promise最强大的部分","slug":"自己撸一个Promise库的过程","published":1,"updated":"2020-06-17T10:26:40.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbu000xsou53kw402il","content":"<p>新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，<code>Promise</code>从ES6出来就用到现在，<code>then/catch</code>那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><blockquote>\n<p><a href=\"https://promisesaplus.com/\">Promises/A+规范</a><br><a href=\"http://cuipengfei.me/blog/2016/05/15/promise/\">崔鹏飞的博客</a><br><a href=\"https://github.com/promises-aplus/promises-tests\">Promise测试库</a></p>\n</blockquote>\n<p>从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：</p>\n<ul>\n<li>三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)</li>\n<li><strong>规范2.2.4</strong>：<code>onFulfilled</code>或<code>onRejected</code>在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使<code>Promise</code>已经<code>resolved</code>），而常用的异步执行函数就是<code>setTimeout</code>、<code>setImmediate</code>以及node特有的<code>process.nextTick</code>等函数，具体函数的不同会影响到整个<code>Promise</code>执行的效率，这里可以关注一下</li>\n<li><strong>规范2.2.6.1</strong>：当<code>Promise</code>进入完成状态，所有<code>onFulfilled</code>都需要按它们调用<code>then</code>的顺序来触发；这里隐含了一个点：<code>then</code>里传进去的函数是通过主动回调来触发的，也就是说<code>Promise</code>本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少</li>\n<li><strong>规范2.3</strong>：Promise解决程序，规范里将它表示为<code>[[Resolve]](promise, x)</code>，实际上就是写一个函数，输入一个未完成的<code>promise</code>和值<code>x</code>，通过一系列规则判断，以确定这个<code>promise</code>最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进<code>x.then</code>的函数仅能被调用一次，全程记得用<code>try-catch</code>包裹</li>\n</ul>\n<p>这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些<code>bluebird</code>的常用方法，比如<code>try</code>、<code>all</code>、<code>map</code>之类的，对理解代码逻辑很有帮助。</p>\n<p>附上<a href=\"https://github.com/ngtmuzi/np/blob/master/index.js\">我的Promise库</a>。另外要说一句，多尝试<code>new Promise()</code>来自己封装异步代码，我是见过不少同事只懂从<code>Promise.resolve()</code>开始的，那就弄丢了Promise最强大的部分</p>\n","site":{"data":{}},"excerpt":"","more":"<p>新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，<code>Promise</code>从ES6出来就用到现在，<code>then/catch</code>那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><blockquote>\n<p><a href=\"https://promisesaplus.com/\">Promises/A+规范</a><br><a href=\"http://cuipengfei.me/blog/2016/05/15/promise/\">崔鹏飞的博客</a><br><a href=\"https://github.com/promises-aplus/promises-tests\">Promise测试库</a></p>\n</blockquote>\n<p>从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：</p>\n<ul>\n<li>三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)</li>\n<li><strong>规范2.2.4</strong>：<code>onFulfilled</code>或<code>onRejected</code>在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使<code>Promise</code>已经<code>resolved</code>），而常用的异步执行函数就是<code>setTimeout</code>、<code>setImmediate</code>以及node特有的<code>process.nextTick</code>等函数，具体函数的不同会影响到整个<code>Promise</code>执行的效率，这里可以关注一下</li>\n<li><strong>规范2.2.6.1</strong>：当<code>Promise</code>进入完成状态，所有<code>onFulfilled</code>都需要按它们调用<code>then</code>的顺序来触发；这里隐含了一个点：<code>then</code>里传进去的函数是通过主动回调来触发的，也就是说<code>Promise</code>本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少</li>\n<li><strong>规范2.3</strong>：Promise解决程序，规范里将它表示为<code>[[Resolve]](promise, x)</code>，实际上就是写一个函数，输入一个未完成的<code>promise</code>和值<code>x</code>，通过一系列规则判断，以确定这个<code>promise</code>最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进<code>x.then</code>的函数仅能被调用一次，全程记得用<code>try-catch</code>包裹</li>\n</ul>\n<p>这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些<code>bluebird</code>的常用方法，比如<code>try</code>、<code>all</code>、<code>map</code>之类的，对理解代码逻辑很有帮助。</p>\n<p>附上<a href=\"https://github.com/ngtmuzi/np/blob/master/index.js\">我的Promise库</a>。另外要说一句，多尝试<code>new Promise()</code>来自己封装异步代码，我是见过不少同事只懂从<code>Promise.resolve()</code>开始的，那就弄丢了Promise最强大的部分</p>\n"},{"title":"解决vue无法捕获input变动的问题","desc":"手动触发Input事件就好了","author":"ngtmuzi","date":"2017-06-05T05:35:42.000Z","_content":"## 问题\n\n自己的页面使用了vue和一款jquery的时间选择插件`datepicker`，但选好时间后input框的变动并没有被vue捕获到\n\n## 参考资料\n\n> [Vue表单控件绑定](http://cn.vuejs.org/v2/guide/forms.html#基础用法)  \n> [Vue源码](https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090)  \n> [Jquery的val()方法说明](http://api.jquery.com/val/#val-value)  \n> [从vue.js的源码分析...](http://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html)  \n> [MDN: Event对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Event)\n\n## 分析\n\njquery的val方法文档写得很清楚：\n\n> Setting values using this method (or using the native value property) does not cause the dispatch of the change event.\n\n在类似使用`jquery`的`val()`方法时或者原生dom方法改动input的值时，不会触发任何事件。\n\n> [vue.js #L6090](https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090)\n ```javascript\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n```\n\n而vue是通过绑定事件（默认是`input`）来获知表单元素的变动的，因此这个问题就是因为插件直接用`.val()`设置了值，而vue无法获知。\n\n## 解决方案\n\n我们可以在改动值后手动触发`input`事件，注意这里我们需要使用DOM原生的`event`对象，而不能直接使用jquery的`.trigger()`方法\n```javascript\n//.get(0)返回DOM原生对象\n$('#input1').val('something').get(0).dispatchEvent(new Event('input'));\n```\n在我这个具体问题中，监听插件的自定义事件就可以了\n```javascript\n$(\".form_datetime\").datepicker()\n  .on('changeDate', function (e) {\n    //触发DOM对象上的原生input事件\n    this.dispatchEvent(new Event('input'))\n  });\n```\n注意如果input使用的修饰符带有`.lazy`则应该触发`change`事件\n\n当然最好的办法还是避免使用其他库来改动表单，改为使用基于vue的插件之类的，省心省力","source":"_posts/解决vue无法捕获input变动的问题.md","raw":"---\ntitle: 解决vue无法捕获input变动的问题\ndesc: 手动触发Input事件就好了\nauthor: ngtmuzi\ncategory: 神秘代码\ndate: 2017-06-05 13:35:42\ntags:\n- vue\n- jquery\n- javascript\n---\n## 问题\n\n自己的页面使用了vue和一款jquery的时间选择插件`datepicker`，但选好时间后input框的变动并没有被vue捕获到\n\n## 参考资料\n\n> [Vue表单控件绑定](http://cn.vuejs.org/v2/guide/forms.html#基础用法)  \n> [Vue源码](https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090)  \n> [Jquery的val()方法说明](http://api.jquery.com/val/#val-value)  \n> [从vue.js的源码分析...](http://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html)  \n> [MDN: Event对象](https://developer.mozilla.org/zh-CN/docs/Web/API/Event)\n\n## 分析\n\njquery的val方法文档写得很清楚：\n\n> Setting values using this method (or using the native value property) does not cause the dispatch of the change event.\n\n在类似使用`jquery`的`val()`方法时或者原生dom方法改动input的值时，不会触发任何事件。\n\n> [vue.js #L6090](https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090)\n ```javascript\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n```\n\n而vue是通过绑定事件（默认是`input`）来获知表单元素的变动的，因此这个问题就是因为插件直接用`.val()`设置了值，而vue无法获知。\n\n## 解决方案\n\n我们可以在改动值后手动触发`input`事件，注意这里我们需要使用DOM原生的`event`对象，而不能直接使用jquery的`.trigger()`方法\n```javascript\n//.get(0)返回DOM原生对象\n$('#input1').val('something').get(0).dispatchEvent(new Event('input'));\n```\n在我这个具体问题中，监听插件的自定义事件就可以了\n```javascript\n$(\".form_datetime\").datepicker()\n  .on('changeDate', function (e) {\n    //触发DOM对象上的原生input事件\n    this.dispatchEvent(new Event('input'))\n  });\n```\n注意如果input使用的修饰符带有`.lazy`则应该触发`change`事件\n\n当然最好的办法还是避免使用其他库来改动表单，改为使用基于vue的插件之类的，省心省力","slug":"解决vue无法捕获input变动的问题","published":1,"updated":"2020-06-17T10:26:40.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgu6ckbu000ysou50p4387hf","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>自己的页面使用了vue和一款jquery的时间选择插件<code>datepicker</code>，但选好时间后input框的变动并没有被vue捕获到</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><blockquote>\n<p><a href=\"http://cn.vuejs.org/v2/guide/forms.html#基础用法\">Vue表单控件绑定</a><br><a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090\">Vue源码</a><br><a href=\"http://api.jquery.com/val/#val-value\">Jquery的val()方法说明</a><br><a href=\"http://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html\">从vue.js的源码分析…</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Event\">MDN: Event对象</a></p>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>jquery的val方法文档写得很清楚：</p>\n<blockquote>\n<p>Setting values using this method (or using the native value property) does not cause the dispatch of the change event.</p>\n</blockquote>\n<p>在类似使用<code>jquery</code>的<code>val()</code>方法时或者原生dom方法改动input的值时，不会触发任何事件。</p>\n<blockquote>\n<p><a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090\">vue.js #L6090</a><br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> event = lazy</span><br><span class=\"line\">  ? <span class=\"string\">&#x27;change&#x27;</span></span><br><span class=\"line\">  : type === <span class=\"string\">&#x27;range&#x27;</span></span><br><span class=\"line\">    ? RANGE_TOKEN</span><br><span class=\"line\">    : <span class=\"string\">&#x27;input&#x27;</span>;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>而vue是通过绑定事件（默认是<code>input</code>）来获知表单元素的变动的，因此这个问题就是因为插件直接用<code>.val()</code>设置了值，而vue无法获知。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>我们可以在改动值后手动触发<code>input</code>事件，注意这里我们需要使用DOM原生的<code>event</code>对象，而不能直接使用jquery的<code>.trigger()</code>方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.get(0)返回DOM原生对象</span></span><br><span class=\"line\">$(<span class=\"string\">&#x27;#input1&#x27;</span>).val(<span class=\"string\">&#x27;something&#x27;</span>).get(<span class=\"number\">0</span>).dispatchEvent(<span class=\"keyword\">new</span> Event(<span class=\"string\">&#x27;input&#x27;</span>));</span><br></pre></td></tr></table></figure><br>在我这个具体问题中，监听插件的自定义事件就可以了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&quot;.form_datetime&quot;</span>).datepicker()</span><br><span class=\"line\">  .on(<span class=\"string\">&#x27;changeDate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//触发DOM对象上的原生input事件</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.dispatchEvent(<span class=\"keyword\">new</span> Event(<span class=\"string\">&#x27;input&#x27;</span>))</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure><br>注意如果input使用的修饰符带有<code>.lazy</code>则应该触发<code>change</code>事件</p>\n<p>当然最好的办法还是避免使用其他库来改动表单，改为使用基于vue的插件之类的，省心省力</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>自己的页面使用了vue和一款jquery的时间选择插件<code>datepicker</code>，但选好时间后input框的变动并没有被vue捕获到</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><blockquote>\n<p><a href=\"http://cn.vuejs.org/v2/guide/forms.html#基础用法\">Vue表单控件绑定</a><br><a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090\">Vue源码</a><br><a href=\"http://api.jquery.com/val/#val-value\">Jquery的val()方法说明</a><br><a href=\"http://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html\">从vue.js的源码分析…</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Event\">MDN: Event对象</a></p>\n</blockquote>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>jquery的val方法文档写得很清楚：</p>\n<blockquote>\n<p>Setting values using this method (or using the native value property) does not cause the dispatch of the change event.</p>\n</blockquote>\n<p>在类似使用<code>jquery</code>的<code>val()</code>方法时或者原生dom方法改动input的值时，不会触发任何事件。</p>\n<blockquote>\n<p><a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js#L6090\">vue.js #L6090</a><br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> event = lazy</span><br><span class=\"line\">  ? <span class=\"string\">&#x27;change&#x27;</span></span><br><span class=\"line\">  : type === <span class=\"string\">&#x27;range&#x27;</span></span><br><span class=\"line\">    ? RANGE_TOKEN</span><br><span class=\"line\">    : <span class=\"string\">&#x27;input&#x27;</span>;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>而vue是通过绑定事件（默认是<code>input</code>）来获知表单元素的变动的，因此这个问题就是因为插件直接用<code>.val()</code>设置了值，而vue无法获知。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>我们可以在改动值后手动触发<code>input</code>事件，注意这里我们需要使用DOM原生的<code>event</code>对象，而不能直接使用jquery的<code>.trigger()</code>方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.get(0)返回DOM原生对象</span></span><br><span class=\"line\">$(<span class=\"string\">&#x27;#input1&#x27;</span>).val(<span class=\"string\">&#x27;something&#x27;</span>).get(<span class=\"number\">0</span>).dispatchEvent(<span class=\"keyword\">new</span> Event(<span class=\"string\">&#x27;input&#x27;</span>));</span><br></pre></td></tr></table></figure><br>在我这个具体问题中，监听插件的自定义事件就可以了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&quot;.form_datetime&quot;</span>).datepicker()</span><br><span class=\"line\">  .on(<span class=\"string\">&#x27;changeDate&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//触发DOM对象上的原生input事件</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.dispatchEvent(<span class=\"keyword\">new</span> Event(<span class=\"string\">&#x27;input&#x27;</span>))</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure><br>注意如果input使用的修饰符带有<code>.lazy</code>则应该触发<code>change</code>事件</p>\n<p>当然最好的办法还是避免使用其他库来改动表单，改为使用基于vue的插件之类的，省心省力</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckgu6ckb70000sou561h2hyb2","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdm003vsou5g553dpiw"},{"post_id":"ckgu6ckbc0001sou56ebc5ce4","category_id":"ckgu6ckcc0011sou52pixd9tu","_id":"ckgu6ckdm003xsou58aiv1p9k"},{"post_id":"ckgu6ckbd0002sou51dxqdwxu","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdn003zsou57onpe15d"},{"post_id":"ckgu6ckbd0003sou551fs58wv","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdn0041sou577g62n8f"},{"post_id":"ckgu6ckbe0004sou5ekuk7b69","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdn0043sou54z2rbxjk"},{"post_id":"ckgu6ckbf0005sou5bymxenfg","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdn0045sou5aurk4942"},{"post_id":"ckgu6ckbf0006sou5hffj83tp","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdn0047sou57nnaal2p"},{"post_id":"ckgu6ckbg0007sou56pfffocd","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdn0049sou5btzlf8lp"},{"post_id":"ckgu6ckbg0008sou58x149p6y","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdn004bsou52jrn6i13"},{"post_id":"ckgu6ckbh0009sou54zym7f9m","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdn004dsou5069689g5"},{"post_id":"ckgu6ckbh000asou52scw1upq","category_id":"ckgu6ckcc0011sou52pixd9tu","_id":"ckgu6ckdo004fsou55wuqhnvo"},{"post_id":"ckgu6ckbi000bsou55x6fa76j","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdo004hsou524jh2fb3"},{"post_id":"ckgu6ckbi000csou5e53j43tk","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdo004jsou53s6j5epf"},{"post_id":"ckgu6ckbj000dsou5cybr6cxb","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdo004lsou5hm6w9rqw"},{"post_id":"ckgu6ckbk000esou59uo1ag9v","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdo004nsou539h3e9jk"},{"post_id":"ckgu6ckbl000fsou5bgt05vc5","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdo004psou5fy81fvxg"},{"post_id":"ckgu6ckbl000gsou5hu9e09x4","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdo004rsou5c5h927ak"},{"post_id":"ckgu6ckbm000hsou5g24n4ldx","category_id":"ckgu6ckcr001xsou57w05c575","_id":"ckgu6ckdo004tsou576r16674"},{"post_id":"ckgu6ckbm000isou5fawvcns6","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdo004vsou5akpban8s"},{"post_id":"ckgu6ckbn000jsou552gbajxe","category_id":"ckgu6ckcc0011sou52pixd9tu","_id":"ckgu6ckdo004xsou5hi21cqra"},{"post_id":"ckgu6ckbo000ksou54yq6gnya","category_id":"ckgu6ckcr001xsou57w05c575","_id":"ckgu6ckdp004zsou5h1466c1n"},{"post_id":"ckgu6ckbo000lsou512n60pr7","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdp0051sou5215742x3"},{"post_id":"ckgu6ckbp000msou5eyiiba6d","category_id":"ckgu6ckcc0011sou52pixd9tu","_id":"ckgu6ckdp0053sou522jlbjvi"},{"post_id":"ckgu6ckbp000nsou5712329k9","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdp0055sou51lh32oif"},{"post_id":"ckgu6ckbq000osou53snt1l9f","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdp0057sou58spn717g"},{"post_id":"ckgu6ckbq000psou50i9wf1be","category_id":"ckgu6ckcc0011sou52pixd9tu","_id":"ckgu6ckdp0059sou59q8h15fu"},{"post_id":"ckgu6ckbr000qsou5ff1xg9vl","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdp005bsou5dzog826c"},{"post_id":"ckgu6ckbr000rsou53z4odx8e","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdp005dsou56wl35k7x"},{"post_id":"ckgu6ckbr000ssou51bvo3663","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdq005fsou5ezg2g9t6"},{"post_id":"ckgu6ckbs000tsou5cm91a54j","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdq005hsou5eomz9pi5"},{"post_id":"ckgu6ckbs000usou54ri1edxe","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdr005jsou5477z3vvc"},{"post_id":"ckgu6ckbt000vsou56o96elfs","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdr005lsou51kdn9h16"},{"post_id":"ckgu6ckbt000wsou55hpmf9te","category_id":"ckgu6ckcc0011sou52pixd9tu","_id":"ckgu6ckdr005nsou5cst8f5jh"},{"post_id":"ckgu6ckbu000xsou53kw402il","category_id":"ckgu6ckc4000zsou5edxzeswm","_id":"ckgu6ckdr005psou55hrsb8si"},{"post_id":"ckgu6ckbu000ysou50p4387hf","category_id":"ckgu6ckcf0013sou5emlr8ee1","_id":"ckgu6ckdr005rsou58c3cd7me"}],"PostTag":[{"post_id":"ckgu6ckb70000sou561h2hyb2","tag_id":"ckgu6ckcb0010sou525sk6yi1","_id":"ckgu6ckdm003usou5f30c2c64"},{"post_id":"ckgu6ckb70000sou561h2hyb2","tag_id":"ckgu6ckce0012sou59nyb25h6","_id":"ckgu6ckdm003wsou520b4fzxc"},{"post_id":"ckgu6ckbc0001sou56ebc5ce4","tag_id":"ckgu6ckcf0014sou5187r12gu","_id":"ckgu6ckdn003ysou534t75zxj"},{"post_id":"ckgu6ckbd0002sou51dxqdwxu","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckdn0040sou5hi7m1ni8"},{"post_id":"ckgu6ckbd0002sou51dxqdwxu","tag_id":"ckgu6ckci0018sou57aey9f15","_id":"ckgu6ckdn0042sou5dfm3dfj4"},{"post_id":"ckgu6ckbd0003sou551fs58wv","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckdn0044sou52369dz34"},{"post_id":"ckgu6ckbd0003sou551fs58wv","tag_id":"ckgu6ckci0018sou57aey9f15","_id":"ckgu6ckdn0046sou513zwfbmz"},{"post_id":"ckgu6ckbe0004sou5ekuk7b69","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckdn0048sou576suehnp"},{"post_id":"ckgu6ckbe0004sou5ekuk7b69","tag_id":"ckgu6ckcl001gsou5a0cb5hl2","_id":"ckgu6ckdn004asou50yt39vxz"},{"post_id":"ckgu6ckbf0005sou5bymxenfg","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckdn004csou5cvnc1cu3"},{"post_id":"ckgu6ckbf0005sou5bymxenfg","tag_id":"ckgu6ckcm001ksou59u42apyj","_id":"ckgu6ckdn004esou5429pasoc"},{"post_id":"ckgu6ckbf0006sou5hffj83tp","tag_id":"ckgu6ckci0018sou57aey9f15","_id":"ckgu6ckdo004gsou55qwhhknq"},{"post_id":"ckgu6ckbf0006sou5hffj83tp","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckdo004isou5drt6d01n"},{"post_id":"ckgu6ckbf0006sou5hffj83tp","tag_id":"ckgu6ckcp001qsou52fpd5tb6","_id":"ckgu6ckdo004ksou53693caei"},{"post_id":"ckgu6ckbg0007sou56pfffocd","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckdo004msou57adgfsnn"},{"post_id":"ckgu6ckbg0007sou56pfffocd","tag_id":"ckgu6ckcq001usou57mjkbabe","_id":"ckgu6ckdo004osou58w6z6a34"},{"post_id":"ckgu6ckbg0007sou56pfffocd","tag_id":"ckgu6ckcq001wsou5bjhsfcal","_id":"ckgu6ckdo004qsou58qjo9qmu"},{"post_id":"ckgu6ckbg0008sou58x149p6y","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckdo004ssou5fk6xap91"},{"post_id":"ckgu6ckbh0009sou54zym7f9m","tag_id":"ckgu6ckcs0020sou5du0c60ci","_id":"ckgu6ckdo004usou5dezs36yf"},{"post_id":"ckgu6ckbh0009sou54zym7f9m","tag_id":"ckgu6ckcs0022sou581c12joa","_id":"ckgu6ckdo004wsou51ydeacbo"},{"post_id":"ckgu6ckbh0009sou54zym7f9m","tag_id":"ckgu6ckct0025sou5brp4fvfu","_id":"ckgu6ckdp004ysou52mfc0wdm"},{"post_id":"ckgu6ckbh000asou52scw1upq","tag_id":"ckgu6ckcs0022sou581c12joa","_id":"ckgu6ckdp0050sou56vt75ffo"},{"post_id":"ckgu6ckbh000asou52scw1upq","tag_id":"ckgu6ckcs0020sou5du0c60ci","_id":"ckgu6ckdp0052sou5dx7df2b3"},{"post_id":"ckgu6ckbh000asou52scw1upq","tag_id":"ckgu6ckcv002bsou54e731dte","_id":"ckgu6ckdp0054sou5eptzamdc"},{"post_id":"ckgu6ckbi000bsou55x6fa76j","tag_id":"ckgu6ckct0025sou5brp4fvfu","_id":"ckgu6ckdp0056sou56y0xh6co"},{"post_id":"ckgu6ckbi000bsou55x6fa76j","tag_id":"ckgu6ckcw002fsou5hkf4f60u","_id":"ckgu6ckdp0058sou532xb57z0"},{"post_id":"ckgu6ckbi000bsou55x6fa76j","tag_id":"ckgu6ckcx002hsou5eyw512b9","_id":"ckgu6ckdp005asou59i6d6i9d"},{"post_id":"ckgu6ckbi000bsou55x6fa76j","tag_id":"ckgu6ckcx002jsou5hihl422x","_id":"ckgu6ckdp005csou54t7n5okf"},{"post_id":"ckgu6ckbi000csou5e53j43tk","tag_id":"ckgu6ckct0025sou5brp4fvfu","_id":"ckgu6ckdp005esou5hvry7s9e"},{"post_id":"ckgu6ckbi000csou5e53j43tk","tag_id":"ckgu6ckcz002nsou50swrdhz6","_id":"ckgu6ckdq005gsou51k1ec48b"},{"post_id":"ckgu6ckbi000csou5e53j43tk","tag_id":"ckgu6ckcw002fsou5hkf4f60u","_id":"ckgu6ckdr005isou59u6n1mfi"},{"post_id":"ckgu6ckbj000dsou5cybr6cxb","tag_id":"ckgu6ckct0025sou5brp4fvfu","_id":"ckgu6ckdr005ksou5622d4k1j"},{"post_id":"ckgu6ckbj000dsou5cybr6cxb","tag_id":"ckgu6ckd0002tsou5gme4g8lu","_id":"ckgu6ckdr005msou5ai9cc28j"},{"post_id":"ckgu6ckbk000esou59uo1ag9v","tag_id":"ckgu6ckct0025sou5brp4fvfu","_id":"ckgu6ckdr005osou5c96jbxw7"},{"post_id":"ckgu6ckbl000fsou5bgt05vc5","tag_id":"ckgu6ckct0025sou5brp4fvfu","_id":"ckgu6ckdr005qsou5hpgv1p8w"},{"post_id":"ckgu6ckbl000gsou5hu9e09x4","tag_id":"ckgu6ckd2002xsou5eoyoe431","_id":"ckgu6ckdr005ssou5hzad19dx"},{"post_id":"ckgu6ckbm000hsou5g24n4ldx","tag_id":"ckgu6ckd2002ysou50c75dfew","_id":"ckgu6ckdr005tsou5679kcl0v"},{"post_id":"ckgu6ckbm000isou5fawvcns6","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckdr005usou5a0h2aasz"},{"post_id":"ckgu6ckbm000isou5fawvcns6","tag_id":"ckgu6ckct0025sou5brp4fvfu","_id":"ckgu6ckdr005vsou526647co4"},{"post_id":"ckgu6ckbm000isou5fawvcns6","tag_id":"ckgu6ckcp001qsou52fpd5tb6","_id":"ckgu6ckdr005wsou594mqe29y"},{"post_id":"ckgu6ckbm000isou5fawvcns6","tag_id":"ckgu6ckd30032sou569kc7xdm","_id":"ckgu6ckdr005xsou5eynoeg1x"},{"post_id":"ckgu6ckbn000jsou552gbajxe","tag_id":"ckgu6ckcf0014sou5187r12gu","_id":"ckgu6ckdr005ysou53je791ii"},{"post_id":"ckgu6ckbo000ksou54yq6gnya","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckdr005zsou54ztq03xz"},{"post_id":"ckgu6ckbo000lsou512n60pr7","tag_id":"ckgu6ckd40035sou50y7egmuq","_id":"ckgu6ckdr0060sou5g23qgjmq"},{"post_id":"ckgu6ckbo000lsou512n60pr7","tag_id":"ckgu6ckcv002bsou54e731dte","_id":"ckgu6ckdr0061sou5enpf8enx"},{"post_id":"ckgu6ckbp000nsou5712329k9","tag_id":"ckgu6ckd50037sou5csp8hne5","_id":"ckgu6ckds0062sou51k6hckig"},{"post_id":"ckgu6ckbp000nsou5712329k9","tag_id":"ckgu6ckd50038sou55c8e6c73","_id":"ckgu6ckds0063sou5ef8hdmjs"},{"post_id":"ckgu6ckbq000osou53snt1l9f","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckds0064sou57tje4vpo"},{"post_id":"ckgu6ckbq000osou53snt1l9f","tag_id":"ckgu6ckd6003asou5ejl2gcdy","_id":"ckgu6ckds0065sou5f3ppg9ep"},{"post_id":"ckgu6ckbr000qsou5ff1xg9vl","tag_id":"ckgu6ckcx002hsou5eyw512b9","_id":"ckgu6ckds0066sou51krx64cu"},{"post_id":"ckgu6ckbr000qsou5ff1xg9vl","tag_id":"ckgu6ckd6003csou550z82sqr","_id":"ckgu6ckds0067sou5fns66kyz"},{"post_id":"ckgu6ckbr000qsou5ff1xg9vl","tag_id":"ckgu6ckcs0022sou581c12joa","_id":"ckgu6ckds0068sou5e3ts78z6"},{"post_id":"ckgu6ckbr000rsou53z4odx8e","tag_id":"ckgu6ckcg0016sou5f6zrh2m9","_id":"ckgu6ckds0069sou535tg2gh9"},{"post_id":"ckgu6ckbr000rsou53z4odx8e","tag_id":"ckgu6ckd8003fsou50vbw19br","_id":"ckgu6ckds006asou52dctf11o"},{"post_id":"ckgu6ckbr000rsou53z4odx8e","tag_id":"ckgu6ckd30032sou569kc7xdm","_id":"ckgu6ckds006bsou5fgvch8hw"},{"post_id":"ckgu6ckbr000ssou51bvo3663","tag_id":"ckgu6ckct0025sou5brp4fvfu","_id":"ckgu6ckds006csou5a4pw6oto"},{"post_id":"ckgu6ckbr000ssou51bvo3663","tag_id":"ckgu6ckcx002hsou5eyw512b9","_id":"ckgu6ckds006dsou5dnfrdghz"},{"post_id":"ckgu6ckbr000ssou51bvo3663","tag_id":"ckgu6ckcx002jsou5hihl422x","_id":"ckgu6ckds006esou5gj2v1f0j"},{"post_id":"ckgu6ckbs000tsou5cm91a54j","tag_id":"ckgu6ckd6003csou550z82sqr","_id":"ckgu6ckds006fsou57mbx1o02"},{"post_id":"ckgu6ckbs000usou54ri1edxe","tag_id":"ckgu6ckcp001qsou52fpd5tb6","_id":"ckgu6ckdt006gsou575la5b08"},{"post_id":"ckgu6ckbs000usou54ri1edxe","tag_id":"ckgu6ckda003msou5c1o2c0rd","_id":"ckgu6ckdt006hsou51saj8leb"},{"post_id":"ckgu6ckbs000usou54ri1edxe","tag_id":"ckgu6ckdb003nsou5hbb280r0","_id":"ckgu6ckdt006isou52nrlck7q"},{"post_id":"ckgu6ckbt000vsou56o96elfs","tag_id":"ckgu6ckdb003osou50fk025ij","_id":"ckgu6ckdt006jsou51d2ndeow"},{"post_id":"ckgu6ckbu000xsou53kw402il","tag_id":"ckgu6ckcx002hsou5eyw512b9","_id":"ckgu6ckdt006ksou5f0fzeptf"},{"post_id":"ckgu6ckbu000xsou53kw402il","tag_id":"ckgu6ckcx002jsou5hihl422x","_id":"ckgu6ckdt006lsou5fcrp4r5l"},{"post_id":"ckgu6ckbu000ysou50p4387hf","tag_id":"ckgu6ckcs0020sou5du0c60ci","_id":"ckgu6ckdt006msou5gxbc0y78"},{"post_id":"ckgu6ckbu000ysou50p4387hf","tag_id":"ckgu6ckdc003ssou5e86a4r3a","_id":"ckgu6ckdt006nsou5d5ui9djw"},{"post_id":"ckgu6ckbu000ysou50p4387hf","tag_id":"ckgu6ckct0025sou5brp4fvfu","_id":"ckgu6ckdt006osou5dx9ed730"}],"Tag":[{"name":"TypeScript","_id":"ckgu6ckcb0010sou525sk6yi1"},{"name":"TS","_id":"ckgu6ckce0012sou59nyb25h6"},{"name":"总结","_id":"ckgu6ckcf0014sou5187r12gu"},{"name":"nodejs","_id":"ckgu6ckcg0016sou5f6zrh2m9"},{"name":"stream","_id":"ckgu6ckci0018sou57aey9f15"},{"name":"encoding","_id":"ckgu6ckcl001gsou5a0cb5hl2"},{"name":"redis","_id":"ckgu6ckcm001ksou59u42apyj"},{"name":"promise","_id":"ckgu6ckcp001qsou52fpd5tb6"},{"name":"shell","_id":"ckgu6ckcq001usou57mjkbabe"},{"name":"cli","_id":"ckgu6ckcq001wsou5bjhsfcal"},{"name":"vue","_id":"ckgu6ckcs0020sou5du0c60ci"},{"name":"前端","_id":"ckgu6ckcs0022sou581c12joa"},{"name":"javascript","_id":"ckgu6ckct0025sou5brp4fvfu"},{"name":"Tool","_id":"ckgu6ckcv002bsou54e731dte"},{"name":"Proxy","_id":"ckgu6ckcw002fsou5hkf4f60u"},{"name":"Promise","_id":"ckgu6ckcx002hsou5eyw512b9"},{"name":"ES6","_id":"ckgu6ckcx002jsou5hihl422x"},{"name":"es6","_id":"ckgu6ckcz002nsou50swrdhz6"},{"name":"Class","_id":"ckgu6ckd0002tsou5gme4g8lu"},{"name":"C++","_id":"ckgu6ckd2002xsou5eoyoe431"},{"name":"mysql","_id":"ckgu6ckd2002ysou50c75dfew"},{"name":"express","_id":"ckgu6ckd30032sou569kc7xdm"},{"name":"ElasticSearch","_id":"ckgu6ckd40035sou50y7egmuq"},{"name":"Bash","_id":"ckgu6ckd50037sou5csp8hne5"},{"name":"MSSQL","_id":"ckgu6ckd50038sou55c8e6c73"},{"name":"socket.io","_id":"ckgu6ckd6003asou5ejl2gcdy"},{"name":"javaScript","_id":"ckgu6ckd6003csou550z82sqr"},{"name":"koa","_id":"ckgu6ckd8003fsou50vbw19br"},{"name":"async","_id":"ckgu6ckda003msou5c1o2c0rd"},{"name":"es7","_id":"ckgu6ckdb003nsou5hbb280r0"},{"name":"mongodb","_id":"ckgu6ckdb003osou50fk025ij"},{"name":"jquery","_id":"ckgu6ckdc003ssou5e86a4r3a"}]}}