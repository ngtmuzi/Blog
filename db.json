{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/clean-blog/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/article.styl","path":"css/article.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/mixins.styl","path":"css/mixins.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/variables.styl","path":"css/variables.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":1},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/clean-blog/LICENSE","hash":"34ac5e147727699d1bbc346b014f2e0bdfbb0947","modified":1485083344262},{"_id":"themes/clean-blog/README.md","hash":"4fa53a32f64f081660be607d9ed4f4efa28b3b25","modified":1485083344266},{"_id":"themes/clean-blog/_config.yml","hash":"bee26e7a100b0555215176b06890e71b389e6626","modified":1485143553453},{"_id":"source/_posts/NodeJS：Stream研究笔记.md","hash":"d177f27b1cd471d501cf3e7346a9b82cfc62b0a3","modified":1485138403175},{"_id":"source/_posts/Node处理字符编码相关经验.md","hash":"ac9806a9f1735a8689698a916d1593b51bcdbcfd","modified":1485138351890},{"_id":"source/_posts/Proxy实现Promise同步调用逻辑.md","hash":"15b7dcf534bb077356a9f742ac8626fe37351f2d","modified":1485138283590},{"_id":"source/_posts/Proxy对象仿Scala的通配符函数调用.md","hash":"2b83cb8912f41d76907f38874b00456de72c6aa1","modified":1485138283667},{"_id":"source/_posts/javaScript的函数柯里化.md","hash":"870c1e7c6e53a0cc6805fc44a2f423f395db4882","modified":1485138458402},{"_id":"source/_posts/javascript模板渲染研究笔记（一）.md","hash":"ab021eeb63be243a6fb4771173bbae5fe64391a7","modified":1485138450978},{"_id":"source/_posts/promise的日常应用.md","hash":"8b965dc5c27a8b9524044b2376418cf5fa540c3c","modified":1485138351921},{"_id":"source/_posts/mingw32缺少posix_memalign函数.md","hash":"078072348d701a4d7ca227978f26ec7a1003b3cf","modified":1485138450943},{"_id":"source/_posts/个人博客绝赞内测中.md","hash":"41255bb3066eca218310f0073985fe855566ceed","modified":1485138283610},{"_id":"source/_posts/博客迁移到hexo.md","hash":"cf7ceb76ed2e66852bf13aff3ea49c8fd2f3e206","modified":1485138283631},{"_id":"source/_posts/实现一个简单的promise队列.md","hash":"2a638dd6295edfb8635b9f046c10bce0e3fc825a","modified":1485140701773},{"_id":"source/_posts/自己撸一个Promise库的过程.md","hash":"b1094a1a8a119a14c11e8b76339b14809df8cb20","modified":1485140248720},{"_id":"themes/clean-blog/languages/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1485083344274},{"_id":"themes/clean-blog/languages/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1485083344277},{"_id":"themes/clean-blog/languages/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1485083344278},{"_id":"themes/clean-blog/languages/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1485083344280},{"_id":"themes/clean-blog/languages/fr.yml","hash":"10e3529b8492d7a7601d5b35b44d8fc9e8ea8d1b","modified":1485083344283},{"_id":"themes/clean-blog/languages/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1485083344286},{"_id":"themes/clean-blog/languages/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1485083344289},{"_id":"themes/clean-blog/languages/pt.yml","hash":"6a31d548092af8af9f25d859063b0589c23ce13a","modified":1485083344292},{"_id":"themes/clean-blog/languages/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1485083344295},{"_id":"themes/clean-blog/languages/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1485083344301},{"_id":"themes/clean-blog/languages/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1485083344298},{"_id":"themes/clean-blog/source/favicon.ico","hash":"11c8f3376cd3d5c578f72b15265614b1c91c0921","modified":1452563365192},{"_id":"themes/clean-blog/layout/archive.ejs","hash":"3c3eaf652efe697fe6bbbcc66c346a98f94fe363","modified":1485083344527},{"_id":"themes/clean-blog/layout/index.ejs","hash":"f05ec4cd1b8d57c234ba54b14547015a0325fcf1","modified":1485084117413},{"_id":"themes/clean-blog/layout/layout.ejs","hash":"acc791dc4346c135ce4cac3cdeba6f96708115e5","modified":1485083344568},{"_id":"themes/clean-blog/layout/page.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1485083344570},{"_id":"themes/clean-blog/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1485083344571},{"_id":"themes/clean-blog/source/css/article.styl","hash":"64a58eaaf711dd548016b5d67aca00b33bdccdad","modified":1485152447315},{"_id":"themes/clean-blog/source/css/base.styl","hash":"501a63d0dfef58a1b98680e1411732ea16c89bc1","modified":1485152423219},{"_id":"themes/clean-blog/source/css/mixins.styl","hash":"f1daed6271d18f9069a4a41f43fe5588e4dd59cb","modified":1485138971818},{"_id":"themes/clean-blog/source/css/variables.styl","hash":"06e16f64020cbddf2c2c49ef45f940141a1b2ada","modified":1485086731194},{"_id":"themes/clean-blog/source/css/style.styl","hash":"7200d572751c1f5888b3d0df25bf503a3f31ca2d","modified":1485083344607},{"_id":"themes/clean-blog/source/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1485083344615},{"_id":"themes/clean-blog/layout/_partial/after-footer.ejs","hash":"da52d35a9a996e90a608a4b0f6cbe47cf512244f","modified":1485086185165},{"_id":"themes/clean-blog/layout/_partial/article-archive.ejs","hash":"75b9b24c226eda4884752a868177b590d3e8b06f","modified":1485083344361},{"_id":"themes/clean-blog/layout/_partial/article-categories.ejs","hash":"b494e4a50f63d66e545da449af18a7198a057bd6","modified":1485083344377},{"_id":"themes/clean-blog/layout/_partial/article-full.ejs","hash":"12b8388ca3c729104225e44f247246501c925c14","modified":1485083344398},{"_id":"themes/clean-blog/layout/_partial/article-index.ejs","hash":"4545f81383a7209ae582dd090ed2067dab7ffca3","modified":1485087843649},{"_id":"themes/clean-blog/layout/_partial/comments.ejs","hash":"3eeae54c507cb1378f74505dbf2221a9f93741a9","modified":1485151155835},{"_id":"themes/clean-blog/layout/_partial/article-tags.ejs","hash":"12524df0c1ce5136a8f88cea2fe550f9e1b47b19","modified":1485083344439},{"_id":"themes/clean-blog/layout/_partial/footer.ejs","hash":"566fb4ad5a9b1755d43af8d892c770e2970c8749","modified":1485151356920},{"_id":"themes/clean-blog/layout/_partial/gallery.ejs","hash":"15e9562d0f6146e25e22856693d1312cd3ade4af","modified":1485083344460},{"_id":"themes/clean-blog/layout/_partial/google-analytics.ejs","hash":"18d40f0033c9d424bfd5b7d50d86d1731426240c","modified":1485151556647},{"_id":"themes/clean-blog/layout/_partial/head.ejs","hash":"eea3dd6f53b4419d0754e1940ffd5ba96ca00bb2","modified":1485152637400},{"_id":"themes/clean-blog/layout/_partial/menu.ejs","hash":"3c51a2a2f950ab2ca80f10d3d3941d5d8cd08ec7","modified":1485083344515},{"_id":"themes/clean-blog/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1485083344518},{"_id":"themes/clean-blog/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1485083344625},{"_id":"themes/clean-blog/source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1485083344620},{"_id":"public/博客迁移到hexo/index.html","hash":"44c700eb4e319be39a6f3307ac235553c8ac7656","modified":1485152683139},{"_id":"public/自己撸一个Promise库的过程/index.html","hash":"4270dbb47bb9ded8a4ae4064ad2dcd0a9037d54a","modified":1485152683142},{"_id":"public/实现一个简单的promise队列/index.html","hash":"64fa375edbe1c82327c401490cc927a46a6ac542","modified":1485152683142},{"_id":"public/javaScript的函数柯里化/index.html","hash":"28bee8d61bb5343217a74d815a40b0724ecc9eff","modified":1485152683142},{"_id":"public/promise的日常应用/index.html","hash":"696215eb24bf4c6d1f2923ac825c218bc54e846b","modified":1485152683142},{"_id":"public/mingw32缺少posix_memalign函数/index.html","hash":"9f3d28336b1376105c14f1c0744d7cca5c9e45ff","modified":1485152683142},{"_id":"public/个人博客绝赞内测中/index.html","hash":"b8c72b830063b7728ddf4dfd85cbea63f91da9fc","modified":1485152683142},{"_id":"public/categories/神秘代码/index.html","hash":"31182b9fd4376701d520f981a079b1c28456cf90","modified":1485152683142},{"_id":"public/categories/班门弄斧/index.html","hash":"431e2518021ca25d2b2ef31c4e3b8f6a235bd8d8","modified":1485152683143},{"_id":"public/categories/随笔/index.html","hash":"ebff56a9d9e00a149f06aaf3890824c6617ae9cc","modified":1485152683143},{"_id":"public/archives/page/2/index.html","hash":"d29b14281b3268b5619d0c70f2fc31155335673d","modified":1485152683143},{"_id":"public/archives/index.html","hash":"0a122391942ec16fc15eeecbbe738cf29a2a6847","modified":1485152683143},{"_id":"public/archives/2015/index.html","hash":"43552aa29dc4650ea65625fcccc39fa86fa2ee26","modified":1485152683143},{"_id":"public/archives/2015/11/index.html","hash":"8df4e4b98231d0f8afead31db4aa01c48391ca0d","modified":1485152683143},{"_id":"public/archives/2015/12/index.html","hash":"e8e1b2fca29ee956645962e442623ef6f1a8f701","modified":1485152683143},{"_id":"public/archives/2016/index.html","hash":"16169287066ba641c58b1faef260c929a10cce85","modified":1485152683143},{"_id":"public/archives/2016/01/index.html","hash":"83c4d8f912a6367ac833a814261c287e0c5d4ed7","modified":1485152683143},{"_id":"public/archives/2016/04/index.html","hash":"47a7b809ebaf8ea3180e81d6a564daea74c61892","modified":1485152683143},{"_id":"public/archives/2016/02/index.html","hash":"54574a55806a2702499a2e4c3689662311a68c30","modified":1485152683143},{"_id":"public/archives/2016/05/index.html","hash":"8a678b8fad52013f208975d65c71dcf09973349f","modified":1485152683143},{"_id":"public/archives/2016/08/index.html","hash":"5b2b46867b84b5d6329d96939c9e6472c24a2293","modified":1485152683143},{"_id":"public/archives/2016/09/index.html","hash":"e149d118f65d2a98e30e031b2f6a8a0b9dd83f2a","modified":1485152683144},{"_id":"public/archives/2017/index.html","hash":"2aff0d090772005d22b466ceba563d658273a6e2","modified":1485152683144},{"_id":"public/archives/2017/01/index.html","hash":"8736d481f2c7621b5737f25996eb5a18fd9c5625","modified":1485152683144},{"_id":"public/index.html","hash":"c3a61dc61f6834829444de2724e5f03812564be5","modified":1485152683144},{"_id":"public/page/2/index.html","hash":"58b0182791e61d2944489e819fa5b80c2e71024b","modified":1485152683144},{"_id":"public/tags/nodejs/index.html","hash":"126def530685f1ec2d4f760d9030047409407aaf","modified":1485152683144},{"_id":"public/tags/stream/index.html","hash":"a6a8e19ce190ba85ded4bbac6cbb4e7c85454727","modified":1485152683144},{"_id":"public/tags/javascript/index.html","hash":"64bd9373a8a0d5f3df07cde85db0c6acfc1c272a","modified":1485152683144},{"_id":"public/tags/Proxy/index.html","hash":"74c41c40ae6931da559406312bd1d50e49a5b374","modified":1485152683144},{"_id":"public/tags/Promise/index.html","hash":"909617adfad22b61e66684d65e27ec8a0c04061f","modified":1485152683144},{"_id":"public/tags/ES6/index.html","hash":"394c87dddf44e460ca390e3318621183fee62d5c","modified":1485152683144},{"_id":"public/tags/encoding/index.html","hash":"b9283d0cf765a18c3f126c4d3762bb455361bc78","modified":1485152683144},{"_id":"public/tags/es6/index.html","hash":"68a76a13c6e36e68114b4b38bac9baae545c2c76","modified":1485152683145},{"_id":"public/tags/promise/index.html","hash":"6fcfaf71a8265a860cced4f209db8caa89159817","modified":1485152683145},{"_id":"public/tags/express/index.html","hash":"fcf9c3c12747f4ae6b143a6345e0d191a31e4757","modified":1485152683145},{"_id":"public/Node处理字符编码相关经验/index.html","hash":"7bb61b9e3c0e1a0f46367326f6dd7e58a25ea64c","modified":1485152683145},{"_id":"public/Proxy实现Promise同步调用逻辑/index.html","hash":"6b37c36447a1509f86deff50e3e7b71abb992d01","modified":1485152683145},{"_id":"public/Proxy对象仿Scala的通配符函数调用/index.html","hash":"e6456b08d38a904b8eec78db8b66abe56adcd485","modified":1485152683145},{"_id":"public/NodeJS：Stream研究笔记/index.html","hash":"12d35f6afec8f0bab17dc13771c765917db8a393","modified":1485152683145},{"_id":"public/javascript模板渲染研究笔记（一）/index.html","hash":"6e9319d1d0354f0bdcaa4b91dbf58118a568bf25","modified":1485152683145},{"_id":"public/tags/C/index.html","hash":"3519f27a0a88762b45eba40303252cc3e98c6510","modified":1485152683148},{"_id":"public/favicon.ico","hash":"11c8f3376cd3d5c578f72b15265614b1c91c0921","modified":1485152683148},{"_id":"public/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1485152683148},{"_id":"public/css/article.css","hash":"b6e5dc135d7a6416b1b8e67bcc32ddf8ab4aa242","modified":1485152683700},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485152683701},{"_id":"public/css/style.css","hash":"22d30eabfba32bea71fdc70688e538cf3f63ceca","modified":1485152683701},{"_id":"public/css/mixins.css","hash":"b9e01ee658f10b7b381d209f384c1593237a965c","modified":1485152683701},{"_id":"public/css/base.css","hash":"2ea66e3a09a37767a9f2e918fe8ffac3fca08ad4","modified":1485152683701},{"_id":"public/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1485152683701},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1485152683708}],"Category":[{"name":"神秘代码","_id":"ciy9pk7xh0002fkmxaia476oi"},{"name":"班门弄斧","_id":"ciy9pk7y1000jfkmxrkc2sl4a"},{"name":"随笔","_id":"ciy9pk7ya000yfkmxfyaqsy52"}],"Data":[],"Page":[],"Post":[{"title":"NodeJS:Stream研究笔记","desc":"相信学过nodejs的人都必然会接触到nodejs中的流（stream）","date":"2016-02-15T13:00:21.199Z","author":"ngtmuzi","_content":"　　相信学过`nodejs`的人都必然会接触到`nodejs`中的流（`stream`），不提从`fs`、`net`、`http`这些基础模块，到`express`、`request`、`mongodb`这些常用模块，处处都有流的身影。在初学时我也曾被`pipe`方法的强大特性吓到，参看`request`的文档：\n\n```javascript\nrequest('http://google.com/doodle.png').pipe(fs.createWriteStream('doodle.png'));\n\nfs.createReadStream('file.json').pipe(request.put('http://mysite.com/obj.json'));\n\nrequest.get('http://google.com/img.png').pipe(request.put('http://mysite.com/img.png'));\n```\n　　从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。\n\n　　流在`nodejs`内部提供的方法都是事件式的，需要用`on`方法将我们的回调函数挂在相应的事件上，如`close`、`end`、`data`、`drain`等，这种形式与`nodejs`异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。\n\n　　流的`pipe`方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个`pipe`就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现`pipe`也不是很复杂，主要的业务代码如下\n\n```javascript\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n};\n```\n　　就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。\n\n---\n　　以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：\n\n* `net.createServer`方法接收一个函数，用于获得`socket`套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次`data`事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……\n\n* `http`也是跟流打交道很多的模块，比如`http.request`函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过`error`事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。\n\n```javascript\nvar req = http.request('http://baidu.com', function (res) {\n  console.log(res.headers);     //调用回调的时候，已经获取到了http头\n  res.on('data', console.log);  //读http正文（表单部分存储于此）\n});\nreq.end('hello');  //只有请求流写完之后，才后真正进行http请求\n````\n* fs模块的文件流有一个很实用的特性，那就是指定读写位置，如`fs.createReadStream`函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，`express`模块中负责静态文件服务的`send`模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句\n```javascript\n// pipe\nvar stream = fs.createReadStream(path, options)\nstream.pipe(res);\n```\n* 而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是`options`中的`flags`参数，当取默认值'w'时，它每次都会重写文件，而改成'r+'，就不会将文件清空。\n\n* `mongodb`的node模块为配合`GridFS`功能，也使用了流的特性来进行文件读写，参见`GridFSBucket`类。\n\n　　在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用`on('error')`来自行捕获，之后就可以愉快地使用各种`pipe`了~","source":"_posts/NodeJS：Stream研究笔记.md","raw":"---\ntitle: NodeJS:Stream研究笔记    \ndesc: 相信学过nodejs的人都必然会接触到nodejs中的流（stream） \ndate: 2016-2-15 21:00:21.199\ntags: \n- nodejs\n- stream  \nauthor: ngtmuzi  \ncategory: 神秘代码\n---\n　　相信学过`nodejs`的人都必然会接触到`nodejs`中的流（`stream`），不提从`fs`、`net`、`http`这些基础模块，到`express`、`request`、`mongodb`这些常用模块，处处都有流的身影。在初学时我也曾被`pipe`方法的强大特性吓到，参看`request`的文档：\n\n```javascript\nrequest('http://google.com/doodle.png').pipe(fs.createWriteStream('doodle.png'));\n\nfs.createReadStream('file.json').pipe(request.put('http://mysite.com/obj.json'));\n\nrequest.get('http://google.com/img.png').pipe(request.put('http://mysite.com/img.png'));\n```\n　　从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。\n\n　　流在`nodejs`内部提供的方法都是事件式的，需要用`on`方法将我们的回调函数挂在相应的事件上，如`close`、`end`、`data`、`drain`等，这种形式与`nodejs`异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。\n\n　　流的`pipe`方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个`pipe`就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现`pipe`也不是很复杂，主要的业务代码如下\n\n```javascript\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n};\n```\n　　就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。\n\n---\n　　以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：\n\n* `net.createServer`方法接收一个函数，用于获得`socket`套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次`data`事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……\n\n* `http`也是跟流打交道很多的模块，比如`http.request`函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过`error`事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。\n\n```javascript\nvar req = http.request('http://baidu.com', function (res) {\n  console.log(res.headers);     //调用回调的时候，已经获取到了http头\n  res.on('data', console.log);  //读http正文（表单部分存储于此）\n});\nreq.end('hello');  //只有请求流写完之后，才后真正进行http请求\n````\n* fs模块的文件流有一个很实用的特性，那就是指定读写位置，如`fs.createReadStream`函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，`express`模块中负责静态文件服务的`send`模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句\n```javascript\n// pipe\nvar stream = fs.createReadStream(path, options)\nstream.pipe(res);\n```\n* 而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是`options`中的`flags`参数，当取默认值'w'时，它每次都会重写文件，而改成'r+'，就不会将文件清空。\n\n* `mongodb`的node模块为配合`GridFS`功能，也使用了流的特性来进行文件读写，参见`GridFSBucket`类。\n\n　　在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用`on('error')`来自行捕获，之后就可以愉快地使用各种`pipe`了~","slug":"NodeJS：Stream研究笔记","published":1,"updated":"2017-01-23T02:26:43.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7x60000fkmxo4lol2it","content":"<p>　　相信学过<code>nodejs</code>的人都必然会接触到<code>nodejs</code>中的流（<code>stream</code>），不提从<code>fs</code>、<code>net</code>、<code>http</code>这些基础模块，到<code>express</code>、<code>request</code>、<code>mongodb</code>这些常用模块，处处都有流的身影。在初学时我也曾被<code>pipe</code>方法的强大特性吓到，参看<code>request</code>的文档：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">request(<span class=\"string\">'http://google.com/doodle.png'</span>).pipe(fs.createWriteStream(<span class=\"string\">'doodle.png'</span>));</div><div class=\"line\"></div><div class=\"line\">fs.createReadStream(<span class=\"string\">'file.json'</span>).pipe(request.put(<span class=\"string\">'http://mysite.com/obj.json'</span>));</div><div class=\"line\"></div><div class=\"line\">request.get(<span class=\"string\">'http://google.com/img.png'</span>).pipe(request.put(<span class=\"string\">'http://mysite.com/img.png'</span>));</div></pre></td></tr></table></figure>\n<p>　　从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。</p>\n<p>　　流在<code>nodejs</code>内部提供的方法都是事件式的，需要用<code>on</code>方法将我们的回调函数挂在相应的事件上，如<code>close</code>、<code>end</code>、<code>data</code>、<code>drain</code>等，这种形式与<code>nodejs</code>异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。</p>\n<p>　　流的<code>pipe</code>方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个<code>pipe</code>就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现<code>pipe</code>也不是很复杂，主要的业务代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Stream.prototype.pipe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dest, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> source = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondata</span>(<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (dest.writable) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === dest.write(chunk) &amp;&amp; source.pause) &#123;</div><div class=\"line\">        source.pause();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  source.on(<span class=\"string\">'data'</span>, ondata);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondrain</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (source.readable &amp;&amp; source.resume) &#123;</div><div class=\"line\">      source.resume();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dest.on(<span class=\"string\">'drain'</span>, ondrain);</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>　　就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。</p>\n<hr>\n<p>　　以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：</p>\n<ul>\n<li><p><code>net.createServer</code>方法接收一个函数，用于获得<code>socket</code>套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次<code>data</code>事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……</p>\n</li>\n<li><p><code>http</code>也是跟流打交道很多的模块，比如<code>http.request</code>函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过<code>error</code>事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> req = http.request(<span class=\"string\">'http://baidu.com'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(res.headers);     <span class=\"comment\">//调用回调的时候，已经获取到了http头</span></div><div class=\"line\">  res.on(<span class=\"string\">'data'</span>, <span class=\"built_in\">console</span>.log);  <span class=\"comment\">//读http正文（表单部分存储于此）</span></div><div class=\"line\">&#125;);</div><div class=\"line\">req.end(<span class=\"string\">'hello'</span>);  <span class=\"comment\">//只有请求流写完之后，才后真正进行http请求</span></div><div class=\"line\"><span class=\"string\">`</span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>fs模块的文件流有一个很实用的特性，那就是指定读写位置，如<code>fs.createReadStream</code>函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，<code>express</code>模块中负责静态文件服务的<code>send</code>模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// pipe</span></div><div class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(path, options)</div><div class=\"line\">stream.pipe(res);</div></pre></td></tr></table></figure>\n</li>\n<li><p>而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是<code>options</code>中的<code>flags</code>参数，当取默认值’w’时，它每次都会重写文件，而改成’r+’，就不会将文件清空。</p>\n</li>\n<li><p><code>mongodb</code>的node模块为配合<code>GridFS</code>功能，也使用了流的特性来进行文件读写，参见<code>GridFSBucket</code>类。</p>\n</li>\n</ul>\n<p>　　在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用<code>on(&#39;error&#39;)</code>来自行捕获，之后就可以愉快地使用各种<code>pipe</code>了~</p>\n","excerpt":"","more":"<p>　　相信学过<code>nodejs</code>的人都必然会接触到<code>nodejs</code>中的流（<code>stream</code>），不提从<code>fs</code>、<code>net</code>、<code>http</code>这些基础模块，到<code>express</code>、<code>request</code>、<code>mongodb</code>这些常用模块，处处都有流的身影。在初学时我也曾被<code>pipe</code>方法的强大特性吓到，参看<code>request</code>的文档：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">request(<span class=\"string\">'http://google.com/doodle.png'</span>).pipe(fs.createWriteStream(<span class=\"string\">'doodle.png'</span>));</div><div class=\"line\"></div><div class=\"line\">fs.createReadStream(<span class=\"string\">'file.json'</span>).pipe(request.put(<span class=\"string\">'http://mysite.com/obj.json'</span>));</div><div class=\"line\"></div><div class=\"line\">request.get(<span class=\"string\">'http://google.com/img.png'</span>).pipe(request.put(<span class=\"string\">'http://mysite.com/img.png'</span>));</div></pre></td></tr></table></figure>\n<p>　　从网络流到文件流的转换自然直观，甚至可以以此实现最简单的代理服务器或静态文件服务器。最近在研究一些文件上传的东西，就重温了一下流，才发现其中大有乾坤。</p>\n<p>　　流在<code>nodejs</code>内部提供的方法都是事件式的，需要用<code>on</code>方法将我们的回调函数挂在相应的事件上，如<code>close</code>、<code>end</code>、<code>data</code>、<code>drain</code>等，这种形式与<code>nodejs</code>异步的惯用套路——callback相差甚远，事件响应式编程也是一种可行的异步编程解决方案，不过势必会造成逻辑被不同的事件响应函数所分割，有时事件触发的先后顺序也会引起困扰，当然这不是我要讨论的重点。</p>\n<p>　　流的<code>pipe</code>方法在初学者的我看来简直是万能钥匙，只要搞到一个可读流和一个可写流，一个<code>pipe</code>就完事了，里面具体是什么原理都不用管。不过在看过源码后才发现<code>pipe</code>也不是很复杂，主要的业务代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Stream.prototype.pipe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dest, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> source = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondata</span>(<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (dest.writable) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"literal\">false</span> === dest.write(chunk) &amp;&amp; source.pause) &#123;</div><div class=\"line\">        source.pause();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  source.on(<span class=\"string\">'data'</span>, ondata);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ondrain</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (source.readable &amp;&amp; source.resume) &#123;</div><div class=\"line\">      source.resume();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dest.on(<span class=\"string\">'drain'</span>, ondrain);</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>　　就是简单的对流的事件的应用，当可写流（ws）处于可写时，打开可读流（rs），当rs的数据读进来了，就往ws写，写到满了就暂停读入rs，就是这样一种循环，至于具体不同种类的流之间的细节，全都被封起来了。</p>\n<hr>\n<p>　　以上是最基本的流的原理，而在不同的模块中，流也有很多有趣的用法：</p>\n<ul>\n<li><p><code>net.createServer</code>方法接收一个函数，用于获得<code>socket</code>套接字对象，而它就是一个可读可写流对象，我们需要自行处理它所接收的数据，因为TCP流之间的数据没有间隔，所以如何从连续的流中获取一个完整的消息包，也是很多人纠结的问题，常用的方法是定义包的前几位作为包头，在其中定义整个包的长度，或者干脆指定固定的包长度之类的，需要注意的是每次<code>data</code>事件收到的数据需要好好保存，它其中可能包含多个包，也有可能只是一个包的一小部分，想要在底层搞个应用也不容易啊……</p>\n</li>\n<li><p><code>http</code>也是跟流打交道很多的模块，比如<code>http.request</code>函数本身就返回一个可写流，而它的回调函数又接受一个可读流，而且需要在可写流（也就是http请求流）写完之后，才会真的去进行http请求，获取到http头之后，再传给回调函数一个可读流，之后的http正文才从可读流中流过来，如果中途出错，会通过<code>error</code>事件抛出。可见此过程很不直观，但在众多的err开头的回调函数中，也很新奇。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> req = http.request(<span class=\"string\">'http://baidu.com'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(res.headers);     <span class=\"comment\">//调用回调的时候，已经获取到了http头</span></div><div class=\"line\">  res.on(<span class=\"string\">'data'</span>, <span class=\"built_in\">console</span>.log);  <span class=\"comment\">//读http正文（表单部分存储于此）</span></div><div class=\"line\">&#125;);</div><div class=\"line\">req.end(<span class=\"string\">'hello'</span>);  <span class=\"comment\">//只有请求流写完之后，才后真正进行http请求</span></div><div class=\"line\"><span class=\"string\">`</span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>fs模块的文件流有一个很实用的特性，那就是指定读写位置，如<code>fs.createReadStream</code>函数可以指定文件读取的开始和结束位置，由此可以联想到最直接的用法，就是与http服务配合，作为静态文件服务器，以提供文件的多线程下载、断点续传等功能，<code>express</code>模块中负责静态文件服务的<code>send</code>模块，大多数代码负责从http请求头中获取文件的范围（Range）和查找文件，而最核心的代码只有这一句</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// pipe</span></div><div class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(path, options)</div><div class=\"line\">stream.pipe(res);</div></pre></td></tr></table></figure>\n</li>\n<li><p>而写文件流也可以指定写入的起始位置，可以很自然地想到，这对于前面的断点续传等功能有多大的帮助。这里值得一提的是<code>options</code>中的<code>flags</code>参数，当取默认值’w’时，它每次都会重写文件，而改成’r+’，就不会将文件清空。</p>\n</li>\n<li><p><code>mongodb</code>的node模块为配合<code>GridFS</code>功能，也使用了流的特性来进行文件读写，参见<code>GridFSBucket</code>类。</p>\n</li>\n</ul>\n<p>　　在使用各式各样流的时候，要记得的一点是，错误不再位于回调参数的第一位，需要用<code>on(&#39;error&#39;)</code>来自行捕获，之后就可以愉快地使用各种<code>pipe</code>了~</p>\n"},{"title":"Proxy实现Promise同步调用逻辑","desc":"Proxy + Promise = 逻辑同步","date":"2016-08-08T15:30:08.830Z","author":"ngtmuzi","_content":"　　我们在很多使用Promise的时候都会有如下的用法\n```javascript\nMongoClient.connect()\n  .then(function (db) {\n    var col = db.collection('something');\n    col.find().toArray()\n      .then(console.log, console.error);\n  });\n```\n　　真正的连接对象在`connect()`之后才返回，只能在`then`回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子\n```javascript\nvar db;\nMongoClient.connect()\n  .then(function (_db) {\n    db = _db;\n  });\n//别的地方\ndb.collection('otherthing')....\n```\n　　这样的缺点是在连接未建立时访问`db`会引发异常，当然最正确的做法应该是\n```javascript\nvar db = MongoClient.connect();\n//别的地方\ndb.then(function (_db) {\n  _db.collection('otherthing')....\n});\n```\n　　可以保持对一个连接的复用，但这样还是嵌了一层回调。\n\n　　在之前用`Proxy`写了几个玩具之后，有个念头渐渐浮上心头，`Proxy`也许可以改变这个模式，我们可以用`Proxy`预先收集好调用链，然后再将其内部转为`Promise`的调用链，简单来说思路如下：\n\n1. 先将原始数据用`Promise.resolve`包裹，使其成为一个`Promise`对象，并返回该对象的代理`Proxy`\n\n2. 对该`Proxy`的`get`和`apply`操作实际上就是在后面多加一个`.then`回调，并会继续返回`Proxy`，以实现链式调用\n\n3. 当将`Proxy`作为函数运行时对参数预先做`Promise.resolve`处理，使得它可以接受`Promise`参数\n\n4. 在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能\n\n5. 最终的值从`.then中`获取，`Promise`的特性保证了最终值的可达性\n\n\n　　多说无用，以下是一些示例：\n\n```javascript\nvar request = require('request-promise');\nvar _       = require('promixy');\n\nvar parse   = _(JSON.parse);            //proxy a function\nvar docJson = request('https://nodejs.org/api/documentation.json');  //a promise \nvar obj     = parse(docJson);           //wait the promise result\n\nobj.miscs[0].textRaw.then(console.log, console.error);\n```\n　　首先代理了`JSON.parse`使其可以接受`Promise`类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过`console.log`打印出来\n\n　　当试图从`undefined`中读取属性时，会返回类似这样的错误\n```\nTypeError: can't read property 'textRaw' in {Promixy}(1 args).miscs.10, it got a undefined\n```\n　　虽然有些不直观但好歹调用链是能看出来了\n```javascript\n_(Promise.resolve(_(_(_(111))))).then(_(console.log), _(console.error));\n//111\n```\n　　即使嵌了很多层，这个`Proxy`依然是`Promise`的代理，所以最后还是可以得到正确的结果的\n\n　　而刚才的mongo连接也可以简化为\n\n```javascript\nvar db = _(MongoClient.connect());\n//别的地方\ndb.collection('something')...\n```\n　　实质上是`Proxy`在内部代替用户嵌了一层`.then`，代码上更加简单直观，且从它上面取的所有属性依然有`Proxy`包裹，所以你甚至可以实现这样变态的调用方式\n\n```javascript\ndb.collection('something').find().toArray()[0].somekey\n  .then(console.log,console.error);\n```\n　　直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法\n\n　　综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，[npm地址](https://www.npmjs.com/package/promixy)，如果你有任何建议或发现了bug，欢迎到[github](https://github.com/ngtmuzi/promixy)反馈","source":"_posts/Proxy实现Promise同步调用逻辑.md","raw":"---\ntitle: Proxy实现Promise同步调用逻辑  \ndesc: Proxy + Promise = 逻辑同步  \ndate: 2016-8-8 23:30:08.830\ntags: \n- javascript\n- Proxy\n- Promise\n- ES6\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n　　我们在很多使用Promise的时候都会有如下的用法\n```javascript\nMongoClient.connect()\n  .then(function (db) {\n    var col = db.collection('something');\n    col.find().toArray()\n      .then(console.log, console.error);\n  });\n```\n　　真正的连接对象在`connect()`之后才返回，只能在`then`回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子\n```javascript\nvar db;\nMongoClient.connect()\n  .then(function (_db) {\n    db = _db;\n  });\n//别的地方\ndb.collection('otherthing')....\n```\n　　这样的缺点是在连接未建立时访问`db`会引发异常，当然最正确的做法应该是\n```javascript\nvar db = MongoClient.connect();\n//别的地方\ndb.then(function (_db) {\n  _db.collection('otherthing')....\n});\n```\n　　可以保持对一个连接的复用，但这样还是嵌了一层回调。\n\n　　在之前用`Proxy`写了几个玩具之后，有个念头渐渐浮上心头，`Proxy`也许可以改变这个模式，我们可以用`Proxy`预先收集好调用链，然后再将其内部转为`Promise`的调用链，简单来说思路如下：\n\n1. 先将原始数据用`Promise.resolve`包裹，使其成为一个`Promise`对象，并返回该对象的代理`Proxy`\n\n2. 对该`Proxy`的`get`和`apply`操作实际上就是在后面多加一个`.then`回调，并会继续返回`Proxy`，以实现链式调用\n\n3. 当将`Proxy`作为函数运行时对参数预先做`Promise.resolve`处理，使得它可以接受`Promise`参数\n\n4. 在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能\n\n5. 最终的值从`.then中`获取，`Promise`的特性保证了最终值的可达性\n\n\n　　多说无用，以下是一些示例：\n\n```javascript\nvar request = require('request-promise');\nvar _       = require('promixy');\n\nvar parse   = _(JSON.parse);            //proxy a function\nvar docJson = request('https://nodejs.org/api/documentation.json');  //a promise \nvar obj     = parse(docJson);           //wait the promise result\n\nobj.miscs[0].textRaw.then(console.log, console.error);\n```\n　　首先代理了`JSON.parse`使其可以接受`Promise`类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过`console.log`打印出来\n\n　　当试图从`undefined`中读取属性时，会返回类似这样的错误\n```\nTypeError: can't read property 'textRaw' in {Promixy}(1 args).miscs.10, it got a undefined\n```\n　　虽然有些不直观但好歹调用链是能看出来了\n```javascript\n_(Promise.resolve(_(_(_(111))))).then(_(console.log), _(console.error));\n//111\n```\n　　即使嵌了很多层，这个`Proxy`依然是`Promise`的代理，所以最后还是可以得到正确的结果的\n\n　　而刚才的mongo连接也可以简化为\n\n```javascript\nvar db = _(MongoClient.connect());\n//别的地方\ndb.collection('something')...\n```\n　　实质上是`Proxy`在内部代替用户嵌了一层`.then`，代码上更加简单直观，且从它上面取的所有属性依然有`Proxy`包裹，所以你甚至可以实现这样变态的调用方式\n\n```javascript\ndb.collection('something').find().toArray()[0].somekey\n  .then(console.log,console.error);\n```\n　　直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法\n\n　　综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，[npm地址](https://www.npmjs.com/package/promixy)，如果你有任何建议或发现了bug，欢迎到[github](https://github.com/ngtmuzi/promixy)反馈","slug":"Proxy实现Promise同步调用逻辑","published":1,"updated":"2017-01-23T02:24:43.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7xa0001fkmx72pgr4jl","content":"<p>　　我们在很多使用Promise的时候都会有如下的用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">MongoClient.connect()</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">db</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> col = db.collection(<span class=\"string\">'something'</span>);</div><div class=\"line\">    col.find().toArray()</div><div class=\"line\">      .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>　　真正的连接对象在<code>connect()</code>之后才返回，只能在<code>then</code>回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db;</div><div class=\"line\">MongoClient.connect()</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</div><div class=\"line\">    db = _db;</div><div class=\"line\">  &#125;);</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.collection(<span class=\"string\">'otherthing'</span>)....</div></pre></td></tr></table></figure></p>\n<p>　　这样的缺点是在连接未建立时访问<code>db</code>会引发异常，当然最正确的做法应该是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = MongoClient.connect();</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</div><div class=\"line\">  _db.collection(<span class=\"string\">'otherthing'</span>)....</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　可以保持对一个连接的复用，但这样还是嵌了一层回调。</p>\n<p>　　在之前用<code>Proxy</code>写了几个玩具之后，有个念头渐渐浮上心头，<code>Proxy</code>也许可以改变这个模式，我们可以用<code>Proxy</code>预先收集好调用链，然后再将其内部转为<code>Promise</code>的调用链，简单来说思路如下：</p>\n<ol>\n<li><p>先将原始数据用<code>Promise.resolve</code>包裹，使其成为一个<code>Promise</code>对象，并返回该对象的代理<code>Proxy</code></p>\n</li>\n<li><p>对该<code>Proxy</code>的<code>get</code>和<code>apply</code>操作实际上就是在后面多加一个<code>.then</code>回调，并会继续返回<code>Proxy</code>，以实现链式调用</p>\n</li>\n<li><p>当将<code>Proxy</code>作为函数运行时对参数预先做<code>Promise.resolve</code>处理，使得它可以接受<code>Promise</code>参数</p>\n</li>\n<li><p>在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能</p>\n</li>\n<li><p>最终的值从<code>.then中</code>获取，<code>Promise</code>的特性保证了最终值的可达性</p>\n</li>\n</ol>\n<p>　　多说无用，以下是一些示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _       = <span class=\"built_in\">require</span>(<span class=\"string\">'promixy'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parse   = _(<span class=\"built_in\">JSON</span>.parse);            <span class=\"comment\">//proxy a function</span></div><div class=\"line\"><span class=\"keyword\">var</span> docJson = request(<span class=\"string\">'https://nodejs.org/api/documentation.json'</span>);  <span class=\"comment\">//a promise </span></div><div class=\"line\"><span class=\"keyword\">var</span> obj     = parse(docJson);           <span class=\"comment\">//wait the promise result</span></div><div class=\"line\"></div><div class=\"line\">obj.miscs[<span class=\"number\">0</span>].textRaw.then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>　　首先代理了<code>JSON.parse</code>使其可以接受<code>Promise</code>类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过<code>console.log</code>打印出来</p>\n<p>　　当试图从<code>undefined</code>中读取属性时，会返回类似这样的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TypeError: can&apos;t read property &apos;textRaw&apos; in &#123;Promixy&#125;(1 args).miscs.10, it got a undefined</div></pre></td></tr></table></figure></p>\n<p>　　虽然有些不直观但好歹调用链是能看出来了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_(<span class=\"built_in\">Promise</span>.resolve(_(_(_(<span class=\"number\">111</span>))))).then(_(<span class=\"built_in\">console</span>.log), _(<span class=\"built_in\">console</span>.error));</div><div class=\"line\"><span class=\"comment\">//111</span></div></pre></td></tr></table></figure></p>\n<p>　　即使嵌了很多层，这个<code>Proxy</code>依然是<code>Promise</code>的代理，所以最后还是可以得到正确的结果的</p>\n<p>　　而刚才的mongo连接也可以简化为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = _(MongoClient.connect());</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.collection(<span class=\"string\">'something'</span>)...</div></pre></td></tr></table></figure>\n<p>　　实质上是<code>Proxy</code>在内部代替用户嵌了一层<code>.then</code>，代码上更加简单直观，且从它上面取的所有属性依然有<code>Proxy</code>包裹，所以你甚至可以实现这样变态的调用方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.collection(<span class=\"string\">'something'</span>).find().toArray()[<span class=\"number\">0</span>].somekey</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log,<span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>　　直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法</p>\n<p>　　综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，<a href=\"https://www.npmjs.com/package/promixy\" target=\"_blank\" rel=\"external\">npm地址</a>，如果你有任何建议或发现了bug，欢迎到<a href=\"https://github.com/ngtmuzi/promixy\" target=\"_blank\" rel=\"external\">github</a>反馈</p>\n","excerpt":"","more":"<p>　　我们在很多使用Promise的时候都会有如下的用法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">MongoClient.connect()</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">db</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> col = db.collection(<span class=\"string\">'something'</span>);</div><div class=\"line\">    col.find().toArray()</div><div class=\"line\">      .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>　　真正的连接对象在<code>connect()</code>之后才返回，只能在<code>then</code>回调中处理后续的数据库操作，而如果想复用这个连接，就需要在外面用另一个对象保持对它的引用，代码可能就会变成这个样子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db;</div><div class=\"line\">MongoClient.connect()</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</div><div class=\"line\">    db = _db;</div><div class=\"line\">  &#125;);</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.collection(<span class=\"string\">'otherthing'</span>)....</div></pre></td></tr></table></figure></p>\n<p>　　这样的缺点是在连接未建立时访问<code>db</code>会引发异常，当然最正确的做法应该是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = MongoClient.connect();</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_db</span>) </span>&#123;</div><div class=\"line\">  _db.collection(<span class=\"string\">'otherthing'</span>)....</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　可以保持对一个连接的复用，但这样还是嵌了一层回调。</p>\n<p>　　在之前用<code>Proxy</code>写了几个玩具之后，有个念头渐渐浮上心头，<code>Proxy</code>也许可以改变这个模式，我们可以用<code>Proxy</code>预先收集好调用链，然后再将其内部转为<code>Promise</code>的调用链，简单来说思路如下：</p>\n<ol>\n<li><p>先将原始数据用<code>Promise.resolve</code>包裹，使其成为一个<code>Promise</code>对象，并返回该对象的代理<code>Proxy</code></p>\n</li>\n<li><p>对该<code>Proxy</code>的<code>get</code>和<code>apply</code>操作实际上就是在后面多加一个<code>.then</code>回调，并会继续返回<code>Proxy</code>，以实现链式调用</p>\n</li>\n<li><p>当将<code>Proxy</code>作为函数运行时对参数预先做<code>Promise.resolve</code>处理，使得它可以接受<code>Promise</code>参数</p>\n</li>\n<li><p>在内部的取值、调用时做错误捕获，使得在冗长的调用链中捕获错误成为可能</p>\n</li>\n<li><p>最终的值从<code>.then中</code>获取，<code>Promise</code>的特性保证了最终值的可达性</p>\n</li>\n</ol>\n<p>　　多说无用，以下是一些示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _       = <span class=\"built_in\">require</span>(<span class=\"string\">'promixy'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parse   = _(<span class=\"built_in\">JSON</span>.parse);            <span class=\"comment\">//proxy a function</span></div><div class=\"line\"><span class=\"keyword\">var</span> docJson = request(<span class=\"string\">'https://nodejs.org/api/documentation.json'</span>);  <span class=\"comment\">//a promise </span></div><div class=\"line\"><span class=\"keyword\">var</span> obj     = parse(docJson);           <span class=\"comment\">//wait the promise result</span></div><div class=\"line\"></div><div class=\"line\">obj.miscs[<span class=\"number\">0</span>].textRaw.then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>　　首先代理了<code>JSON.parse</code>使其可以接受<code>Promise</code>类型的参数，并挂上长长的一串取属性操作，得到的结果最后通过<code>console.log</code>打印出来</p>\n<p>　　当试图从<code>undefined</code>中读取属性时，会返回类似这样的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TypeError: can&apos;t read property &apos;textRaw&apos; in &#123;Promixy&#125;(1 args).miscs.10, it got a undefined</div></pre></td></tr></table></figure></p>\n<p>　　虽然有些不直观但好歹调用链是能看出来了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">_(<span class=\"built_in\">Promise</span>.resolve(_(_(_(<span class=\"number\">111</span>))))).then(_(<span class=\"built_in\">console</span>.log), _(<span class=\"built_in\">console</span>.error));</div><div class=\"line\"><span class=\"comment\">//111</span></div></pre></td></tr></table></figure></p>\n<p>　　即使嵌了很多层，这个<code>Proxy</code>依然是<code>Promise</code>的代理，所以最后还是可以得到正确的结果的</p>\n<p>　　而刚才的mongo连接也可以简化为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = _(MongoClient.connect());</div><div class=\"line\"><span class=\"comment\">//别的地方</span></div><div class=\"line\">db.collection(<span class=\"string\">'something'</span>)...</div></pre></td></tr></table></figure>\n<p>　　实质上是<code>Proxy</code>在内部代替用户嵌了一层<code>.then</code>，代码上更加简单直观，且从它上面取的所有属性依然有<code>Proxy</code>包裹，所以你甚至可以实现这样变态的调用方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.collection(<span class=\"string\">'something'</span>).find().toArray()[<span class=\"number\">0</span>].somekey</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log,<span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>　　直接取出集合第一条中的某个值，当然我不建议这种很难理解的写法</p>\n<p>　　综上，这个模块还有许多待发现的可用之处，我个人也将它用于了生产环境中，<a href=\"https://www.npmjs.com/package/promixy\">npm地址</a>，如果你有任何建议或发现了bug，欢迎到<a href=\"https://github.com/ngtmuzi/promixy\">github</a>反馈</p>\n"},{"title":"Node处理字符编码相关经验","desc":"在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道","date":"2016-05-25T02:10:55.618Z","author":"ngtmuzi","_content":"　　在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：\n\n　　首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用`iconv-lite`就行了\n\n\n自动判断文本编码并解码为UTF8\n---\n```javascript\nvar iconv     = require('iconv-lite');\nvar jschardet = require('jschardet');\nfunction readText(filePath) {\n  var fileData = fs.readFileSync(filePath);\n  var encoding = jschardet.detect(fileData).encoding;\n  if (!iconv.encodingExists(encoding)) encoding = 'utf8';\n  return iconv.decode(fileData, encoding);\n}\n```\n　　`jschardet`模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用`iconv-lite`转成UTF8即可\n\n\n读取GBK编码页面\n---\n```javascript\nvar request = require('request-promise');\nvar iconv   = require('iconv-lite');\nrequest('http://someurl.com', {encoding: null})\n  .then(s=>iconv.decode(s, 'gbk'))\n  .then(console.log, console.error);\n```\n　　将`encoding`指定为`null`的时候`request`模块会返回一个`buffer`，我们将其手动gbk解码即可\n\n\n处理gbk编码的urlencode\n---\n```javascript\nvar iconv   = require('iconv-lite');\nvar gbkStr = '%c4%e3%ba%c3';\niconv.decode(new Buffer(gbkStr.replace(/%/g, ''), 'hex'), 'gbk');\n```\n　　`express`在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成`buffer`之后再解码\n\n\n\n转发无法被解码的urlencode\n---\n　　假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的`%c4%e3%ba%c3`，这个时候再通过`request`去请求的时候，再次做了urlencode，会把原字符串里的百分号转成`%25`，那么目标方接到参数的时候就变成`%25c4%25e3%25ba%25c3`，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下\n```javascript\nvar qs   = require('querystring');\nvar data = {gbkStr: '%c4%e3%ba%c3'};\n\nfunction urlEncode(s) {\n  return qs.escape(s.replace(/%(\\w{2})/g, '-_-$1')).replace(/-_-(\\W{2})/g, '%$1');\n}\n\n//1、使用原生的queryString\nvar url = 'someurl' + qs.stringify(data, null, null, {encodeURIComponent: urlEncode});\n\n//2、直接用于request\nrequest('someurl', {\n  qs                : data,\n  qsStringifyOptions: {options: {encodeURIComponent: urlEncode}}\n}).then(console.log, console.error);\n```\n　　关于`querystring`更多的细节参看[官方文档](https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options)\n\n　　我们可以让`querystring`结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱","source":"_posts/Node处理字符编码相关经验.md","raw":"---\ntitle: Node处理字符编码相关经验\ndesc: 在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道  \ndate: 2016-5-25 10:10:55.618\ntags: \n- nodejs\n- encoding\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n　　在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：\n\n　　首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用`iconv-lite`就行了\n\n\n自动判断文本编码并解码为UTF8\n---\n```javascript\nvar iconv     = require('iconv-lite');\nvar jschardet = require('jschardet');\nfunction readText(filePath) {\n  var fileData = fs.readFileSync(filePath);\n  var encoding = jschardet.detect(fileData).encoding;\n  if (!iconv.encodingExists(encoding)) encoding = 'utf8';\n  return iconv.decode(fileData, encoding);\n}\n```\n　　`jschardet`模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用`iconv-lite`转成UTF8即可\n\n\n读取GBK编码页面\n---\n```javascript\nvar request = require('request-promise');\nvar iconv   = require('iconv-lite');\nrequest('http://someurl.com', {encoding: null})\n  .then(s=>iconv.decode(s, 'gbk'))\n  .then(console.log, console.error);\n```\n　　将`encoding`指定为`null`的时候`request`模块会返回一个`buffer`，我们将其手动gbk解码即可\n\n\n处理gbk编码的urlencode\n---\n```javascript\nvar iconv   = require('iconv-lite');\nvar gbkStr = '%c4%e3%ba%c3';\niconv.decode(new Buffer(gbkStr.replace(/%/g, ''), 'hex'), 'gbk');\n```\n　　`express`在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成`buffer`之后再解码\n\n\n\n转发无法被解码的urlencode\n---\n　　假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的`%c4%e3%ba%c3`，这个时候再通过`request`去请求的时候，再次做了urlencode，会把原字符串里的百分号转成`%25`，那么目标方接到参数的时候就变成`%25c4%25e3%25ba%25c3`，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下\n```javascript\nvar qs   = require('querystring');\nvar data = {gbkStr: '%c4%e3%ba%c3'};\n\nfunction urlEncode(s) {\n  return qs.escape(s.replace(/%(\\w{2})/g, '-_-$1')).replace(/-_-(\\W{2})/g, '%$1');\n}\n\n//1、使用原生的queryString\nvar url = 'someurl' + qs.stringify(data, null, null, {encodeURIComponent: urlEncode});\n\n//2、直接用于request\nrequest('someurl', {\n  qs                : data,\n  qsStringifyOptions: {options: {encodeURIComponent: urlEncode}}\n}).then(console.log, console.error);\n```\n　　关于`querystring`更多的细节参看[官方文档](https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options)\n\n　　我们可以让`querystring`结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱","slug":"Node处理字符编码相关经验","published":1,"updated":"2017-01-23T02:25:51.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7xk0004fkmxw9els4n1","content":"<p>　　在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：</p>\n<p>　　首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用<code>iconv-lite</code>就行了</p>\n<h2 id=\"自动判断文本编码并解码为UTF8\"><a href=\"#自动判断文本编码并解码为UTF8\" class=\"headerlink\" title=\"自动判断文本编码并解码为UTF8\"></a>自动判断文本编码并解码为UTF8</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> iconv     = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> jschardet = <span class=\"built_in\">require</span>(<span class=\"string\">'jschardet'</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readText</span>(<span class=\"params\">filePath</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fileData = fs.readFileSync(filePath);</div><div class=\"line\">  <span class=\"keyword\">var</span> encoding = jschardet.detect(fileData).encoding;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!iconv.encodingExists(encoding)) encoding = <span class=\"string\">'utf8'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> iconv.decode(fileData, encoding);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　<code>jschardet</code>模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用<code>iconv-lite</code>转成UTF8即可</p>\n<h2 id=\"读取GBK编码页面\"><a href=\"#读取GBK编码页面\" class=\"headerlink\" title=\"读取GBK编码页面\"></a>读取GBK编码页面</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\">request(<span class=\"string\">'http://someurl.com'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"literal\">null</span>&#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">s</span>=&gt;</span>iconv.decode(s, <span class=\"string\">'gbk'</span>))</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>　　将<code>encoding</code>指定为<code>null</code>的时候<code>request</code>模块会返回一个<code>buffer</code>，我们将其手动gbk解码即可</p>\n<h2 id=\"处理gbk编码的urlencode\"><a href=\"#处理gbk编码的urlencode\" class=\"headerlink\" title=\"处理gbk编码的urlencode\"></a>处理gbk编码的urlencode</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> gbkStr = <span class=\"string\">'%c4%e3%ba%c3'</span>;</div><div class=\"line\">iconv.decode(<span class=\"keyword\">new</span> Buffer(gbkStr.replace(<span class=\"regexp\">/%/g</span>, <span class=\"string\">''</span>), <span class=\"string\">'hex'</span>), <span class=\"string\">'gbk'</span>);</div></pre></td></tr></table></figure>\n<p>　　<code>express</code>在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成<code>buffer</code>之后再解码</p>\n<h2 id=\"转发无法被解码的urlencode\"><a href=\"#转发无法被解码的urlencode\" class=\"headerlink\" title=\"转发无法被解码的urlencode\"></a>转发无法被解码的urlencode</h2><p>　　假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的<code>%c4%e3%ba%c3</code>，这个时候再通过<code>request</code>去请求的时候，再次做了urlencode，会把原字符串里的百分号转成<code>%25</code>，那么目标方接到参数的时候就变成<code>%25c4%25e3%25ba%25c3</code>，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> qs   = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">gbkStr</span>: <span class=\"string\">'%c4%e3%ba%c3'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">urlEncode</span>(<span class=\"params\">s</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> qs.escape(s.replace(<span class=\"regexp\">/%(\\w&#123;2&#125;)/g</span>, <span class=\"string\">'-_-$1'</span>)).replace(<span class=\"regexp\">/-_-(\\W&#123;2&#125;)/g</span>, <span class=\"string\">'%$1'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//1、使用原生的queryString</span></div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'someurl'</span> + qs.stringify(data, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、直接用于request</span></div><div class=\"line\">request(<span class=\"string\">'someurl'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">qs</span>                : data,</div><div class=\"line\">  <span class=\"attr\">qsStringifyOptions</span>: &#123;<span class=\"attr\">options</span>: &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;&#125;</div><div class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure></p>\n<p>　　关于<code>querystring</code>更多的细节参看<a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n<p>　　我们可以让<code>querystring</code>结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱</p>\n","excerpt":"","more":"<p>　　在UTF8与GBK之间摸爬滚打一段时间后摸索出来了一些门道：</p>\n<p>　　首先要确定一点原则，就是尽可能往UTF8转，因为Node本身是用UTF8的，需要转成其他编码的时候再用<code>iconv-lite</code>就行了</p>\n<h2 id=\"自动判断文本编码并解码为UTF8\"><a href=\"#自动判断文本编码并解码为UTF8\" class=\"headerlink\" title=\"自动判断文本编码并解码为UTF8\"></a>自动判断文本编码并解码为UTF8</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> iconv     = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> jschardet = <span class=\"built_in\">require</span>(<span class=\"string\">'jschardet'</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readText</span>(<span class=\"params\">filePath</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fileData = fs.readFileSync(filePath);</div><div class=\"line\">  <span class=\"keyword\">var</span> encoding = jschardet.detect(fileData).encoding;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!iconv.encodingExists(encoding)) encoding = <span class=\"string\">'utf8'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> iconv.decode(fileData, encoding);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　<code>jschardet</code>模块的原理不用看源码都能大概猜到，是判断文本二进制码的范围，因为不同的编码占用的区块是有差异的，得到编码之后再用<code>iconv-lite</code>转成UTF8即可</p>\n<h2 id=\"读取GBK编码页面\"><a href=\"#读取GBK编码页面\" class=\"headerlink\" title=\"读取GBK编码页面\"></a>读取GBK编码页面</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\">request(<span class=\"string\">'http://someurl.com'</span>, &#123;<span class=\"attr\">encoding</span>: <span class=\"literal\">null</span>&#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">s</span>=&gt;</span>iconv.decode(s, <span class=\"string\">'gbk'</span>))</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure>\n<p>　　将<code>encoding</code>指定为<code>null</code>的时候<code>request</code>模块会返回一个<code>buffer</code>，我们将其手动gbk解码即可</p>\n<h2 id=\"处理gbk编码的urlencode\"><a href=\"#处理gbk编码的urlencode\" class=\"headerlink\" title=\"处理gbk编码的urlencode\"></a>处理gbk编码的urlencode</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> iconv   = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> gbkStr = <span class=\"string\">'%c4%e3%ba%c3'</span>;</div><div class=\"line\">iconv.decode(<span class=\"keyword\">new</span> Buffer(gbkStr.replace(<span class=\"regexp\">/%/g</span>, <span class=\"string\">''</span>), <span class=\"string\">'hex'</span>), <span class=\"string\">'gbk'</span>);</div></pre></td></tr></table></figure>\n<p>　　<code>express</code>在碰到无法解码的urlencode的时候会将其保留为原格式，好在urlencode就是16进制前面加了%号，因此我们可以手动转成<code>buffer</code>之后再解码</p>\n<h2 id=\"转发无法被解码的urlencode\"><a href=\"#转发无法被解码的urlencode\" class=\"headerlink\" title=\"转发无法被解码的urlencode\"></a>转发无法被解码的urlencode</h2><p>　　假设我们的程序只是做纯粹的转发，没想到参数里有不能解码的urlencode，比如上面的<code>%c4%e3%ba%c3</code>，这个时候再通过<code>request</code>去请求的时候，再次做了urlencode，会把原字符串里的百分号转成<code>%25</code>，那么目标方接到参数的时候就变成<code>%25c4%25e3%25ba%25c3</code>，为了避免这一点，我们需要对无法被urlencode解码的部分做无伤转发，示例如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> qs   = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">gbkStr</span>: <span class=\"string\">'%c4%e3%ba%c3'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">urlEncode</span>(<span class=\"params\">s</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> qs.escape(s.replace(<span class=\"regexp\">/%(\\w&#123;2&#125;)/g</span>, <span class=\"string\">'-_-$1'</span>)).replace(<span class=\"regexp\">/-_-(\\W&#123;2&#125;)/g</span>, <span class=\"string\">'%$1'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//1、使用原生的queryString</span></div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'someurl'</span> + qs.stringify(data, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2、直接用于request</span></div><div class=\"line\">request(<span class=\"string\">'someurl'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">qs</span>                : data,</div><div class=\"line\">  <span class=\"attr\">qsStringifyOptions</span>: &#123;<span class=\"attr\">options</span>: &#123;<span class=\"attr\">encodeURIComponent</span>: urlEncode&#125;&#125;</div><div class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div></pre></td></tr></table></figure></p>\n<p>　　关于<code>querystring</code>更多的细节参看<a href=\"https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options\">官方文档</a></p>\n<p>　　我们可以让<code>querystring</code>结合第一段代码的自动判断编码，来实现一个自动化的解码流程，当然越是自动化的东西，就越难搞清楚内在的原理，在很多时候，还是自己来实现比较靠谱</p>\n"},{"title":"javaScript的函数柯里化","desc":"柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数","date":"2016-01-07T02:11:18.000Z","author":"ngtmuzi","_content":"> 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n\n　　简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：\n```javascript\nfunction curry(fn, context) {\n    function c() {\n        var args = this.concat(Array.prototype.slice.call(arguments));\n        if (args.length >= fn.length) return fn.apply(context, args);\n        return c.bind(args);\n    }\n\n    return c.bind([]);\n}\n```\n　　返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：\n\n```javascript\nvar _a = function (a, b) {\n    return a + b;\n};\nvar a = curry(_a);\n\nconsole.log(a(1, 2), a(2)(3), a()()(3)(4), a()()(4, 5))\n//运行结果： 3 5 7 9\n```","source":"_posts/javaScript的函数柯里化.md","raw":"---\ntitle: javaScript的函数柯里化  \ndesc: 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数  \ndate: 2016-1-7 10:11:18  \ntags: javascript  \nauthor: ngtmuzi  \ncategory: 班门弄斧  \n---\n> 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。\n\n　　简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：\n```javascript\nfunction curry(fn, context) {\n    function c() {\n        var args = this.concat(Array.prototype.slice.call(arguments));\n        if (args.length >= fn.length) return fn.apply(context, args);\n        return c.bind(args);\n    }\n\n    return c.bind([]);\n}\n```\n　　返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：\n\n```javascript\nvar _a = function (a, b) {\n    return a + b;\n};\nvar a = curry(_a);\n\nconsole.log(a(1, 2), a(2)(3), a()()(3)(4), a()()(4, 5))\n//运行结果： 3 5 7 9\n```","slug":"javaScript的函数柯里化","published":1,"updated":"2017-01-23T02:27:38.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7xn0005fkmxo53neyv7","content":"<blockquote>\n<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>\n</blockquote>\n<p>　　简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"keyword\">this</span>.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">        <span class=\"keyword\">if</span> (args.length &gt;= fn.length) <span class=\"keyword\">return</span> fn.apply(context, args);</div><div class=\"line\">        <span class=\"keyword\">return</span> c.bind(args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> c.bind([]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _a = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> a = curry(_a);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(a(<span class=\"number\">1</span>, <span class=\"number\">2</span>), a(<span class=\"number\">2</span>)(<span class=\"number\">3</span>), a()()(<span class=\"number\">3</span>)(<span class=\"number\">4</span>), a()()(<span class=\"number\">4</span>, <span class=\"number\">5</span>))</div><div class=\"line\"><span class=\"comment\">//运行结果： 3 5 7 9</span></div></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p>\n</blockquote>\n<p>　　简单理解来说就是把一个函数带上经常用到的参数和上下文，生成一个新的函数的技术，lodash的柯里化函数写得好复杂看得不是很懂，自己想了一下应该不是很复杂才对：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"keyword\">this</span>.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</div><div class=\"line\">        <span class=\"keyword\">if</span> (args.length &gt;= fn.length) <span class=\"keyword\">return</span> fn.apply(context, args);</div><div class=\"line\">        <span class=\"keyword\">return</span> c.bind(args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> c.bind([]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　返回一个用于收集参数数组的函数，当参数达到原函数的参数长度时才调用原函数，参数数组传到新函数的this对象上以供调用，测试如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _a = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> a = curry(_a);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(a(<span class=\"number\">1</span>, <span class=\"number\">2</span>), a(<span class=\"number\">2</span>)(<span class=\"number\">3</span>), a()()(<span class=\"number\">3</span>)(<span class=\"number\">4</span>), a()()(<span class=\"number\">4</span>, <span class=\"number\">5</span>))</div><div class=\"line\"><span class=\"comment\">//运行结果： 3 5 7 9</span></div></pre></td></tr></table></figure>"},{"title":"Proxy对象仿Scala的通配符函数调用","desc":"Proxy对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本javascript无法完成的特性","date":"2016-04-23T08:47:40.471Z","author":"ngtmuzi","_content":"　　`Proxy`对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本`javascript`无法完成的特性，在不长的`scala语言`学习过程中，发现这门语言有一个很神奇的通配符`_`，在函数链式调用中，`_`就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：\n```javascript\n[1, 2, 3, 4].map(_.toString());\n```\n　　就是对每个传来的对象，调用他们自身的`toString()`方法，使用ES6中的`Proxy`对象，可以很容易地模拟该特性\n（nodejs v6.0已支持`Proxy`，代码亦可在最新版chrome中运行）\n```javascript\nvar _ = new Proxy({}, {\n  get: function (target, key) {\n    return function (obj) {\n      if (obj && obj[key] && typeof obj[key] !== 'function') return obj[key];\n      var args = arguments;\n      return function (obj) {\n        if (obj && obj[key] && typeof obj[key] === 'function')\n          return obj[key].call(obj, ...args);\n      };\n    };\n  }\n});\n```\n　　除了调用对象自带的方法外，还有取出属性的功能，运行结果如下\n\n```javascript\n[1, 32, 128, 1024].map(_.toString('2'));\n//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]\n\n[{v:123},{v:456}].map(_.v);\n//return [123, 456]\n\nPromise.resolve(new Date())\n  .then(_.getTime())\n  .then(_.toString())\n  .then(_.length)\n  .then(console.log, console.error);\n//return 13\n```\n---\n# 2016-6-8续\n　　之前研究`Proxy`的时候写出来的那个`_`实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个`_`的作用层数，不能继续往里面走，解决的方法当然是继续返回一个`Proxy`，思路如下：\n\n* `_`本身返回一个Proxy，取属性操作返回的也是一个`Proxy`，这些`Proxy`指向一个函数，并在被调用时按顺序取出第一个参数里的属性\n\n* `_`可以预接收参数，接收的参数将在`Proxy`被调用时传给取出来的函数\n\n　　难点是如何知道`Proxy`是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了`Proxy`的相关资料后，我意识到上述的两种情况，对应的`this`应该是不同的，后来又发现过长的调用链每次都要经过多个`Proxy`可能会影响效率，我又改成另外一种形式实现：`Proxy`负责收集参数和属性名，并在最终调用的时候新建一个`Function`，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 `s=>s.xx.yy.zz()` 给简化成 `_.xx.yy.zz()` 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：\n\n```javascript\n/**\n * Created by ngtmuzi on 2016/5/29.\n */\n'use strict';\nconst receiveFn = (...args) => args;\n\n/**\n * chain proxy maker\n * @params {Any} defaultValue\n * @type {Function}\n */\nconst chainProxy = module.exports = function (defaultValue) {\n  var hasDefault   = arguments.length > 0;\n\n  var handle = {\n    get: function (target, property, receiver) {\n      //set prototype to base Proxy Object _\n      if (property === 'prototype') return _;\n      if (property === 'apply') return target.apply;\n      if (property === 'call') return target.call;\n      if (property === 'bind') return target.bind;\n\n      //is number\n      if (!isNaN(+property)) return new Proxy(target.bind(null, `[${property}]`), handle);\n      //return a new Proxy, go on\n      else return new Proxy(target.bind(null, '.' + property), handle);\n    },\n\n    apply: function (target, thisArg, argumentsList) {\n      //if method calling on Proxy Object\n      if (thisArg && thisArg.prototype === _) {\n        //save arguments to chain, and go on\n        return new Proxy(target.bind(null, argumentsList), handle);\n\n      } else {  //calling on outside\n\n        //get the calling chain\n        var chains = target();\n        //pick arguments\n        var args   = [].concat(...chains.filter(Array.isArray));\n\n        //make function body\n        var argNum     = 0;\n        var expression = chains.reduce(function (a, b) {\n          if (typeof b === 'string') return a + b;\n          else if (Array.isArray(b)) return a + `(${b.map(()=> `args[${argNum++}]`)})`;\n        }, 'return _');\n\n        var fnStr = `\n        try{\n          ${expression};\n        }catch(err){\n          ${hasDefault ? 'return defaultValue;' : ''}\n          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '${expression}';\n          throw err;\n        }`;\n\n        var finalFn = new Function(['args', '_', 'defaultValue'], fnStr);\n        return finalFn(args, argumentsList[0], defaultValue);\n      }\n    }\n  };\n\n  var _ = new Proxy(receiveFn, handle);\n  return _;\n};\n```\n　　测试代码如下：\n```javascript\nvar _1 = require('../index')(undefined);\nvar _2 = require('../index')();\nvar _3 = require('../index')({foo: 'bar'});\n\nPromise.resolve({a: 12333})\n  .then(_1.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 1:'), console.error.bind(null, 'catch error1:'))\n\n  .then(()=>({a: 12333}))\n  .then(_2.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'))\n\n  .then(()=>({a: 12333}))\n  .then(_3.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'));\n```\n　　本段代码已经做为模块提交到[npm](https://www.npmjs.com/package/chainproxy)上","source":"_posts/Proxy对象仿Scala的通配符函数调用.md","raw":"---\ntitle: Proxy对象仿Scala的通配符函数调用  \ndesc: Proxy对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本javascript无法完成的特性  \ndate: 2016-4-23 16:47:40.471\ntags: \n- javascript\n- es6\n- Proxy\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n　　`Proxy`对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本`javascript`无法完成的特性，在不长的`scala语言`学习过程中，发现这门语言有一个很神奇的通配符`_`，在函数链式调用中，`_`就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：\n```javascript\n[1, 2, 3, 4].map(_.toString());\n```\n　　就是对每个传来的对象，调用他们自身的`toString()`方法，使用ES6中的`Proxy`对象，可以很容易地模拟该特性\n（nodejs v6.0已支持`Proxy`，代码亦可在最新版chrome中运行）\n```javascript\nvar _ = new Proxy({}, {\n  get: function (target, key) {\n    return function (obj) {\n      if (obj && obj[key] && typeof obj[key] !== 'function') return obj[key];\n      var args = arguments;\n      return function (obj) {\n        if (obj && obj[key] && typeof obj[key] === 'function')\n          return obj[key].call(obj, ...args);\n      };\n    };\n  }\n});\n```\n　　除了调用对象自带的方法外，还有取出属性的功能，运行结果如下\n\n```javascript\n[1, 32, 128, 1024].map(_.toString('2'));\n//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]\n\n[{v:123},{v:456}].map(_.v);\n//return [123, 456]\n\nPromise.resolve(new Date())\n  .then(_.getTime())\n  .then(_.toString())\n  .then(_.length)\n  .then(console.log, console.error);\n//return 13\n```\n---\n# 2016-6-8续\n　　之前研究`Proxy`的时候写出来的那个`_`实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个`_`的作用层数，不能继续往里面走，解决的方法当然是继续返回一个`Proxy`，思路如下：\n\n* `_`本身返回一个Proxy，取属性操作返回的也是一个`Proxy`，这些`Proxy`指向一个函数，并在被调用时按顺序取出第一个参数里的属性\n\n* `_`可以预接收参数，接收的参数将在`Proxy`被调用时传给取出来的函数\n\n　　难点是如何知道`Proxy`是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了`Proxy`的相关资料后，我意识到上述的两种情况，对应的`this`应该是不同的，后来又发现过长的调用链每次都要经过多个`Proxy`可能会影响效率，我又改成另外一种形式实现：`Proxy`负责收集参数和属性名，并在最终调用的时候新建一个`Function`，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 `s=>s.xx.yy.zz()` 给简化成 `_.xx.yy.zz()` 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：\n\n```javascript\n/**\n * Created by ngtmuzi on 2016/5/29.\n */\n'use strict';\nconst receiveFn = (...args) => args;\n\n/**\n * chain proxy maker\n * @params {Any} defaultValue\n * @type {Function}\n */\nconst chainProxy = module.exports = function (defaultValue) {\n  var hasDefault   = arguments.length > 0;\n\n  var handle = {\n    get: function (target, property, receiver) {\n      //set prototype to base Proxy Object _\n      if (property === 'prototype') return _;\n      if (property === 'apply') return target.apply;\n      if (property === 'call') return target.call;\n      if (property === 'bind') return target.bind;\n\n      //is number\n      if (!isNaN(+property)) return new Proxy(target.bind(null, `[${property}]`), handle);\n      //return a new Proxy, go on\n      else return new Proxy(target.bind(null, '.' + property), handle);\n    },\n\n    apply: function (target, thisArg, argumentsList) {\n      //if method calling on Proxy Object\n      if (thisArg && thisArg.prototype === _) {\n        //save arguments to chain, and go on\n        return new Proxy(target.bind(null, argumentsList), handle);\n\n      } else {  //calling on outside\n\n        //get the calling chain\n        var chains = target();\n        //pick arguments\n        var args   = [].concat(...chains.filter(Array.isArray));\n\n        //make function body\n        var argNum     = 0;\n        var expression = chains.reduce(function (a, b) {\n          if (typeof b === 'string') return a + b;\n          else if (Array.isArray(b)) return a + `(${b.map(()=> `args[${argNum++}]`)})`;\n        }, 'return _');\n\n        var fnStr = `\n        try{\n          ${expression};\n        }catch(err){\n          ${hasDefault ? 'return defaultValue;' : ''}\n          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '${expression}';\n          throw err;\n        }`;\n\n        var finalFn = new Function(['args', '_', 'defaultValue'], fnStr);\n        return finalFn(args, argumentsList[0], defaultValue);\n      }\n    }\n  };\n\n  var _ = new Proxy(receiveFn, handle);\n  return _;\n};\n```\n　　测试代码如下：\n```javascript\nvar _1 = require('../index')(undefined);\nvar _2 = require('../index')();\nvar _3 = require('../index')({foo: 'bar'});\n\nPromise.resolve({a: 12333})\n  .then(_1.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 1:'), console.error.bind(null, 'catch error1:'))\n\n  .then(()=>({a: 12333}))\n  .then(_2.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'))\n\n  .then(()=>({a: 12333}))\n  .then(_3.ab.toString().split('')[0].toString().replace('1', 'replaceStr').length)\n  .then(console.log.bind(null, 'result 2:'), console.error.bind(null, 'catch error2:'));\n```\n　　本段代码已经做为模块提交到[npm](https://www.npmjs.com/package/chainproxy)上","slug":"Proxy对象仿Scala的通配符函数调用","published":1,"updated":"2017-01-23T02:24:43.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7xs0006fkmx1qznahr8","content":"<p>　　<code>Proxy</code>对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本<code>javascript</code>无法完成的特性，在不长的<code>scala语言</code>学习过程中，发现这门语言有一个很神奇的通配符<code>_</code>，在函数链式调用中，<code>_</code>就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(_.toString());</div></pre></td></tr></table></figure></p>\n<p>　　就是对每个传来的对象，调用他们自身的<code>toString()</code>方法，使用ES6中的<code>Proxy</code>对象，可以很容易地模拟该特性<br>（nodejs v6.0已支持<code>Proxy</code>，代码亦可在最新版chrome中运行）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</div><div class=\"line\">  <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] !== <span class=\"string\">'function'</span>) <span class=\"keyword\">return</span> obj[key];</div><div class=\"line\">      <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'function'</span>)</div><div class=\"line\">          <span class=\"keyword\">return</span> obj[key].call(obj, ...args);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　除了调用对象自带的方法外，还有取出属性的功能，运行结果如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">32</span>, <span class=\"number\">128</span>, <span class=\"number\">1024</span>].map(_.toString(<span class=\"string\">'2'</span>));</div><div class=\"line\"><span class=\"comment\">//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]</span></div><div class=\"line\"></div><div class=\"line\">[&#123;<span class=\"attr\">v</span>:<span class=\"number\">123</span>&#125;,&#123;<span class=\"attr\">v</span>:<span class=\"number\">456</span>&#125;].map(_.v);</div><div class=\"line\"><span class=\"comment\">//return [123, 456]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</div><div class=\"line\">  .then(_.getTime())</div><div class=\"line\">  .then(_.toString())</div><div class=\"line\">  .then(_.length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div><div class=\"line\"><span class=\"comment\">//return 13</span></div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"2016-6-8续\"><a href=\"#2016-6-8续\" class=\"headerlink\" title=\"2016-6-8续\"></a>2016-6-8续</h1><p>　　之前研究<code>Proxy</code>的时候写出来的那个<code>_</code>实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个<code>_</code>的作用层数，不能继续往里面走，解决的方法当然是继续返回一个<code>Proxy</code>，思路如下：</p>\n<ul>\n<li><p><code>_</code>本身返回一个Proxy，取属性操作返回的也是一个<code>Proxy</code>，这些<code>Proxy</code>指向一个函数，并在被调用时按顺序取出第一个参数里的属性</p>\n</li>\n<li><p><code>_</code>可以预接收参数，接收的参数将在<code>Proxy</code>被调用时传给取出来的函数</p>\n</li>\n</ul>\n<p>　　难点是如何知道<code>Proxy</code>是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了<code>Proxy</code>的相关资料后，我意识到上述的两种情况，对应的<code>this</code>应该是不同的，后来又发现过长的调用链每次都要经过多个<code>Proxy</code>可能会影响效率，我又改成另外一种形式实现：<code>Proxy</code>负责收集参数和属性名，并在最终调用的时候新建一个<code>Function</code>，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 <code>s=&gt;s.xx.yy.zz()</code> 给简化成 <code>_.xx.yy.zz()</code> 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by ngtmuzi on 2016/5/29.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> receiveFn = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> args;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * chain proxy maker</div><div class=\"line\"> * @params &#123;Any&#125; defaultValue</div><div class=\"line\"> * @type &#123;Function&#125;</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">const</span> chainProxy = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">defaultValue</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> hasDefault   = <span class=\"built_in\">arguments</span>.length &gt; <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> handle = &#123;</div><div class=\"line\">    <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, property, receiver</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//set prototype to base Proxy Object _</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'prototype'</span>) <span class=\"keyword\">return</span> _;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'apply'</span>) <span class=\"keyword\">return</span> target.apply;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'call'</span>) <span class=\"keyword\">return</span> target.call;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'bind'</span>) <span class=\"keyword\">return</span> target.bind;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//is number</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">isNaN</span>(+property)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">`[<span class=\"subst\">$&#123;property&#125;</span>]`</span>), handle);</div><div class=\"line\">      <span class=\"comment\">//return a new Proxy, go on</span></div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">'.'</span> + property), handle);</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">apply</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, thisArg, argumentsList</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//if method calling on Proxy Object</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (thisArg &amp;&amp; thisArg.prototype === _) &#123;</div><div class=\"line\">        <span class=\"comment\">//save arguments to chain, and go on</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, argumentsList), handle);</div><div class=\"line\"></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//calling on outside</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//get the calling chain</span></div><div class=\"line\">        <span class=\"keyword\">var</span> chains = target();</div><div class=\"line\">        <span class=\"comment\">//pick arguments</span></div><div class=\"line\">        <span class=\"keyword\">var</span> args   = [].concat(...chains.filter(<span class=\"built_in\">Array</span>.isArray));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//make function body</span></div><div class=\"line\">        <span class=\"keyword\">var</span> argNum     = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> expression = chains.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> b === <span class=\"string\">'string'</span>) <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(b)) <span class=\"keyword\">return</span> a + <span class=\"string\">`(<span class=\"subst\">$&#123;b.map(()=&gt; <span class=\"string\">`args[<span class=\"subst\">$&#123;argNum++&#125;</span>]`</span>)&#125;</span>)`</span>;</div><div class=\"line\">        &#125;, <span class=\"string\">'return _'</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> fnStr = <span class=\"string\">`</span></div><div class=\"line\">        try&#123;</div><div class=\"line\">          <span class=\"subst\">$&#123;expression&#125;</span>;</div><div class=\"line\">        &#125;catch(err)&#123;</div><div class=\"line\">          <span class=\"subst\">$&#123;hasDefault ? <span class=\"string\">'return defaultValue;'</span> : <span class=\"string\">''</span>&#125;</span></div><div class=\"line\">          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '<span class=\"subst\">$&#123;expression&#125;</span>';</div><div class=\"line\">          throw err;</div><div class=\"line\">        &#125;`;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> finalFn = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>([<span class=\"string\">'args'</span>, <span class=\"string\">'_'</span>, <span class=\"string\">'defaultValue'</span>], fnStr);</div><div class=\"line\">        <span class=\"keyword\">return</span> finalFn(args, argumentsList[<span class=\"number\">0</span>], defaultValue);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(receiveFn, handle);</div><div class=\"line\">  <span class=\"keyword\">return</span> _;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>　　测试代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _1 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)(<span class=\"literal\">undefined</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _2 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)();</div><div class=\"line\"><span class=\"keyword\">var</span> _3 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)(&#123;<span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;)</div><div class=\"line\">  .then(_1.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 1:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error1:'</span>))</div><div class=\"line\"></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</div><div class=\"line\">  .then(_2.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 2:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error2:'</span>))</div><div class=\"line\"></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</div><div class=\"line\">  .then(_3.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 2:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error2:'</span>));</div></pre></td></tr></table></figure></p>\n<p>　　本段代码已经做为模块提交到<a href=\"https://www.npmjs.com/package/chainproxy\" target=\"_blank\" rel=\"external\">npm</a>上</p>\n","excerpt":"","more":"<p>　　<code>Proxy</code>对象是ES6加入的新特性，使用它来监听拦截对象的操作，可以使我们完成很多原本<code>javascript</code>无法完成的特性，在不长的<code>scala语言</code>学习过程中，发现这门语言有一个很神奇的通配符<code>_</code>，在函数链式调用中，<code>_</code>就代表了对象本身，这使得函数式编程的语法更加简洁，放在javascript中举例，就类似这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].map(_.toString());</div></pre></td></tr></table></figure></p>\n<p>　　就是对每个传来的对象，调用他们自身的<code>toString()</code>方法，使用ES6中的<code>Proxy</code>对象，可以很容易地模拟该特性<br>（nodejs v6.0已支持<code>Proxy</code>，代码亦可在最新版chrome中运行）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</div><div class=\"line\">  <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] !== <span class=\"string\">'function'</span>) <span class=\"keyword\">return</span> obj[key];</div><div class=\"line\">      <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (obj &amp;&amp; obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'function'</span>)</div><div class=\"line\">          <span class=\"keyword\">return</span> obj[key].call(obj, ...args);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　除了调用对象自带的方法外，还有取出属性的功能，运行结果如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">32</span>, <span class=\"number\">128</span>, <span class=\"number\">1024</span>].map(_.toString(<span class=\"string\">'2'</span>));</div><div class=\"line\"><span class=\"comment\">//return [\"1\", \"100000\", \"10000000\", \"10000000000\"]</span></div><div class=\"line\"></div><div class=\"line\">[&#123;<span class=\"attr\">v</span>:<span class=\"number\">123</span>&#125;,&#123;<span class=\"attr\">v</span>:<span class=\"number\">456</span>&#125;].map(_.v);</div><div class=\"line\"><span class=\"comment\">//return [123, 456]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</div><div class=\"line\">  .then(_.getTime())</div><div class=\"line\">  .then(_.toString())</div><div class=\"line\">  .then(_.length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log, <span class=\"built_in\">console</span>.error);</div><div class=\"line\"><span class=\"comment\">//return 13</span></div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"2016-6-8续\"><a href=\"#2016-6-8续\" class=\"headerlink\" title=\"2016-6-8续\"></a>2016-6-8续</h1><p>　　之前研究<code>Proxy</code>的时候写出来的那个<code>_</code>实际上还是有很大缺陷的，比如只能取一层的结构，参数的属性与方法同名时会取出参数的属性，不能正确捕捉到类型不对之类的错误，以及其他等等，于是就想做一个更完善的，现在想想当时的思路本身不太对，返回了一个函数就等于是限制了这个<code>_</code>的作用层数，不能继续往里面走，解决的方法当然是继续返回一个<code>Proxy</code>，思路如下：</p>\n<ul>\n<li><p><code>_</code>本身返回一个Proxy，取属性操作返回的也是一个<code>Proxy</code>，这些<code>Proxy</code>指向一个函数，并在被调用时按顺序取出第一个参数里的属性</p>\n</li>\n<li><p><code>_</code>可以预接收参数，接收的参数将在<code>Proxy</code>被调用时传给取出来的函数</p>\n</li>\n</ul>\n<p>　　难点是如何知道<code>Proxy</code>是在预传参的时候被调用还是在真正取值的时候被调用，实际上用返回函数的方法可能很难解决这种问题，在再次深入研究了<code>Proxy</code>的相关资料后，我意识到上述的两种情况，对应的<code>this</code>应该是不同的，后来又发现过长的调用链每次都要经过多个<code>Proxy</code>可能会影响效率，我又改成另外一种形式实现：<code>Proxy</code>负责收集参数和属性名，并在最终调用的时候新建一个<code>Function</code>，将整个调用链还原回原本的格式（想到这里我就感觉坑了，实际上我只是把 <code>s=&gt;s.xx.yy.zz()</code> 给简化成 <code>_.xx.yy.zz()</code> 而已，因此我特意加上了一个默认值的功能，好歹比箭头函数多了个错误捕获），再基于其他的一些需求，修修改改之后，变成了以下的格式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Created by ngtmuzi on 2016/5/29.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> receiveFn = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> args;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * chain proxy maker</div><div class=\"line\"> * @params &#123;Any&#125; defaultValue</div><div class=\"line\"> * @type &#123;Function&#125;</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">const</span> chainProxy = <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">defaultValue</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> hasDefault   = <span class=\"built_in\">arguments</span>.length &gt; <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> handle = &#123;</div><div class=\"line\">    <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, property, receiver</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//set prototype to base Proxy Object _</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'prototype'</span>) <span class=\"keyword\">return</span> _;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'apply'</span>) <span class=\"keyword\">return</span> target.apply;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'call'</span>) <span class=\"keyword\">return</span> target.call;</div><div class=\"line\">      <span class=\"keyword\">if</span> (property === <span class=\"string\">'bind'</span>) <span class=\"keyword\">return</span> target.bind;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//is number</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">isNaN</span>(+property)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">`[<span class=\"subst\">$&#123;property&#125;</span>]`</span>), handle);</div><div class=\"line\">      <span class=\"comment\">//return a new Proxy, go on</span></div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, <span class=\"string\">'.'</span> + property), handle);</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">apply</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, thisArg, argumentsList</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//if method calling on Proxy Object</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (thisArg &amp;&amp; thisArg.prototype === _) &#123;</div><div class=\"line\">        <span class=\"comment\">//save arguments to chain, and go on</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target.bind(<span class=\"literal\">null</span>, argumentsList), handle);</div><div class=\"line\"></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//calling on outside</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//get the calling chain</span></div><div class=\"line\">        <span class=\"keyword\">var</span> chains = target();</div><div class=\"line\">        <span class=\"comment\">//pick arguments</span></div><div class=\"line\">        <span class=\"keyword\">var</span> args   = [].concat(...chains.filter(<span class=\"built_in\">Array</span>.isArray));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//make function body</span></div><div class=\"line\">        <span class=\"keyword\">var</span> argNum     = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> expression = chains.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> b === <span class=\"string\">'string'</span>) <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(b)) <span class=\"keyword\">return</span> a + <span class=\"string\">`(<span class=\"subst\">$&#123;b.map(()=&gt; <span class=\"string\">`args[<span class=\"subst\">$&#123;argNum++&#125;</span>]`</span>)&#125;</span>)`</span>;</div><div class=\"line\">        &#125;, <span class=\"string\">'return _'</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> fnStr = <span class=\"string\">`</div><div class=\"line\">        try&#123;</div><div class=\"line\">          <span class=\"subst\">$&#123;expression&#125;</span>;</div><div class=\"line\">        &#125;catch(err)&#123;</div><div class=\"line\">          <span class=\"subst\">$&#123;hasDefault ? <span class=\"string\">'return defaultValue;'</span> : <span class=\"string\">''</span>&#125;</span></div><div class=\"line\">          err.stack = err.name + ': ' + err.message + '\\\\n\\\\tat: ' + '<span class=\"subst\">$&#123;expression&#125;</span>';</div><div class=\"line\">          throw err;</div><div class=\"line\">        &#125;`</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> finalFn = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>([<span class=\"string\">'args'</span>, <span class=\"string\">'_'</span>, <span class=\"string\">'defaultValue'</span>], fnStr);</div><div class=\"line\">        <span class=\"keyword\">return</span> finalFn(args, argumentsList[<span class=\"number\">0</span>], defaultValue);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(receiveFn, handle);</div><div class=\"line\">  <span class=\"keyword\">return</span> _;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>　　测试代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _1 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)(<span class=\"literal\">undefined</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _2 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)();</div><div class=\"line\"><span class=\"keyword\">var</span> _3 = <span class=\"built_in\">require</span>(<span class=\"string\">'../index'</span>)(&#123;<span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;)</div><div class=\"line\">  .then(_1.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 1:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error1:'</span>))</div><div class=\"line\"></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</div><div class=\"line\">  .then(_2.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 2:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error2:'</span>))</div><div class=\"line\"></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>(&#123;<span class=\"attr\">a</span>: <span class=\"number\">12333</span>&#125;))</div><div class=\"line\">  .then(_3.ab.toString().split(<span class=\"string\">''</span>)[<span class=\"number\">0</span>].toString().replace(<span class=\"string\">'1'</span>, <span class=\"string\">'replaceStr'</span>).length)</div><div class=\"line\">  .then(<span class=\"built_in\">console</span>.log.bind(<span class=\"literal\">null</span>, <span class=\"string\">'result 2:'</span>), <span class=\"built_in\">console</span>.error.bind(<span class=\"literal\">null</span>, <span class=\"string\">'catch error2:'</span>));</div></pre></td></tr></table></figure></p>\n<p>　　本段代码已经做为模块提交到<a href=\"https://www.npmjs.com/package/chainproxy\">npm</a>上</p>\n"},{"title":"promise的日常应用","desc":"promise在异步处理上真是比原始的回调好了太多，promise大法好~","date":"2015-12-30T12:46:04.470Z","author":"ngtmuzi","_content":"　　`promise`在异步处理上真是比原始的回调好了太多，`promise`大法好~\n\n　　下面是一些日常工作中总结的各种神秘技巧：（使用`bluebird`模块）\n\n* 一般来说都是在`request`请求或数据库操作之后开始使用`promise`，当然要直接`Promise.resolve()`也是可以的\n\n* `mongodb`模块原生返回`promise`对象，真是方便不少，不过它用的是`Q`模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换`promise`库：\n```javascript\nMongoClient.connect(mongoUrl, {promiseLibrary: Promise})\n```\n* `mysql`方面好像除了`sequelize`外没什么比较好的`promise`的模块……因为目前的工作内容都是在`mongodb`上，对这方面也没做太多了解\n\n* `redis`模块中`ioredis`据说不错，不过也没太多接触\n\n* 至于网络请求，自然是`request`的`promise`版：`request`-`promise`\n\n---\n\n　　当以上模块返回了promise对象，就可以用then一路走到黑啦\n\n　　一般来说我的express路由处理函数都会以这样结尾：\n```javascript\nfunction getArticle(req, res, next) {\n  mongo.article.find(req.query).sort({postTime:-1}).toArray()\n    .then(res.ok, next);\n}\n```\n　　`res.ok`是自己为了方便而挂上的一个函数，一般类似于  \n\n```javascript\n  res.ok  = res.json.bind(res);\n```\n\n　　`next`函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。\n\n　　后来想想，用`next`函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：\n\n```javascript\nres.ok = function (data) {\n  res.send(200,data);\n};\nres.err = _.curry(function (code, err, ext) {\n  res.status(code || 500);\n  res.json({msg: err && err.message || err, ext: ext && ext.message || ext});\n});\n```\n　　使用了`lodash`模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术\n\n```javascript\nsms.csGetStatusReportExEx()\n  .then(res.ok, res.err(502, '状态报告获取失败'));\n```\n　　真正的错误信息会被带在`ext`里字段返回，另外`res.ok`也改成调用适用性更好的`res.send`函数\n（注意这里有个坑，`res.send`一个数字的话它会以为你只返回一个http状态码，因此虽然`res.send(200,data)`这种格式已被弃用，但是在目前还是必须这么处理才行）","source":"_posts/promise的日常应用.md","raw":"---\ntitle: promise的日常应用    \ndesc: promise在异步处理上真是比原始的回调好了太多，promise大法好~  \ndate: 2015-12-30 20:46:04.470\ntags: \n- nodejs\n- javascript\n- promise\n- express  \nauthor: ngtmuzi  \ncategory: 班门弄斧  \n---\n　　`promise`在异步处理上真是比原始的回调好了太多，`promise`大法好~\n\n　　下面是一些日常工作中总结的各种神秘技巧：（使用`bluebird`模块）\n\n* 一般来说都是在`request`请求或数据库操作之后开始使用`promise`，当然要直接`Promise.resolve()`也是可以的\n\n* `mongodb`模块原生返回`promise`对象，真是方便不少，不过它用的是`Q`模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换`promise`库：\n```javascript\nMongoClient.connect(mongoUrl, {promiseLibrary: Promise})\n```\n* `mysql`方面好像除了`sequelize`外没什么比较好的`promise`的模块……因为目前的工作内容都是在`mongodb`上，对这方面也没做太多了解\n\n* `redis`模块中`ioredis`据说不错，不过也没太多接触\n\n* 至于网络请求，自然是`request`的`promise`版：`request`-`promise`\n\n---\n\n　　当以上模块返回了promise对象，就可以用then一路走到黑啦\n\n　　一般来说我的express路由处理函数都会以这样结尾：\n```javascript\nfunction getArticle(req, res, next) {\n  mongo.article.find(req.query).sort({postTime:-1}).toArray()\n    .then(res.ok, next);\n}\n```\n　　`res.ok`是自己为了方便而挂上的一个函数，一般类似于  \n\n```javascript\n  res.ok  = res.json.bind(res);\n```\n\n　　`next`函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。\n\n　　后来想想，用`next`函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：\n\n```javascript\nres.ok = function (data) {\n  res.send(200,data);\n};\nres.err = _.curry(function (code, err, ext) {\n  res.status(code || 500);\n  res.json({msg: err && err.message || err, ext: ext && ext.message || ext});\n});\n```\n　　使用了`lodash`模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术\n\n```javascript\nsms.csGetStatusReportExEx()\n  .then(res.ok, res.err(502, '状态报告获取失败'));\n```\n　　真正的错误信息会被带在`ext`里字段返回，另外`res.ok`也改成调用适用性更好的`res.send`函数\n（注意这里有个坑，`res.send`一个数字的话它会以为你只返回一个http状态码，因此虽然`res.send(200,data)`这种格式已被弃用，但是在目前还是必须这么处理才行）","slug":"promise的日常应用","published":1,"updated":"2017-01-23T02:25:51.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7xu0009fkmxnyruwqmy","content":"<p>　　<code>promise</code>在异步处理上真是比原始的回调好了太多，<code>promise</code>大法好~</p>\n<p>　　下面是一些日常工作中总结的各种神秘技巧：（使用<code>bluebird</code>模块）</p>\n<ul>\n<li><p>一般来说都是在<code>request</code>请求或数据库操作之后开始使用<code>promise</code>，当然要直接<code>Promise.resolve()</code>也是可以的</p>\n</li>\n<li><p><code>mongodb</code>模块原生返回<code>promise</code>对象，真是方便不少，不过它用的是<code>Q</code>模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换<code>promise</code>库：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MongoClient.connect(mongoUrl, &#123;<span class=\"attr\">promiseLibrary</span>: <span class=\"built_in\">Promise</span>&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>mysql</code>方面好像除了<code>sequelize</code>外没什么比较好的<code>promise</code>的模块……因为目前的工作内容都是在<code>mongodb</code>上，对这方面也没做太多了解</p>\n</li>\n<li><p><code>redis</code>模块中<code>ioredis</code>据说不错，不过也没太多接触</p>\n</li>\n<li><p>至于网络请求，自然是<code>request</code>的<code>promise</code>版：<code>request</code>-<code>promise</code></p>\n</li>\n</ul>\n<hr>\n<p>　　当以上模块返回了promise对象，就可以用then一路走到黑啦</p>\n<p>　　一般来说我的express路由处理函数都会以这样结尾：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArticle</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  mongo.article.find(req.query).sort(&#123;<span class=\"attr\">postTime</span>:<span class=\"number\">-1</span>&#125;).toArray()</div><div class=\"line\">    .then(res.ok, next);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　<code>res.ok</code>是自己为了方便而挂上的一个函数，一般类似于  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.ok  = res.json.bind(res);</div></pre></td></tr></table></figure>\n<p>　　<code>next</code>函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。</p>\n<p>　　后来想想，用<code>next</code>函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.ok = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  res.send(<span class=\"number\">200</span>,data);</div><div class=\"line\">&#125;;</div><div class=\"line\">res.err = _.curry(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, err, ext</span>) </span>&#123;</div><div class=\"line\">  res.status(code || <span class=\"number\">500</span>);</div><div class=\"line\">  res.json(&#123;<span class=\"attr\">msg</span>: err &amp;&amp; err.message || err, <span class=\"attr\">ext</span>: ext &amp;&amp; ext.message || ext&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>　　使用了<code>lodash</code>模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sms.csGetStatusReportExEx()</div><div class=\"line\">  .then(res.ok, res.err(<span class=\"number\">502</span>, <span class=\"string\">'状态报告获取失败'</span>));</div></pre></td></tr></table></figure>\n<p>　　真正的错误信息会被带在<code>ext</code>里字段返回，另外<code>res.ok</code>也改成调用适用性更好的<code>res.send</code>函数<br>（注意这里有个坑，<code>res.send</code>一个数字的话它会以为你只返回一个http状态码，因此虽然<code>res.send(200,data)</code>这种格式已被弃用，但是在目前还是必须这么处理才行）</p>\n","excerpt":"","more":"<p>　　<code>promise</code>在异步处理上真是比原始的回调好了太多，<code>promise</code>大法好~</p>\n<p>　　下面是一些日常工作中总结的各种神秘技巧：（使用<code>bluebird</code>模块）</p>\n<ul>\n<li><p>一般来说都是在<code>request</code>请求或数据库操作之后开始使用<code>promise</code>，当然要直接<code>Promise.resolve()</code>也是可以的</p>\n</li>\n<li><p><code>mongodb</code>模块原生返回<code>promise</code>对象，真是方便不少，不过它用的是<code>Q</code>模块，没太多精力去了解模块间差异的我会选择在初始连接数据库的时候更换<code>promise</code>库：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MongoClient.connect(mongoUrl, &#123;<span class=\"attr\">promiseLibrary</span>: <span class=\"built_in\">Promise</span>&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>mysql</code>方面好像除了<code>sequelize</code>外没什么比较好的<code>promise</code>的模块……因为目前的工作内容都是在<code>mongodb</code>上，对这方面也没做太多了解</p>\n</li>\n<li><p><code>redis</code>模块中<code>ioredis</code>据说不错，不过也没太多接触</p>\n</li>\n<li><p>至于网络请求，自然是<code>request</code>的<code>promise</code>版：<code>request</code>-<code>promise</code></p>\n</li>\n</ul>\n<hr>\n<p>　　当以上模块返回了promise对象，就可以用then一路走到黑啦</p>\n<p>　　一般来说我的express路由处理函数都会以这样结尾：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArticle</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  mongo.article.find(req.query).sort(&#123;<span class=\"attr\">postTime</span>:<span class=\"number\">-1</span>&#125;).toArray()</div><div class=\"line\">    .then(res.ok, next);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　<code>res.ok</code>是自己为了方便而挂上的一个函数，一般类似于  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.ok  = res.json.bind(res);</div></pre></td></tr></table></figure>\n<p>　　<code>next</code>函数用于将错误传到路由处理函数的末端——错误处理函数，在那里进行统一的错误返回。</p>\n<p>　　后来想想，用<code>next</code>函数统一处理错误固然看来很cooooooool，但也正因为此，对于各种错误的描述无法被带过去——用户并不在意你到底是数据库炸了还是代码写错了，他只想要一个中文的对错误的合理解释，类似“账号密码不正确！”之类的东西，因此考虑了一下，还是改成如下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">res.ok = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  res.send(<span class=\"number\">200</span>,data);</div><div class=\"line\">&#125;;</div><div class=\"line\">res.err = _.curry(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code, err, ext</span>) </span>&#123;</div><div class=\"line\">  res.status(code || <span class=\"number\">500</span>);</div><div class=\"line\">  res.json(&#123;<span class=\"attr\">msg</span>: err &amp;&amp; err.message || err, <span class=\"attr\">ext</span>: ext &amp;&amp; ext.message || ext&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>　　使用了<code>lodash</code>模块将函数柯里化——大概就是这样，虽然不太好说明原理，总之这是一种能让我这样处理回调的一种技术</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sms.csGetStatusReportExEx()</div><div class=\"line\">  .then(res.ok, res.err(<span class=\"number\">502</span>, <span class=\"string\">'状态报告获取失败'</span>));</div></pre></td></tr></table></figure>\n<p>　　真正的错误信息会被带在<code>ext</code>里字段返回，另外<code>res.ok</code>也改成调用适用性更好的<code>res.send</code>函数<br>（注意这里有个坑，<code>res.send</code>一个数字的话它会以为你只返回一个http状态码，因此虽然<code>res.send(200,data)</code>这种格式已被弃用，但是在目前还是必须这么处理才行）</p>\n"},{"title":"javascript模板渲染研究笔记（一）","subtitle":null,"desc":"下面没有了","date":"2015-12-31T01:49:32.000Z","author":"ngtmuzi","_content":"　　只是一名本分的后端`nodejs`程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（`angular`、`reactjs`、`vue`、`meteor`以及各种其他）之后，我最终还是决定使用`express`自带的`ejs`\n \n　　即使是各大主流框架，在很大程度上还是离不开`jquery`，我当然也是如此，使用`ejs`仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。\n\n　　然而`ejs`使用中也是各种不爽，在`html`中加上各种`<%%>`真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（`reactjs`的`jsx语法`在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的`jquery`，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了\n\n　　因此我开始研究在`ejs`中加入jq的功能，`cheerio`模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——\n\n　　去翻了一下`ejs`的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言\n```ejs\n<h1>{{ 1+1 }}</h1>\n```\n　　所对应的中间函数：\n```javascript\nfunction () {\n  var out = '';\n  out += '<h1>';\n  out += escape(1 + 1);\n  out += '</h1>';\n  return new String(out);\n}\n```\n　　中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。\n\n　　可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成\n\n```'\n<h1>' + escape(1 + 1) + '</h1>'\n```\n　　这种格式呢？因为需要支持各种看起来高大上的模板语法，如`if`、`each`之类的。\n\n---\n\n　　好像有点跑题，刚才的问题是，我如何将`cheerio`模块加入到`ejs`中呢？\n\n\n\n　　我们都知道，`ejs`中如果要将某些变量的值带到模板中渲染，需要在render时传递`locals`对象，在这个对象里存储所有渲染需要的变量。\n\n　　但实际上在使用模板引擎时，我们并不会使用名叫`locals`或者其他类似`data`之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）\n```javascript\nfunction(locals){\n  with(locals){\n  ......\n  }\n}\n```\n　　模板引擎将传入的`locals`对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传`locals`对象的时候丢进去：\n```javascript\nvar cheerio = require('cheerio');\nres.render('index',{ $:cheerio } );\n```\n\n　　这样子就能实现在`ejs`里实现类似这样的jq语法了\n```javascript\n<% for(var i = 0; i < 10; i++) {%>\n    <%- $('<a>').text(i.toString()).attr('href','#') %>\n<% } %>\n```","source":"_posts/javascript模板渲染研究笔记（一）.md","raw":"---\ntitle: javascript模板渲染研究笔记（一）  \nsubtitle: \ndesc: 下面没有了\ndate: 2015-12-31 9:49:32\ntags: javascript\nauthor: ngtmuzi  \ncategory: 班门弄斧  \n---\n　　只是一名本分的后端`nodejs`程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（`angular`、`reactjs`、`vue`、`meteor`以及各种其他）之后，我最终还是决定使用`express`自带的`ejs`\n \n　　即使是各大主流框架，在很大程度上还是离不开`jquery`，我当然也是如此，使用`ejs`仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。\n\n　　然而`ejs`使用中也是各种不爽，在`html`中加上各种`<%%>`真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（`reactjs`的`jsx语法`在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的`jquery`，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了\n\n　　因此我开始研究在`ejs`中加入jq的功能，`cheerio`模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——\n\n　　去翻了一下`ejs`的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言\n```ejs\n<h1>{{ 1+1 }}</h1>\n```\n　　所对应的中间函数：\n```javascript\nfunction () {\n  var out = '';\n  out += '<h1>';\n  out += escape(1 + 1);\n  out += '</h1>';\n  return new String(out);\n}\n```\n　　中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。\n\n　　可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成\n\n```'\n<h1>' + escape(1 + 1) + '</h1>'\n```\n　　这种格式呢？因为需要支持各种看起来高大上的模板语法，如`if`、`each`之类的。\n\n---\n\n　　好像有点跑题，刚才的问题是，我如何将`cheerio`模块加入到`ejs`中呢？\n\n\n\n　　我们都知道，`ejs`中如果要将某些变量的值带到模板中渲染，需要在render时传递`locals`对象，在这个对象里存储所有渲染需要的变量。\n\n　　但实际上在使用模板引擎时，我们并不会使用名叫`locals`或者其他类似`data`之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）\n```javascript\nfunction(locals){\n  with(locals){\n  ......\n  }\n}\n```\n　　模板引擎将传入的`locals`对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传`locals`对象的时候丢进去：\n```javascript\nvar cheerio = require('cheerio');\nres.render('index',{ $:cheerio } );\n```\n\n　　这样子就能实现在`ejs`里实现类似这样的jq语法了\n```javascript\n<% for(var i = 0; i < 10; i++) {%>\n    <%- $('<a>').text(i.toString()).attr('href','#') %>\n<% } %>\n```","slug":"javascript模板渲染研究笔记（一）","published":1,"updated":"2017-01-23T02:27:30.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7xw000bfkmxqouthw1r","content":"<p>　　只是一名本分的后端<code>nodejs</code>程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（<code>angular</code>、<code>reactjs</code>、<code>vue</code>、<code>meteor</code>以及各种其他）之后，我最终还是决定使用<code>express</code>自带的<code>ejs</code></p>\n<p>　　即使是各大主流框架，在很大程度上还是离不开<code>jquery</code>，我当然也是如此，使用<code>ejs</code>仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。</p>\n<p>　　然而<code>ejs</code>使用中也是各种不爽，在<code>html</code>中加上各种<code>&lt;%%&gt;</code>真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（<code>reactjs</code>的<code>jsx语法</code>在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的<code>jquery</code>，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了</p>\n<p>　　因此我开始研究在<code>ejs</code>中加入jq的功能，<code>cheerio</code>模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——</p>\n<p>　　去翻了一下<code>ejs</code>的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&#123;&#123; 1+1 &#125;&#125;&lt;/h1&gt;</div></pre></td></tr></table></figure></p>\n<p>　　所对应的中间函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> out = <span class=\"string\">''</span>;</div><div class=\"line\">  out += <span class=\"string\">'&lt;h1&gt;'</span>;</div><div class=\"line\">  out += <span class=\"built_in\">escape</span>(<span class=\"number\">1</span> + <span class=\"number\">1</span>);</div><div class=\"line\">  out += <span class=\"string\">'&lt;/h1&gt;'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(out);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。</p>\n<p>　　可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&apos; + escape(1 + 1) + &apos;&lt;/h1&gt;&apos;</div></pre></td></tr></table></figure>\n<p>　　这种格式呢？因为需要支持各种看起来高大上的模板语法，如<code>if</code>、<code>each</code>之类的。</p>\n<hr>\n<p>　　好像有点跑题，刚才的问题是，我如何将<code>cheerio</code>模块加入到<code>ejs</code>中呢？</p>\n<p>　　我们都知道，<code>ejs</code>中如果要将某些变量的值带到模板中渲染，需要在render时传递<code>locals</code>对象，在这个对象里存储所有渲染需要的变量。</p>\n<p>　　但实际上在使用模板引擎时，我们并不会使用名叫<code>locals</code>或者其他类似<code>data</code>之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">locals</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">with</span>(locals)&#123;</div><div class=\"line\">  ......</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　模板引擎将传入的<code>locals</code>对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传<code>locals</code>对象的时候丢进去：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>);</div><div class=\"line\">res.render(<span class=\"string\">'index'</span>,&#123; <span class=\"attr\">$</span>:cheerio &#125; );</div></pre></td></tr></table></figure></p>\n<p>　　这样子就能实现在<code>ejs</code>里实现类似这样的jq语法了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;%&gt;</div><div class=\"line\">    &lt;%- $('&lt;a&gt;').text(i.toString()).attr('href','#') %&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>　　只是一名本分的后端<code>nodejs</code>程序员的我被抓去写前端啦，前端各种东西都搞不懂啊，城里人真是会玩，各种框架各种脚本各种自动化各种模板渲染引擎各种转码，我也是被吓得不敢说话，然而代码还是要写的，研究了一通目前的各种主流框架（<code>angular</code>、<code>reactjs</code>、<code>vue</code>、<code>meteor</code>以及各种其他）之后，我最终还是决定使用<code>express</code>自带的<code>ejs</code></p>\n<p>　　即使是各大主流框架，在很大程度上还是离不开<code>jquery</code>，我当然也是如此，使用<code>ejs</code>仅仅是想将一些数据直接在后端渲染好，避免提供过多没必要的ajax接口费时费力。</p>\n<p>　　然而<code>ejs</code>使用中也是各种不爽，在<code>html</code>中加上各种<code>&lt;%%&gt;</code>真是不怎么好看啊，有的时候webstorm显示出来好多错误，排版也炸了，写得真心累，然后想了想，为什么一定要在视图中加上一堆逻辑语句呢，这种写法实在难看（<code>reactjs</code>的<code>jsx语法</code>在我眼中当然觉得更难看），然后脑洞一开，我就想到了万能的<code>jquery</code>，jq创建新html元素的语法简直优雅，所有的属性操作都能通过js来完成，就可以远离那些不合常理的模板语言了</p>\n<p>　　因此我开始研究在<code>ejs</code>中加入jq的功能，<code>cheerio</code>模块包含了各种jq的核心功能，它通常的用途是html解析，做抓取之类的功能，然而它构建html元素的函数任然还保留着，因此可以将它加入到ejs里，使用更优雅的语法来构建html——</p>\n<p>　　去翻了一下<code>ejs</code>的源码，大概能理解模板引擎的运行原理了：将原有的模板字符串拆开，将模板符号中包含的代码或表达式进行相应的处理，然后再拼回完整的html……可能说得不是很明白，可以看看这样一段模板语言<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&#123;&#123; 1+1 &#125;&#125;&lt;/h1&gt;</div></pre></td></tr></table></figure></p>\n<p>　　所对应的中间函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> out = <span class=\"string\">''</span>;</div><div class=\"line\">  out += <span class=\"string\">'&lt;h1&gt;'</span>;</div><div class=\"line\">  out += <span class=\"built_in\">escape</span>(<span class=\"number\">1</span> + <span class=\"number\">1</span>);</div><div class=\"line\">  out += <span class=\"string\">'&lt;/h1&gt;'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(out);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　中间函数做了简化，实际上它还在我们看不见的地方做更多复杂的操作，以使我们能使用简单的语言来进行模板渲染。</p>\n<p>　　可以看出来它实际上是做了字符串的拼接操作，模板内包含的表达式也被转义后输出（防止嵌入html标签），那为什么不直接转义成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&apos; + escape(1 + 1) + &apos;&lt;/h1&gt;&apos;</div></pre></td></tr></table></figure>\n<p>　　这种格式呢？因为需要支持各种看起来高大上的模板语法，如<code>if</code>、<code>each</code>之类的。</p>\n<hr>\n<p>　　好像有点跑题，刚才的问题是，我如何将<code>cheerio</code>模块加入到<code>ejs</code>中呢？</p>\n<p>　　我们都知道，<code>ejs</code>中如果要将某些变量的值带到模板中渲染，需要在render时传递<code>locals</code>对象，在这个对象里存储所有渲染需要的变量。</p>\n<p>　　但实际上在使用模板引擎时，我们并不会使用名叫<code>locals</code>或者其他类似<code>data</code>之类的变量，而是能直接使用这个变量里提供的属性，原因是，在上面那个函数里，一般还会有类似这样的语句（或者以其他方式实现）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">locals</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">with</span>(locals)&#123;</div><div class=\"line\">  ......</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　模板引擎将传入的<code>locals</code>对象使用with语句添加到当前作用域中，使我们能直接通过属性名来取值，因此想要加入$对象，可以直接在传<code>locals</code>对象的时候丢进去：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>);</div><div class=\"line\">res.render(<span class=\"string\">'index'</span>,&#123; <span class=\"attr\">$</span>:cheerio &#125; );</div></pre></td></tr></table></figure></p>\n<p>　　这样子就能实现在<code>ejs</code>里实现类似这样的jq语法了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;%&gt;</div><div class=\"line\">    &lt;%- $('&lt;a&gt;').text(i.toString()).attr('href','#') %&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure></p>\n"},{"title":"mingw32缺少posix_memalign函数","desc":"瞎玩","date":"2015-11-30T02:40:47.000Z","author":"ngtmuzi","_content":"　　想在`windows`上研究`word2vec`，于是查了一下如何`make`之类的东西，装好`mingw32`之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数`_aligned_malloc`，但是参数格式不一样，那还是自己动手吧：\n```c\nfunction posix_memalign( void ** memptr, size_t alignment, size_t size){\n  (* memptr) = _aligned_malloc(size, alignment);\n}\n```\n　　这样就可以编译通过了","source":"_posts/mingw32缺少posix_memalign函数.md","raw":"---\ntitle: mingw32缺少posix_memalign函数    \ndesc: 瞎玩 \ndate: 2015-11-30 10:40:47.000\ntags: C++\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n　　想在`windows`上研究`word2vec`，于是查了一下如何`make`之类的东西，装好`mingw32`之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数`_aligned_malloc`，但是参数格式不一样，那还是自己动手吧：\n```c\nfunction posix_memalign( void ** memptr, size_t alignment, size_t size){\n  (* memptr) = _aligned_malloc(size, alignment);\n}\n```\n　　这样就可以编译通过了","slug":"mingw32缺少posix_memalign函数","published":1,"updated":"2017-01-23T02:27:30.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7xy000ffkmxhoaqwhui","content":"<p>　　想在<code>windows</code>上研究<code>word2vec</code>，于是查了一下如何<code>make</code>之类的东西，装好<code>mingw32</code>之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数<code>_aligned_malloc</code>，但是参数格式不一样，那还是自己动手吧：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">function <span class=\"title\">posix_memalign</span><span class=\"params\">( <span class=\"keyword\">void</span> ** memptr, <span class=\"keyword\">size_t</span> alignment, <span class=\"keyword\">size_t</span> size)</span></span>&#123;</div><div class=\"line\">  (* memptr) = _aligned_malloc(size, alignment);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　这样就可以编译通过了</p>\n","excerpt":"","more":"<p>　　想在<code>windows</code>上研究<code>word2vec</code>，于是查了一下如何<code>make</code>之类的东西，装好<code>mingw32</code>之后编译的时候总是报错说找不到这个函数，查了半天百度，结论大概就是没有，不过有类似的函数<code>_aligned_malloc</code>，但是参数格式不一样，那还是自己动手吧：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">function <span class=\"title\">posix_memalign</span><span class=\"params\">( <span class=\"keyword\">void</span> ** memptr, <span class=\"keyword\">size_t</span> alignment, <span class=\"keyword\">size_t</span> size)</span></span>&#123;</div><div class=\"line\">  (* memptr) = _aligned_malloc(size, alignment);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　　这样就可以编译通过了</p>\n"},{"title":"个人博客绝赞内测中","subtitle":"来自hexo","desc":"现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧","date":"2015-11-29T10:29:53.000Z","author":"ngtmuzi","_content":"　　现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧","source":"_posts/个人博客绝赞内测中.md","raw":"---\ntitle: 个人博客绝赞内测中  \nsubtitle: 来自hexo  \ndesc: 现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧\ndate: 2015-11-29 18:29:53\ntags:  \nauthor: ngtmuzi  \ncategory: 随笔  \n---\n　　现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧","slug":"个人博客绝赞内测中","published":1,"updated":"2017-01-23T02:24:43.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7y0000ifkmxyjvzjgsx","content":"<p>　　现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧</p>\n","excerpt":"","more":"<p>　　现在只是一个码农，如果没有个地方给自己打字的话会很难受的，算是边做边学， 做个博客出来看看吧</p>\n"},{"title":"博客迁移到hexo","date":"2017-01-22T08:56:56.000Z","author":"ngtmuzi","_content":"　　博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~","source":"_posts/博客迁移到hexo.md","raw":"---\ntitle: 博客迁移到hexo\ndate: 2017-01-22 16:56:56\ncategory: 随笔\nauthor: ngtmuzi\n---\n　　博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~","slug":"博客迁移到hexo","published":1,"updated":"2017-01-23T02:24:43.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7y3000mfkmx7puhpvwy","content":"<p>　　博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~</p>\n","excerpt":"","more":"<p>　　博客还是迁到hexo吧，自己写虽然也能写出来，但是要考虑的地方太多，页面也不如现成的好看~</p>\n"},{"title":"自己撸一个Promise库的过程","desc":"因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧","date":"2017-01-19T01:54:47.349Z","author":"ngtmuzi","_content":"　　新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，`Promise`从ES6出来就用到现在，`then/catch`那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下\n\n## 参考资料：\n\n>[Promises/A+规范](https://promisesaplus.com/)  \n>[崔鹏飞的博客](http://cuipengfei.me/blog/2016/05/15/promise/)  \n>[Promise测试库](https://github.com/promises-aplus/promises-tests)\n\n　　从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。\n\n## 注意点\n　　因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：\n\n* 三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)\n* **规范2.2.4**：`onFulfilled`或`onRejected`在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使`Promise`已经`resolved`），而常用的异步执行函数就是`setTimeout`、`setImmediate`以及node特有的`process.nextTick`等函数，具体函数的不同会影响到整个`Promise`执行的效率，这里可以关注一下\n* **规范2.2.6.1**：当`Promise`进入完成状态，所有`onFulfilled`都需要按它们调用`then`的顺序来触发；这里隐含了一个点：`then`里传进去的函数是通过主动回调来触发的，也就是说`Promise`本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少\n* **规范2.3**：Promise解决程序，规范里将它表示为`[[Resolve]](promise, x)`，实际上就是写一个函数，输入一个未完成的`promise`和值`x`，通过一系列规则判断，以确定这个`promise`最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进`x.then`的函数仅能被调用一次，全程记得用`try-catch`包裹\n\n　　这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些`bluebird`的常用方法，比如`try`、`all`、`map`之类的，对理解代码逻辑很有帮助。\n\n　　附上[我的Promise库](https://github.com/ngtmuzi/np/blob/master/index.js)。另外要说一句，多尝试`new Promise()`来自己封装异步代码，我是见过不少同事只懂从`Promise.resolve()`开始的，那就弄丢了Promise最强大的部分","source":"_posts/自己撸一个Promise库的过程.md","raw":"---\ntitle: 自己撸一个Promise库的过程\ndesc: 因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧  \ndate: 2017-1-19 9:54:47.349\ntags: \n- Promise\n- ES6  \nauthor: ngtmuzi  \ncategory: 班门弄斧\n---\n　　新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，`Promise`从ES6出来就用到现在，`then/catch`那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下\n\n## 参考资料：\n\n>[Promises/A+规范](https://promisesaplus.com/)  \n>[崔鹏飞的博客](http://cuipengfei.me/blog/2016/05/15/promise/)  \n>[Promise测试库](https://github.com/promises-aplus/promises-tests)\n\n　　从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。\n\n## 注意点\n　　因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：\n\n* 三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)\n* **规范2.2.4**：`onFulfilled`或`onRejected`在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使`Promise`已经`resolved`），而常用的异步执行函数就是`setTimeout`、`setImmediate`以及node特有的`process.nextTick`等函数，具体函数的不同会影响到整个`Promise`执行的效率，这里可以关注一下\n* **规范2.2.6.1**：当`Promise`进入完成状态，所有`onFulfilled`都需要按它们调用`then`的顺序来触发；这里隐含了一个点：`then`里传进去的函数是通过主动回调来触发的，也就是说`Promise`本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少\n* **规范2.3**：Promise解决程序，规范里将它表示为`[[Resolve]](promise, x)`，实际上就是写一个函数，输入一个未完成的`promise`和值`x`，通过一系列规则判断，以确定这个`promise`最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进`x.then`的函数仅能被调用一次，全程记得用`try-catch`包裹\n\n　　这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些`bluebird`的常用方法，比如`try`、`all`、`map`之类的，对理解代码逻辑很有帮助。\n\n　　附上[我的Promise库](https://github.com/ngtmuzi/np/blob/master/index.js)。另外要说一句，多尝试`new Promise()`来自己封装异步代码，我是见过不少同事只懂从`Promise.resolve()`开始的，那就弄丢了Promise最强大的部分","slug":"自己撸一个Promise库的过程","published":1,"updated":"2017-01-23T02:57:28.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7y5000ofkmx1dgwyt5d","content":"<p>　　新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，<code>Promise</code>从ES6出来就用到现在，<code>then/catch</code>那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><blockquote>\n<p><a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"external\">Promises/A+规范</a><br><a href=\"http://cuipengfei.me/blog/2016/05/15/promise/\" target=\"_blank\" rel=\"external\">崔鹏飞的博客</a><br><a href=\"https://github.com/promises-aplus/promises-tests\" target=\"_blank\" rel=\"external\">Promise测试库</a></p>\n</blockquote>\n<p>　　从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>　　因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：</p>\n<ul>\n<li>三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)</li>\n<li><strong>规范2.2.4</strong>：<code>onFulfilled</code>或<code>onRejected</code>在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使<code>Promise</code>已经<code>resolved</code>），而常用的异步执行函数就是<code>setTimeout</code>、<code>setImmediate</code>以及node特有的<code>process.nextTick</code>等函数，具体函数的不同会影响到整个<code>Promise</code>执行的效率，这里可以关注一下</li>\n<li><strong>规范2.2.6.1</strong>：当<code>Promise</code>进入完成状态，所有<code>onFulfilled</code>都需要按它们调用<code>then</code>的顺序来触发；这里隐含了一个点：<code>then</code>里传进去的函数是通过主动回调来触发的，也就是说<code>Promise</code>本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少</li>\n<li><strong>规范2.3</strong>：Promise解决程序，规范里将它表示为<code>[[Resolve]](promise, x)</code>，实际上就是写一个函数，输入一个未完成的<code>promise</code>和值<code>x</code>，通过一系列规则判断，以确定这个<code>promise</code>最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进<code>x.then</code>的函数仅能被调用一次，全程记得用<code>try-catch</code>包裹</li>\n</ul>\n<p>　　这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些<code>bluebird</code>的常用方法，比如<code>try</code>、<code>all</code>、<code>map</code>之类的，对理解代码逻辑很有帮助。</p>\n<p>　　附上<a href=\"https://github.com/ngtmuzi/np/blob/master/index.js\" target=\"_blank\" rel=\"external\">我的Promise库</a>。另外要说一句，多尝试<code>new Promise()</code>来自己封装异步代码，我是见过不少同事只懂从<code>Promise.resolve()</code>开始的，那就弄丢了Promise最强大的部分</p>\n","excerpt":"","more":"<p>　　新年第一篇博客，写了一年多的JS，感觉只是弄懂了皮毛，没有好好的钻研过，关于前端那方面更是完全空白，看了别人的面试经历后深感忧虑。正好年前比较闲，重构的项目也基本稳定了，于是就无聊想研究下代码，<code>Promise</code>从ES6出来就用到现在，<code>then/catch</code>那一套倒是很熟了，但还是不清楚里面的原理，就趁此机会深入理解一下</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><blockquote>\n<p><a href=\"https://promisesaplus.com/\">Promises/A+规范</a><br><a href=\"http://cuipengfei.me/blog/2016/05/15/promise/\">崔鹏飞的博客</a><br><a href=\"https://github.com/promises-aplus/promises-tests\">Promise测试库</a></p>\n</blockquote>\n<p>　　从我的结果来说，按照规范上的规则一行一行地写，配合测试库一遍一遍地跑，基本上都能完成代码，而且还有一种类似闯关的感觉（参见提交记录），挺爽，可以试试。</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>　　因为规范说得实在太够详细了，基本也没什么好介绍的了，说下一些需要注意的点吧：</p>\n<ul>\n<li>三个状态，运行中(pending)，已完成(resolved)，已失败(rejected)</li>\n<li><strong>规范2.2.4</strong>：<code>onFulfilled</code>或<code>onRejected</code>在运行至上下文堆栈仅剩平台代码前不能运行；说得很绕，主要是指这2个函数需要异步执行（即使<code>Promise</code>已经<code>resolved</code>），而常用的异步执行函数就是<code>setTimeout</code>、<code>setImmediate</code>以及node特有的<code>process.nextTick</code>等函数，具体函数的不同会影响到整个<code>Promise</code>执行的效率，这里可以关注一下</li>\n<li><strong>规范2.2.6.1</strong>：当<code>Promise</code>进入完成状态，所有<code>onFulfilled</code>都需要按它们调用<code>then</code>的顺序来触发；这里隐含了一个点：<code>then</code>里传进去的函数是通过主动回调来触发的，也就是说<code>Promise</code>本质上是回调的封装，只是对状态和规范做了严格限制，使得最后使用的时候方便不少</li>\n<li><strong>规范2.3</strong>：Promise解决程序，规范里将它表示为<code>[[Resolve]](promise, x)</code>，实际上就是写一个函数，输入一个未完成的<code>promise</code>和值<code>x</code>，通过一系列规则判断，以确定这个<code>promise</code>最后的状态。这部分就是Promise规范的核心了，因为规则写得十分详细，照着来写基本都可以过，关注点：要保证自己传进<code>x.then</code>的函数仅能被调用一次，全程记得用<code>try-catch</code>包裹</li>\n</ul>\n<p>　　这样基本就差不多了，从零写出来之后对Promise理解还是增加了不少的，之后可以尝试加入一些<code>bluebird</code>的常用方法，比如<code>try</code>、<code>all</code>、<code>map</code>之类的，对理解代码逻辑很有帮助。</p>\n<p>　　附上<a href=\"https://github.com/ngtmuzi/np/blob/master/index.js\">我的Promise库</a>。另外要说一句，多尝试<code>new Promise()</code>来自己封装异步代码，我是见过不少同事只懂从<code>Promise.resolve()</code>开始的，那就弄丢了Promise最强大的部分</p>\n"},{"title":"实现一个简单的promise队列","desc":"promise本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。","date":"2016-09-18T14:34:48.448Z","author":"ngtmuzi","_content":"　　来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。\n出于对接方的强烈要求要改，很直观的改进方案就是用队列，原来的系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是`promise`写的，做流程控制好歹比callback简单多了，于是思路如下：\n\n* `promise`本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。\n\n* 队列本身要有节流功能，即可以控制同一时间内在运行的`promise`数量，参考`bluebird`的`map`函数中的concurrency(并发)字段。\n\n　　其实大体思路就是模仿bluebird中的map函数，不同点在于map是处理一个固定的数组，且会结束（当然可以动态地修改该数组，但不推荐），而队列会一直待机处理（伪，实际是队列有改动时才做检查）  \n　　于是完成代码：[promiseQueue.js](https://github.com/ngtmuzi/wheel/blob/master/tools/promiseQueue.js)  \n　　运行起来的感觉类似这样\n```javascript\nconst a = Queue(2);\nconst delay = () => Promise.delay(1000,new Date());\n\na.add(delay).then(console.log);\na.add(delay).then(console.log);\na.add(delay).then(console.log);\n```\n　　并发数是2，因此第3个promise会在前面1个执行完后才开始执行，运行结果\n```\n//2016-09-18T14:29:26.490Z\n//2016-09-18T14:29:26.491Z\n//2016-09-18T14:29:27.495Z\n```\n　　这个轮子的重点是，原代码是`delay().then(...)`，现在改为`a.add(delay).then(...)`，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解","source":"_posts/实现一个简单的promise队列.md","raw":"---\ntitle: 实现一个简单的promise队列\ndesc: promise本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。  \ndate: 2016-9-18 22:34:48.448\ntags: \n- javascript\n- Promise\n- ES6\nauthor: ngtmuzi  \ncategory: 神秘代码  \n---\n　　来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。\n出于对接方的强烈要求要改，很直观的改进方案就是用队列，原来的系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是`promise`写的，做流程控制好歹比callback简单多了，于是思路如下：\n\n* `promise`本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。\n\n* 队列本身要有节流功能，即可以控制同一时间内在运行的`promise`数量，参考`bluebird`的`map`函数中的concurrency(并发)字段。\n\n　　其实大体思路就是模仿bluebird中的map函数，不同点在于map是处理一个固定的数组，且会结束（当然可以动态地修改该数组，但不推荐），而队列会一直待机处理（伪，实际是队列有改动时才做检查）  \n　　于是完成代码：[promiseQueue.js](https://github.com/ngtmuzi/wheel/blob/master/tools/promiseQueue.js)  \n　　运行起来的感觉类似这样\n```javascript\nconst a = Queue(2);\nconst delay = () => Promise.delay(1000,new Date());\n\na.add(delay).then(console.log);\na.add(delay).then(console.log);\na.add(delay).then(console.log);\n```\n　　并发数是2，因此第3个promise会在前面1个执行完后才开始执行，运行结果\n```\n//2016-09-18T14:29:26.490Z\n//2016-09-18T14:29:26.491Z\n//2016-09-18T14:29:27.495Z\n```\n　　这个轮子的重点是，原代码是`delay().then(...)`，现在改为`a.add(delay).then(...)`，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解","slug":"实现一个简单的promise队列","published":1,"updated":"2017-01-23T03:05:01.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy9pk7y7000sfkmxap3owpvh","content":"<p>　　来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。<br>出于对接方的强烈要求要改，很直观的改进方案就是用队列，原来的系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是<code>promise</code>写的，做流程控制好歹比callback简单多了，于是思路如下：</p>\n<ul>\n<li><p><code>promise</code>本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。</p>\n</li>\n<li><p>队列本身要有节流功能，即可以控制同一时间内在运行的<code>promise</code>数量，参考<code>bluebird</code>的<code>map</code>函数中的concurrency(并发)字段。</p>\n</li>\n</ul>\n<p>　　其实大体思路就是模仿bluebird中的map函数，不同点在于map是处理一个固定的数组，且会结束（当然可以动态地修改该数组，但不推荐），而队列会一直待机处理（伪，实际是队列有改动时才做检查）<br>　　于是完成代码：<a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/promiseQueue.js\" target=\"_blank\" rel=\"external\">promiseQueue.js</a><br>　　运行起来的感觉类似这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> a = Queue(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.delay(<span class=\"number\">1000</span>,<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());</div><div class=\"line\"></div><div class=\"line\">a.add(delay).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\">a.add(delay).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\">a.add(delay).then(<span class=\"built_in\">console</span>.log);</div></pre></td></tr></table></figure></p>\n<p>　　并发数是2，因此第3个promise会在前面1个执行完后才开始执行，运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//2016-09-18T14:29:26.490Z</div><div class=\"line\">//2016-09-18T14:29:26.491Z</div><div class=\"line\">//2016-09-18T14:29:27.495Z</div></pre></td></tr></table></figure></p>\n<p>　　这个轮子的重点是，原代码是<code>delay().then(...)</code>，现在改为<code>a.add(delay).then(...)</code>，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解</p>\n","excerpt":"","more":"<p>　　来自一个很现实的需求，有个业务只能串行执行，原来的代码的逻辑是弄个全局锁变量，当新的请求来的时候检查变量，在锁时直接返回错误让对方做重试，非常暴力。<br>出于对接方的强烈要求要改，很直观的改进方案就是用队列，原来的系统是个用redis实现的伪消息队列，来多少推多少，根本做不到控流，而在代码内加队列又要考虑不能对原来的代码有太大改动（150行严重缩进横跨3个系统的业务代码，怼不动），还好原代码就是<code>promise</code>写的，做流程控制好歹比callback简单多了，于是思路如下：</p>\n<ul>\n<li><p><code>promise</code>本身的特性就是“保证在未来某一时刻会完成”，因此可以透明地加入队列，只要在未来某一时刻取出并处理，就可以继续向后执行原有代码，不会改变原有结构。</p>\n</li>\n<li><p>队列本身要有节流功能，即可以控制同一时间内在运行的<code>promise</code>数量，参考<code>bluebird</code>的<code>map</code>函数中的concurrency(并发)字段。</p>\n</li>\n</ul>\n<p>　　其实大体思路就是模仿bluebird中的map函数，不同点在于map是处理一个固定的数组，且会结束（当然可以动态地修改该数组，但不推荐），而队列会一直待机处理（伪，实际是队列有改动时才做检查）<br>　　于是完成代码：<a href=\"https://github.com/ngtmuzi/wheel/blob/master/tools/promiseQueue.js\">promiseQueue.js</a><br>　　运行起来的感觉类似这样<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> a = Queue(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">Promise</span>.delay(<span class=\"number\">1000</span>,<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());</div><div class=\"line\"></div><div class=\"line\">a.add(delay).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\">a.add(delay).then(<span class=\"built_in\">console</span>.log);</div><div class=\"line\">a.add(delay).then(<span class=\"built_in\">console</span>.log);</div></pre></td></tr></table></figure></p>\n<p>　　并发数是2，因此第3个promise会在前面1个执行完后才开始执行，运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//2016-09-18T14:29:26.490Z</div><div class=\"line\">//2016-09-18T14:29:26.491Z</div><div class=\"line\">//2016-09-18T14:29:27.495Z</div></pre></td></tr></table></figure></p>\n<p>　　这个轮子的重点是，原代码是<code>delay().then(...)</code>，现在改为<code>a.add(delay).then(...)</code>，业务逻辑仍旧能跟在后面，原代码改动比较小，也易于理解</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ciy9pk7x60000fkmxo4lol2it","category_id":"ciy9pk7xh0002fkmxaia476oi","_id":"ciy9pk7xv000afkmxr04p1k7m"},{"post_id":"ciy9pk7xs0006fkmx1qznahr8","category_id":"ciy9pk7xh0002fkmxaia476oi","_id":"ciy9pk7xy000efkmxzsz1jf8b"},{"post_id":"ciy9pk7xa0001fkmx72pgr4jl","category_id":"ciy9pk7xh0002fkmxaia476oi","_id":"ciy9pk7y0000hfkmxz51a1zk1"},{"post_id":"ciy9pk7xy000ffkmxhoaqwhui","category_id":"ciy9pk7xh0002fkmxaia476oi","_id":"ciy9pk7y5000nfkmx418v3yf0"},{"post_id":"ciy9pk7xk0004fkmxw9els4n1","category_id":"ciy9pk7xh0002fkmxaia476oi","_id":"ciy9pk7y7000qfkmxiq2ejx0l"},{"post_id":"ciy9pk7xn0005fkmxo53neyv7","category_id":"ciy9pk7y1000jfkmxrkc2sl4a","_id":"ciy9pk7y9000tfkmxwg7zh6r5"},{"post_id":"ciy9pk7y5000ofkmx1dgwyt5d","category_id":"ciy9pk7y1000jfkmxrkc2sl4a","_id":"ciy9pk7ya000vfkmxls9oytce"},{"post_id":"ciy9pk7y7000sfkmxap3owpvh","category_id":"ciy9pk7xh0002fkmxaia476oi","_id":"ciy9pk7ya000xfkmxjmidsh4d"},{"post_id":"ciy9pk7xu0009fkmxnyruwqmy","category_id":"ciy9pk7y1000jfkmxrkc2sl4a","_id":"ciy9pk7yb000zfkmxfwc2yeo0"},{"post_id":"ciy9pk7xw000bfkmxqouthw1r","category_id":"ciy9pk7y1000jfkmxrkc2sl4a","_id":"ciy9pk7yb0011fkmx0v0pt7b4"},{"post_id":"ciy9pk7y0000ifkmxyjvzjgsx","category_id":"ciy9pk7ya000yfkmxfyaqsy52","_id":"ciy9pk7yf0017fkmx7hfx23t9"},{"post_id":"ciy9pk7y3000mfkmx7puhpvwy","category_id":"ciy9pk7ya000yfkmxfyaqsy52","_id":"ciy9pk7yh001afkmx3zmm1yj0"}],"PostTag":[{"post_id":"ciy9pk7x60000fkmxo4lol2it","tag_id":"ciy9pk7xk0003fkmxq8prytk4","_id":"ciy9pk7xz000gfkmxmppizfef"},{"post_id":"ciy9pk7x60000fkmxo4lol2it","tag_id":"ciy9pk7xt0008fkmx61fnn1iv","_id":"ciy9pk7y1000kfkmx9lgsnt1q"},{"post_id":"ciy9pk7xa0001fkmx72pgr4jl","tag_id":"ciy9pk7xx000dfkmxo748wpqd","_id":"ciy9pk7yd0012fkmxgc4zgy7z"},{"post_id":"ciy9pk7xa0001fkmx72pgr4jl","tag_id":"ciy9pk7y2000lfkmxjaul7nmz","_id":"ciy9pk7yd0014fkmxggpid0h9"},{"post_id":"ciy9pk7xa0001fkmx72pgr4jl","tag_id":"ciy9pk7y7000rfkmxyiwo27i6","_id":"ciy9pk7yf0016fkmx4hhozbe7"},{"post_id":"ciy9pk7xa0001fkmx72pgr4jl","tag_id":"ciy9pk7ya000wfkmxnkljzhpw","_id":"ciy9pk7yg0018fkmxuv9wlcg5"},{"post_id":"ciy9pk7xk0004fkmxw9els4n1","tag_id":"ciy9pk7xk0003fkmxq8prytk4","_id":"ciy9pk7yh001bfkmxt7igdeex"},{"post_id":"ciy9pk7xk0004fkmxw9els4n1","tag_id":"ciy9pk7yd0015fkmxitq56rut","_id":"ciy9pk7yh001cfkmxdtx3del9"},{"post_id":"ciy9pk7xn0005fkmxo53neyv7","tag_id":"ciy9pk7xx000dfkmxo748wpqd","_id":"ciy9pk7yh001efkmxpo59l75z"},{"post_id":"ciy9pk7xs0006fkmx1qznahr8","tag_id":"ciy9pk7xx000dfkmxo748wpqd","_id":"ciy9pk7yj001ifkmx7aeuwss3"},{"post_id":"ciy9pk7xs0006fkmx1qznahr8","tag_id":"ciy9pk7yi001ffkmx81uibpul","_id":"ciy9pk7yj001jfkmx0eujqlus"},{"post_id":"ciy9pk7xs0006fkmx1qznahr8","tag_id":"ciy9pk7y2000lfkmxjaul7nmz","_id":"ciy9pk7yk001lfkmxq3d9farl"},{"post_id":"ciy9pk7xu0009fkmxnyruwqmy","tag_id":"ciy9pk7xk0003fkmxq8prytk4","_id":"ciy9pk7yl001ofkmxj1e100fi"},{"post_id":"ciy9pk7xu0009fkmxnyruwqmy","tag_id":"ciy9pk7xx000dfkmxo748wpqd","_id":"ciy9pk7yl001pfkmxu2ue2w5s"},{"post_id":"ciy9pk7xu0009fkmxnyruwqmy","tag_id":"ciy9pk7yj001kfkmxdcdvwwbh","_id":"ciy9pk7yl001rfkmxw49gn6kr"},{"post_id":"ciy9pk7xu0009fkmxnyruwqmy","tag_id":"ciy9pk7yk001mfkmx2qjlf7sr","_id":"ciy9pk7yl001sfkmxa657qbci"},{"post_id":"ciy9pk7xw000bfkmxqouthw1r","tag_id":"ciy9pk7xx000dfkmxo748wpqd","_id":"ciy9pk7ym001ufkmxvd21w598"},{"post_id":"ciy9pk7xy000ffkmxhoaqwhui","tag_id":"ciy9pk7yl001qfkmxvfgs9d1l","_id":"ciy9pk7yn001vfkmxhg5xpl0v"},{"post_id":"ciy9pk7y5000ofkmx1dgwyt5d","tag_id":"ciy9pk7y7000rfkmxyiwo27i6","_id":"ciy9pk7yp001yfkmx9yddqnlw"},{"post_id":"ciy9pk7y5000ofkmx1dgwyt5d","tag_id":"ciy9pk7ya000wfkmxnkljzhpw","_id":"ciy9pk7yp001zfkmxz8wsfk6p"},{"post_id":"ciy9pk7y7000sfkmxap3owpvh","tag_id":"ciy9pk7xx000dfkmxo748wpqd","_id":"ciy9pk7ys0021fkmxrw7018b8"},{"post_id":"ciy9pk7y7000sfkmxap3owpvh","tag_id":"ciy9pk7y7000rfkmxyiwo27i6","_id":"ciy9pk7yt0022fkmxcmo5rmgq"},{"post_id":"ciy9pk7y7000sfkmxap3owpvh","tag_id":"ciy9pk7ya000wfkmxnkljzhpw","_id":"ciy9pk7yt0023fkmxvoqueiyl"}],"Tag":[{"name":"nodejs","_id":"ciy9pk7xk0003fkmxq8prytk4"},{"name":"stream","_id":"ciy9pk7xt0008fkmx61fnn1iv"},{"name":"javascript","_id":"ciy9pk7xx000dfkmxo748wpqd"},{"name":"Proxy","_id":"ciy9pk7y2000lfkmxjaul7nmz"},{"name":"Promise","_id":"ciy9pk7y7000rfkmxyiwo27i6"},{"name":"ES6","_id":"ciy9pk7ya000wfkmxnkljzhpw"},{"name":"encoding","_id":"ciy9pk7yd0015fkmxitq56rut"},{"name":"es6","_id":"ciy9pk7yi001ffkmx81uibpul"},{"name":"promise","_id":"ciy9pk7yj001kfkmxdcdvwwbh"},{"name":"express","_id":"ciy9pk7yk001mfkmx2qjlf7sr"},{"name":"C++","_id":"ciy9pk7yl001qfkmxvfgs9d1l"}]}}